---
title: 函数柯里化
date: 2018-03-26 23:18:56
tags: ES6
---

> 最近在看阮一峰的《ES6入门》，在尾调用扩展中提到了函数柯里化。


一、什么是尾调用
==================
尾调用是函数式编程的一个概念，就是某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要在最后一步操作即可。

尾调用很特殊，函数调用会在内存中有一个调用帧，保存调用位置和内部变量等信息，函数嵌套调用形成一个调用栈。尾调用由于函数是最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等不会再用到了。

二、尾调用和尾递归
===============
函数调用本身叫做递归，尾调用自身就称为尾递归。递归由于需要保存很多个调用帧很容易发生栈溢出，但是对于尾递归来说，由于只存在一个调用栈所以不会发生栈溢出。 

三、尾递归的实现
================
终于要讲到函数柯里化(curring)。尾递归的实现往往是从递归函数改写而来的，改写的步骤就是把所有用到的内部变量改写成函数的参数。在递归函数改写成尾递归函数这里，没有函数柯里化什么事，函数柯里化是在尾递归改写完成后将多参数改写成单参数。先解释下柯里化的意思，指将多参数函数改写成单参数形式。

根据张鑫旭的博文[JS中的柯里化][1]中写道柯里化主要有三个作用：1.参数服用；2.提前返回；3.延迟计算/运行。

在本书中，关于柯里化的代码解释如下：
```javascript
function currying(fn,n){
    return function(m){
        return fn.call(this,m,n);
    }
}
function tailFactorial(n, total){
    if(n === 1) return total;
    return tailFactorial(n-1, n*total);
}

const factorial = curring(tailFactorial, 1);

factorial(5) //120
```
上面是一种笨拙的方法，这里，n指尾递归函数的参数默认值,m是尾递归参数真正的参数。以上代码将阶乘尾递归函数tailFactorial变成只接受一个参数的factorial.
同时，利用ES6的函数默认值也能实现上面的函数柯里化：
```javascript
function factorial(n, total=1){
    if(n === 1) return total;
    return factorial(n, n*total);
}
```



  [1]: http://www.zhangxinxu.com/wordpress/2013/02/js-currying/