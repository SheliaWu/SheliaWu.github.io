{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/uploads/eventloop.jpeg","path":"uploads/eventloop.jpeg","modified":0,"renderable":0},{"_id":"source/uploads/favicon.jpg","path":"uploads/favicon.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"source/uploads/avatar.png","path":"uploads/avatar.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/.DS_Store","hash":"36b821a89b6550c21fa12397ecc1ad7751d98397","modified":1555605297014},{"_id":"source/CNAME","hash":"cdf42bb1ae06123428a42229f0addeb6f48c2767","modified":1552831912069},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1555604864817},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1555604864817},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1555604864817},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1555604864818},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1555604864818},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1555604864818},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1555604864818},{"_id":"themes/yilia/_config.yml","hash":"c3a1694c111e2e1f05a174bd893fe951038fbda2","modified":1555604864818},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1555604864825},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1555604864838},{"_id":"source/_posts/.DS_Store","hash":"7890f981b04e1c69341d61c0adccd8c898f7c6d0","modified":1555605302023},{"_id":"source/_posts/AngularJS学习笔记一.md","hash":"b55af1191a42eaca143b2b52a4f706b96d08ba1c","modified":1552791864032},{"_id":"source/_posts/AngularJS学习笔记二.md","hash":"3f5d1a939aec5eb4e77deaf7fb5b369627f8b11c","modified":1552791864032},{"_id":"source/_posts/Bootstrap的核心特性.md","hash":"5b2db211aff3f4a7925b07c89783f283eb3f2ffc","modified":1552791864033},{"_id":"source/_posts/HEXO-GithubPages搭建博客指南.md","hash":"513125f20201150d3e408327546f4e85bf312257","modified":1552791864033},{"_id":"source/_posts/Less学习笔记一.md","hash":"517dc845f509e971d9e47a8c23f8a43d821baae3","modified":1552791864033},{"_id":"source/_posts/Less学习笔记二.md","hash":"27da2d2722de8da684ca1aa726242365925b4697","modified":1552791864033},{"_id":"source/_posts/canvas的几个知识点.md","hash":"5e0222602588005e062805685c5fa84abca8963b","modified":1552791864033},{"_id":"source/_posts/hello-world.md","hash":"8a02477044e2b77f1b262da2c48c01429e4a32e4","modified":1552791864033},{"_id":"source/_posts/jQuery中的常用事件.md","hash":"7e9e4b1e65cba7df5e887da46c2993802653c68a","modified":1552791864033},{"_id":"source/_posts/jQuery里的Ajax.md","hash":"e6471649fd7ef970f958f4e045acfc5ec5d523b1","modified":1552791864034},{"_id":"source/_posts/javascript的this笔记.md","hash":"53055dac6ca517a6318dbd961996c066aa112fcd","modified":1552791864034},{"_id":"source/_posts/js事件循环机制.md","hash":"7e00b0b79fd0dd8e803d48a4510bca0f2187304a","modified":1555260104778},{"_id":"source/_posts/js双重否定的小知识点.md","hash":"5c402f268c7da9620c67de6b8d2be2c73253f92b","modified":1552791864034},{"_id":"source/_posts/php图像合并.md","hash":"0e6731a585ba99da912de89937306f3e0a3ae859","modified":1552791864034},{"_id":"source/_posts/setTimeout在循环中.md","hash":"a62c54f2c80436c1d76a02cd8c03eafc7e4d7c86","modified":1552791864034},{"_id":"source/_posts/xss攻击.md","hash":"5ee76a0a6afc8b332d8d2f2e098e715b7b7ac03d","modified":1552791864034},{"_id":"source/_posts/函数柯里化.md","hash":"27b3024877c67c191276afd69060b0a27dbd43b3","modified":1552791864035},{"_id":"source/_posts/响应式web设计.md","hash":"8ce7a8bd38d519952356b0f52b148220f55078da","modified":1552791864035},{"_id":"source/_posts/循环中的redis读取性能问题.md","hash":"d5486b7d9643c0b96a989a8f1e08e28666837dcd","modified":1555601173404},{"_id":"source/_posts/微信公众号自定义菜单.md","hash":"660596d3d4c6d5f4fe73d665e9c36f9ef1f2b48d","modified":1552791864035},{"_id":"source/_posts/跨域.md","hash":"bea49e3e89af731b2d0ead9b6f73c92800955a31","modified":1552791864035},{"_id":"source/_posts/轮播图插件封装.md","hash":"0f62992a8fc6efb7db10b75e97ee1b60a7e7a6ab","modified":1552791864035},{"_id":"source/about/index.md","hash":"1b8ba212de27b8b2785e79ca31b3f1f5f2e5b011","modified":1552791864035},{"_id":"source/categories/index.md","hash":"d4e2b88a46022a66e967705efe054b72377312be","modified":1552791864035},{"_id":"source/uploads/eventloop.jpeg","hash":"b0747c0f9a0c5281060c8087bd5c593c8963f293","modified":1555259247719},{"_id":"source/uploads/favicon.jpg","hash":"b743f8174fa581c03d574eda8f1af3675be6834b","modified":1552791864039},{"_id":"source/tags/index.md","hash":"b32f4e6f30349f043b93d5343779b4469f269049","modified":1552791864036},{"_id":"themes/yilia/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1555604864813},{"_id":"themes/yilia/.git/config","hash":"256e47c5a4386e6881318e44d2a716fdc3197863","modified":1555604864814},{"_id":"themes/yilia/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1555604557086},{"_id":"themes/yilia/.git/index","hash":"62043718cf79a49f6e7a5275faa9ec3e00c6331f","modified":1555605340034},{"_id":"themes/yilia/.git/packed-refs","hash":"76b1aa9479dd3de329935b6d94a6624c5f716d23","modified":1555604864811},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1555604864818},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1555604864818},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1555604864818},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1555604864819},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1555604864819},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1555604864819},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1555604864819},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1555604864823},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1555604864824},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1555604864824},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1555604864824},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1555604864824},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1555604864824},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1555604864825},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1555604864836},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1555604864825},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1555604864838},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1555604864834},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1555604864823},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1555604864837},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1555604864837},{"_id":"themes/yilia/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1555604557086},{"_id":"themes/yilia/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1555604557086},{"_id":"themes/yilia/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1555604557086},{"_id":"themes/yilia/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1555604557086},{"_id":"themes/yilia/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1555604557087},{"_id":"themes/yilia/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1555604557087},{"_id":"themes/yilia/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1555604557086},{"_id":"themes/yilia/.git/logs/HEAD","hash":"e2ef1287c608174e79d7ad90ccb8c760efe88d70","modified":1555604864813},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1555604864819},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1555604864819},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1555604864819},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1555604864819},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"64f092186b5a744aa1603ce22bb1d44a34446add","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1555604864820},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1555604864823},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1555604864823},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1555604864834},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1555604864834},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1555604864835},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1555604864835},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1555604864835},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1555604864835},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1555604864835},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1555604864835},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1555604864836},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1555604864825},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1555604864825},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1555604864825},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1555604864826},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1555604864826},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1555604864826},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1555604864826},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1555604864826},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1555604864826},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1555604864827},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1555604864828},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1555604864828},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1555604864829},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1555604864829},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1555604864830},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1555604864830},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1555604864830},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1555604864830},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1555604864830},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1555604864831},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1555604864831},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1555604864831},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1555604864831},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1555604864831},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1555604864831},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"1b1aa0908e58cf942b28e3881d07c5573c4129e1","modified":1555604864831},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1555604864831},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1555604864832},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1555604864832},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1555604864832},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1555604864832},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1555604864833},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1555604864833},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1555604864833},{"_id":"themes/yilia/source-src/js/report.js","hash":"4f1d9a18a936ce40b037f636a39127dd19175b6e","modified":1555604864833},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1555604864833},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1555604864833},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1555604864833},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1555604864834},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1555604864822},{"_id":"themes/yilia/.git/objects/pack/pack-db2e8c7854ef417284a531f7f2e4126427dcb1c6.idx","hash":"a825f430536fd27fc10de5dc24bcc4e8facaa9b0","modified":1555604864804},{"_id":"themes/yilia/.git/refs/heads/master","hash":"4ed77da1a2617db0e77c3e3e190a1c79c16dfb9a","modified":1555604864813},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1555604864821},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1555604864822},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1555604864822},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1555604864822},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1555604864826},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1555604864826},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1555604864827},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1555604864827},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1555604864827},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1555604864827},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1555604864828},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1555604864829},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1555604864829},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1555604864830},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1555604864828},{"_id":"themes/yilia/.git/logs/refs/heads/master","hash":"e2ef1287c608174e79d7ad90ccb8c760efe88d70","modified":1555604864813},{"_id":"themes/yilia/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1555604864812},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1555604864828},{"_id":"themes/yilia/.git/logs/refs/remotes/origin/HEAD","hash":"e2ef1287c608174e79d7ad90ccb8c760efe88d70","modified":1555604864812},{"_id":"source/uploads/avatar.png","hash":"96a445805a3865a711398dcfc4a811b88e642cd2","modified":1552791864038},{"_id":"themes/yilia/.git/objects/pack/pack-db2e8c7854ef417284a531f7f2e4126427dcb1c6.pack","hash":"a4a12bf32fe7ce0e90369c0e504be9650efe0e7a","modified":1555604864804},{"_id":"public/about/index.html","hash":"03cb568dc0b748bfd22110e6b55642b60a7a5a36","modified":1555606461486},{"_id":"public/categories/index.html","hash":"15926754a70c3c19aad039931c6ce15cf4c0f5df","modified":1555606461486},{"_id":"public/tags/index.html","hash":"82f2c5e70dd856f056ef04d2bbb2b9d742dbfdb8","modified":1555606461486},{"_id":"public/2019/04/18/循环中的redis读取性能问题/index.html","hash":"bc94ae6beec6ed9c8b8f7735adb6339b0925b37c","modified":1555606461486},{"_id":"public/2019/04/14/js事件循环机制/index.html","hash":"9f767506cdd8b1fb6678f51d5de7b248856db7d8","modified":1555606461487},{"_id":"public/2019/03/17/hello-world/index.html","hash":"0e857497dda062c0cb27387fde24c9fe59df15a2","modified":1555606461487},{"_id":"public/2018/03/26/函数柯里化/index.html","hash":"fb3265bb9d05bd1b1d420d42b51c2f98f5e5a837","modified":1555606461487},{"_id":"public/2017/05/09/php图像合并/index.html","hash":"1b84943f6d1a7ebf1ce8db457241d470ed4970c5","modified":1555606461487},{"_id":"public/2017/04/06/微信公众号自定义菜单/index.html","hash":"f8560d825a0df8479283987a513f32ff1221628c","modified":1555606461487},{"_id":"public/2017/03/18/xss攻击/index.html","hash":"d18e2a30480b736356d399bec9e25c0cae579809","modified":1555606461487},{"_id":"public/2017/03/05/跨域/index.html","hash":"130a1354504acbf395d4055a52dcc3b53a8fb635","modified":1555606461487},{"_id":"public/2017/02/27/jQuery里的Ajax/index.html","hash":"edd922a11fe496ed3d54ba916bbdcf16df265ae5","modified":1555606461487},{"_id":"public/2017/02/26/javascript的this笔记/index.html","hash":"ea9c371a236eb51725f0c747eff63302fe3eee24","modified":1555606461487},{"_id":"public/2017/02/23/jQuery中的常用事件/index.html","hash":"5e31a61be5539dbd0e9e7b95d016d8889f5eac3e","modified":1555606461487},{"_id":"public/2017/02/22/轮播图插件封装/index.html","hash":"17868aa83bddf10c00f3123c6f6f70b3e5c74ced","modified":1555606461488},{"_id":"public/2017/02/20/canvas的几个知识点/index.html","hash":"13e88a81eda8fde4adb66e9cb341cc9b698eb853","modified":1555606461488},{"_id":"public/2017/02/19/setTimeout在循环中/index.html","hash":"5a9e3961181826e62525f777fccc110d10b5641c","modified":1555606461488},{"_id":"public/2017/02/16/Less学习笔记二/index.html","hash":"b630130b8fdfcd96bc0faca769c382a9db43f015","modified":1555606461488},{"_id":"public/2017/02/14/AngularJS学习笔记二/index.html","hash":"d1474df067875a84395b02d57f52136b3ee25244","modified":1555606461488},{"_id":"public/2017/02/16/Less学习笔记一/index.html","hash":"d3c3313992448498da5d571c7a1182dd06d35a62","modified":1555606461488},{"_id":"public/2017/02/14/js双重否定的小知识点/index.html","hash":"1b01dd7cae38ea8e7dbd369d5b984c9772d0c641","modified":1555606461488},{"_id":"public/2017/02/12/AngularJS学习笔记一/index.html","hash":"ddd3ce177a3411103a4a355f2a7382fdbbeeb0ef","modified":1555606461488},{"_id":"public/2017/02/10/Bootstrap的核心特性/index.html","hash":"33914d4380239ee9b488d068eb4c2bf8dd09e435","modified":1555606461489},{"_id":"public/2017/02/09/响应式web设计/index.html","hash":"d69f73d59e3190eaa00d293bea04ca2eec0ca1ea","modified":1555606461489},{"_id":"public/2017/02/08/HEXO-GithubPages搭建博客指南/index.html","hash":"75d8870a2399014fdece87194aabd3baea5e3952","modified":1555606461489},{"_id":"public/index.html","hash":"5fda85f423820c7fdf688dff327d5e55bd30fe8f","modified":1555606461489},{"_id":"public/page/2/index.html","hash":"aa063e8813f3398cfa13de71f29f85027f5c50b8","modified":1555606461489},{"_id":"public/page/3/index.html","hash":"222d055616e432959fc733f0ef94256f84cc3abf","modified":1555606461489},{"_id":"public/page/4/index.html","hash":"e2c068ec4b6fbda5b7ca002e8f4970749373abe8","modified":1555606461490},{"_id":"public/tags/AngularJS/index.html","hash":"d8b5e1de28551b291615f6e4ba04d78c9df3fc05","modified":1555606461490},{"_id":"public/page/5/index.html","hash":"a861599d1f118bc1500e99b1ac7e72e53d635906","modified":1555606461490},{"_id":"public/tags/Bootstrap-响应式开发/index.html","hash":"ea8b997f72f65b60db211470142d9eed85021095","modified":1555606461490},{"_id":"public/tags/hexo/index.html","hash":"beda41b0643bf22f0d1fd2a7f1b5439f89a594dd","modified":1555606461490},{"_id":"public/tags/Less/index.html","hash":"5872c2819b9ac297a9879eb24654ab26286cde6b","modified":1555606461490},{"_id":"public/tags/HTML5/index.html","hash":"3244e727f2d6b3c7c5e0ead663bfa7550ad38037","modified":1555606461491},{"_id":"public/tags/jQuery/index.html","hash":"b2d8799bf074c08bbb27fb715f242c6c2d1dc17d","modified":1555606461491},{"_id":"public/tags/Ajax/index.html","hash":"eb9c3476e6074acc52b1865a41bd21d1db9ce118","modified":1555606461491},{"_id":"public/tags/javascript-this/index.html","hash":"89e4c930cdc4bfd2b11d83e80e5ea72a808a9769","modified":1555606461491},{"_id":"public/tags/microtask-macrotask/index.html","hash":"5560efe1997e33519413ae6b9aabcd16c4e10263","modified":1555606461491},{"_id":"public/tags/javascript/index.html","hash":"d0c04febf65ced4ea7968f29b6f776872d57ea72","modified":1555606461491},{"_id":"public/tags/php/index.html","hash":"e7c72e74f8bedf4500f9a8c8bbcd370aa1a3e7bd","modified":1555606461491},{"_id":"public/tags/xss/index.html","hash":"1a833cb478bb28de6b97946908d32451b6e93a1e","modified":1555606461491},{"_id":"public/tags/ES6/index.html","hash":"b149e542faeb6f8afacd1197d07e92f4ca9e8eb4","modified":1555606461491},{"_id":"public/tags/HTML5-CSS3/index.html","hash":"de4fb5cd69fba4feb7b42d39065669fa0fbc5777","modified":1555606461492},{"_id":"public/tags/redis-循环/index.html","hash":"f1aa02f89372e9da115bbe7c9684f13607e00e2f","modified":1555606461492},{"_id":"public/tags/微信公众号/index.html","hash":"151bde640b670284eeadde2a0d7ca911005abd34","modified":1555606461492},{"_id":"public/tags/跨域/index.html","hash":"0e47792c8b610ef3dfb6b82e73fee2a9f1c21973","modified":1555606461492},{"_id":"public/archives/index.html","hash":"d466d731cb046ba84275f094176020453d9f372a","modified":1555606461492},{"_id":"public/archives/page/2/index.html","hash":"46a93fecc985458e952e8e6dc49d3fff8180be82","modified":1555606461492},{"_id":"public/archives/page/3/index.html","hash":"0d59d4250eceeff5663f8c851561daa5678fa6e5","modified":1555606461492},{"_id":"public/archives/page/4/index.html","hash":"14ea7943682427c25eb6ee7556c3634c624d5991","modified":1555606461492},{"_id":"public/archives/page/5/index.html","hash":"77c57135e71c3476ff3856123df6275f9e6ed75e","modified":1555606461492},{"_id":"public/archives/2017/index.html","hash":"6505e53fd9cf7437b6bc6bb360294e4080f17045","modified":1555606461493},{"_id":"public/archives/2017/page/2/index.html","hash":"ac68ccab0ac71b3ec0827772609869dafddd785d","modified":1555606461493},{"_id":"public/archives/2017/page/3/index.html","hash":"c3ecada3317ecd1999304f2d0b60d77158452a2d","modified":1555606461493},{"_id":"public/archives/2017/page/4/index.html","hash":"d02616af3854146e238e3737a1cc30bf0291d9bc","modified":1555606461493},{"_id":"public/archives/2017/02/index.html","hash":"8883af873155205090bd35ce13da14beaae72737","modified":1555606461493},{"_id":"public/archives/2017/02/page/2/index.html","hash":"c91a79ec1e5dcdc3f208a95b221c1ac538121aa3","modified":1555606461493},{"_id":"public/archives/2017/02/page/3/index.html","hash":"bf6ffb02bd8a79ac5efd53912159a7f54b508873","modified":1555606461493},{"_id":"public/archives/2017/03/index.html","hash":"757cd3627c224c9722a345dde30aba9a893186d5","modified":1555606461493},{"_id":"public/archives/2017/04/index.html","hash":"ca83ae47c3fba0b143a1c6c4516395c011452589","modified":1555606461493},{"_id":"public/archives/2017/05/index.html","hash":"734b3f0c2fd8f019b3edef29c3d5349ab3f1d4f6","modified":1555606461493},{"_id":"public/archives/2018/index.html","hash":"cdbdbcd3620ed075bb808b2c96a1aaf75a2a2bc9","modified":1555606461493},{"_id":"public/archives/2018/03/index.html","hash":"b2b544a18d2a81f42dd306a976341616126f6bec","modified":1555606461494},{"_id":"public/archives/2019/index.html","hash":"1a5f126048e29164831fb222bd47d7412573446e","modified":1555606461494},{"_id":"public/archives/2019/03/index.html","hash":"4cf7b3757939ccefcd0b067d0eb7d088c29ab0e4","modified":1555606461494},{"_id":"public/archives/2019/04/index.html","hash":"52a41004213407e405054703805349a61d9e3729","modified":1555606461494},{"_id":"public/CNAME","hash":"cdf42bb1ae06123428a42229f0addeb6f48c2767","modified":1555606461498},{"_id":"public/uploads/eventloop.jpeg","hash":"b0747c0f9a0c5281060c8087bd5c593c8963f293","modified":1555606461498},{"_id":"public/uploads/favicon.jpg","hash":"b743f8174fa581c03d574eda8f1af3675be6834b","modified":1555606461499},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1555606461499},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1555606461499},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1555606461499},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1555606461499},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1555606461499},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1555606461499},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1555606461499},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1555606461499},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1555606461499},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1555606461524},{"_id":"public/main.0cf68a.css","hash":"ddf6e2c6b953c2c59a3c271e6070010a4cc81cf9","modified":1555606461526},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1555606461527},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1555606461532},{"_id":"public/uploads/avatar.png","hash":"96a445805a3865a711398dcfc4a811b88e642cd2","modified":1555606461537}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2017-02-08T06:04:33.000Z","type":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2017-02-08 14:04:33\ntype: \"about\"\ncomments: false # 关闭这个页面的多说或者 Disqus 评论\n---\n","updated":"2019-03-17T03:04:24.035Z","path":"about/index.html","layout":"page","_id":"cjumvx6dg0001lvwvcpuzsn5p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"categories","date":"2017-02-08T06:03:49.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2017-02-08 14:03:49\ntype: \"categories\"\ncomments: false # 关闭这个页面的多说或者 Disqus 评论\n---\n","updated":"2019-03-17T03:04:24.035Z","path":"categories/index.html","layout":"page","_id":"cjumvx6di0003lvwv4oj1vdxf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Taqcloud","date":"2017-02-08T05:17:15.000Z","type":"tags","comments":0,"_content":"\n","source":"tags/index.md","raw":"---\ntitle: Taqcloud\ndate: 2017-02-08 13:17:15\ntype: \"tags\"\ncomments: false # 关闭这个页面的多说或者 Disqus 评论\n---\n\n","updated":"2019-03-17T03:04:24.036Z","path":"tags/index.html","layout":"page","_id":"cjumvx6ed001tlvwvoj0bpt7k","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"AngularJS学习笔记一","date":"2017-02-12T11:50:26.000Z","_content":"\n在学习AngularJS的时候，说到Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。Scope 是一个对象，有可用的方法和属。但还是不太搞得明白，感觉有点像是JS的原型继承。所以阅读了相关文章，总结如下。\n\n# Scope的本质\n\nScope实际上就是一个JS对象，controller和view都可以访问它，利用它可以在两者之间传递信息。\n\n# $rootScope\n\nAngular 应用启动并生成视图时,会将根 ng-app 元素与 $rootScope 进行绑定.$rootScope 是所有 $scope 的最上层对象,可以理解为一个 Angular 应用中得全局作用域对象,所以为它附加太多逻辑或者变量并不是一个好主意,和污染 Javascript 全局作用域是一样的.\n\n# 子作用域\n\n每当我们讨明确创建一个$scope对象，就要给DOM元素安上一个controller对象。\n代码如下：\n\n    <div ng-controller=\"MyController\">\n     {{ person.name }}\n    </div>\n    \nng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。这个scope链是这样的：`$scope(mycontroller))->$rootScope`\n\n所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。是不是很像原型链上的查找。\n\n但也有例外，指令的作用域有些不同，下一节将会记录到。","source":"_posts/AngularJS学习笔记一.md","raw":"---\ntitle: AngularJS学习笔记一\ndate: 2017-02-12 19:50:26\ntags: AngularJS\n---\n\n在学习AngularJS的时候，说到Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。Scope 是一个对象，有可用的方法和属。但还是不太搞得明白，感觉有点像是JS的原型继承。所以阅读了相关文章，总结如下。\n\n# Scope的本质\n\nScope实际上就是一个JS对象，controller和view都可以访问它，利用它可以在两者之间传递信息。\n\n# $rootScope\n\nAngular 应用启动并生成视图时,会将根 ng-app 元素与 $rootScope 进行绑定.$rootScope 是所有 $scope 的最上层对象,可以理解为一个 Angular 应用中得全局作用域对象,所以为它附加太多逻辑或者变量并不是一个好主意,和污染 Javascript 全局作用域是一样的.\n\n# 子作用域\n\n每当我们讨明确创建一个$scope对象，就要给DOM元素安上一个controller对象。\n代码如下：\n\n    <div ng-controller=\"MyController\">\n     {{ person.name }}\n    </div>\n    \nng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。这个scope链是这样的：`$scope(mycontroller))->$rootScope`\n\n所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。是不是很像原型链上的查找。\n\n但也有例外，指令的作用域有些不同，下一节将会记录到。","slug":"AngularJS学习笔记一","published":1,"updated":"2019-03-17T03:04:24.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dc0000lvwv2u1tw7wy","content":"<p>在学习AngularJS的时候，说到Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。Scope 是一个对象，有可用的方法和属。但还是不太搞得明白，感觉有点像是JS的原型继承。所以阅读了相关文章，总结如下。</p>\n<h1 id=\"Scope的本质\"><a href=\"#Scope的本质\" class=\"headerlink\" title=\"Scope的本质\"></a>Scope的本质</h1><p>Scope实际上就是一个JS对象，controller和view都可以访问它，利用它可以在两者之间传递信息。</p>\n<h1 id=\"rootScope\"><a href=\"#rootScope\" class=\"headerlink\" title=\"$rootScope\"></a>$rootScope</h1><p>Angular 应用启动并生成视图时,会将根 ng-app 元素与 $rootScope 进行绑定.$rootScope 是所有 $scope 的最上层对象,可以理解为一个 Angular 应用中得全局作用域对象,所以为它附加太多逻辑或者变量并不是一个好主意,和污染 Javascript 全局作用域是一样的.</p>\n<h1 id=\"子作用域\"><a href=\"#子作用域\" class=\"headerlink\" title=\"子作用域\"></a>子作用域</h1><p>每当我们讨明确创建一个$scope对象，就要给DOM元素安上一个controller对象。<br>代码如下：</p>\n<pre><code>&lt;div ng-controller=&quot;MyController&quot;&gt;\n {{ person.name }}\n&lt;/div&gt;\n</code></pre><p>ng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。这个scope链是这样的：<code>$scope(mycontroller))-&gt;$rootScope</code></p>\n<p>所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。是不是很像原型链上的查找。</p>\n<p>但也有例外，指令的作用域有些不同，下一节将会记录到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在学习AngularJS的时候，说到Scope(作用域) 是应用在 HTML (视图) 和 JavaScript (控制器)之间的纽带。Scope 是一个对象，有可用的方法和属。但还是不太搞得明白，感觉有点像是JS的原型继承。所以阅读了相关文章，总结如下。</p>\n<h1 id=\"Scope的本质\"><a href=\"#Scope的本质\" class=\"headerlink\" title=\"Scope的本质\"></a>Scope的本质</h1><p>Scope实际上就是一个JS对象，controller和view都可以访问它，利用它可以在两者之间传递信息。</p>\n<h1 id=\"rootScope\"><a href=\"#rootScope\" class=\"headerlink\" title=\"$rootScope\"></a>$rootScope</h1><p>Angular 应用启动并生成视图时,会将根 ng-app 元素与 $rootScope 进行绑定.$rootScope 是所有 $scope 的最上层对象,可以理解为一个 Angular 应用中得全局作用域对象,所以为它附加太多逻辑或者变量并不是一个好主意,和污染 Javascript 全局作用域是一样的.</p>\n<h1 id=\"子作用域\"><a href=\"#子作用域\" class=\"headerlink\" title=\"子作用域\"></a>子作用域</h1><p>每当我们讨明确创建一个$scope对象，就要给DOM元素安上一个controller对象。<br>代码如下：</p>\n<pre><code>&lt;div ng-controller=&quot;MyController&quot;&gt;\n {{ person.name }}\n&lt;/div&gt;\n</code></pre><p>ng-controller指令给所在的DOM元素创建了一个新的$scope 对象，并将这个$scope 对象包含进外层DOM元素的$scope 对象里。在上面的例子里，这个外层DOM元素的$scope 对象，就是$rootScope 对象。这个scope链是这样的：<code>$scope(mycontroller))-&gt;$rootScope</code></p>\n<p>所有scope都遵循原型继承（prototypal inheritance），这意味着它们都能访问父scope们。对任何属性和方法，如果AngularJS在当前scope上找不到，就会到父scope上去找，如果在父scope上也没找到，就会继续向上回溯，一直到$rootScope 上。是不是很像原型链上的查找。</p>\n<p>但也有例外，指令的作用域有些不同，下一节将会记录到。</p>\n"},{"title":"Bootstrap的核心特性","date":"2017-02-10T13:36:21.000Z","_content":"\n# Bootstrap简介\n\nBootstrap是一个前端开发框架，来自Twitter。它是基于HTML，CSS和JS编写的，使页面更加简洁灵活，它所提供的样式和组件在构建页面时能省很多功夫。\n\nBootstrap的源代码大概看了一下还是可以理解的。布局组件是通过给样式给一个类名，在特定的类写特定的CSS代码。JS插件其实也是我们经常练习的功能封装的。\n\nBootstrap的组件和插件都挺多的，可以大概熟悉个遍，真正使用时再查看相关文档，同时如果想定制自己想要的风格可以在Bootstrap的源代码中更改相关参数。相关文章建议在less和sass文件夹中进行。\n\nBootstrap最让人惊喜的是它的网格系统，我认为这是它的核心特性。\n\n# 核心特性-网格系统\n\nBootstrap创建了一个行类名为`.row`，行内规定只能有12列（根据设备大小和你想要的列宽,类名为`.col-xs/sm/md/lg-*`)。\n\n网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：\n\n-  行必须放置在`.container`，以便获得适当的对齐（alignment）和内边距（padding）。\n- 使用行来创建列的水平组，类名为`.row`。\n- 内容应该放置在列内，且唯有列可以是行的直接子元素。\n- 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个` .col-xs-4`。\n\n基本的网格系统代码应该是如下的：\n\n    <div class=\"container\">\n       <div class=\"row\">\n          <div class=\"col-*-*\"></div>\n          <div class=\"col-*-*\"></div>      \n       </div>\n       <div class=\"row\">...</div>\n    </div>\n\n## 网格系统的几个有用的属性\n\n### 列偏移\n\n如，使用` .col-md-offset-*` 类。这些类会把一个列的左外边距（margin）增加` * `列，其中` *` 范围是从 1 到 11。注意偏移是向右的。\n\n### 列排序\n\n如，使用 `.col-md-push-* `和 `.col-md-pull-*` 类的内置网格列的顺序，其中 * 范围是从 1 到 11。使用 `.col-md-push-*` 和` .col-md-pull-* `类来可以互换互换两列的顺序，push向右，pull向左。\n\n### 列嵌套\n\n列嵌套其实很简单，就是在第一级网格系统的列中再重新添加`.row`的div，这一行同样是十二个列的宽度，同样也是父级元素的宽度。因为Bootstrap的网格系统宽度是通过百分比来确定的，也是说它是自适应的。","source":"_posts/Bootstrap的核心特性.md","raw":"---\ntitle: Bootstrap的核心特性\ndate: 2017-02-10 21:36:21\ntags: Bootstrap 响应式开发\n---\n\n# Bootstrap简介\n\nBootstrap是一个前端开发框架，来自Twitter。它是基于HTML，CSS和JS编写的，使页面更加简洁灵活，它所提供的样式和组件在构建页面时能省很多功夫。\n\nBootstrap的源代码大概看了一下还是可以理解的。布局组件是通过给样式给一个类名，在特定的类写特定的CSS代码。JS插件其实也是我们经常练习的功能封装的。\n\nBootstrap的组件和插件都挺多的，可以大概熟悉个遍，真正使用时再查看相关文档，同时如果想定制自己想要的风格可以在Bootstrap的源代码中更改相关参数。相关文章建议在less和sass文件夹中进行。\n\nBootstrap最让人惊喜的是它的网格系统，我认为这是它的核心特性。\n\n# 核心特性-网格系统\n\nBootstrap创建了一个行类名为`.row`，行内规定只能有12列（根据设备大小和你想要的列宽,类名为`.col-xs/sm/md/lg-*`)。\n\n网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：\n\n-  行必须放置在`.container`，以便获得适当的对齐（alignment）和内边距（padding）。\n- 使用行来创建列的水平组，类名为`.row`。\n- 内容应该放置在列内，且唯有列可以是行的直接子元素。\n- 网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个` .col-xs-4`。\n\n基本的网格系统代码应该是如下的：\n\n    <div class=\"container\">\n       <div class=\"row\">\n          <div class=\"col-*-*\"></div>\n          <div class=\"col-*-*\"></div>      \n       </div>\n       <div class=\"row\">...</div>\n    </div>\n\n## 网格系统的几个有用的属性\n\n### 列偏移\n\n如，使用` .col-md-offset-*` 类。这些类会把一个列的左外边距（margin）增加` * `列，其中` *` 范围是从 1 到 11。注意偏移是向右的。\n\n### 列排序\n\n如，使用 `.col-md-push-* `和 `.col-md-pull-*` 类的内置网格列的顺序，其中 * 范围是从 1 到 11。使用 `.col-md-push-*` 和` .col-md-pull-* `类来可以互换互换两列的顺序，push向右，pull向左。\n\n### 列嵌套\n\n列嵌套其实很简单，就是在第一级网格系统的列中再重新添加`.row`的div，这一行同样是十二个列的宽度，同样也是父级元素的宽度。因为Bootstrap的网格系统宽度是通过百分比来确定的，也是说它是自适应的。","slug":"Bootstrap的核心特性","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dh0002lvwvzi4w7u97","content":"<h1 id=\"Bootstrap简介\"><a href=\"#Bootstrap简介\" class=\"headerlink\" title=\"Bootstrap简介\"></a>Bootstrap简介</h1><p>Bootstrap是一个前端开发框架，来自Twitter。它是基于HTML，CSS和JS编写的，使页面更加简洁灵活，它所提供的样式和组件在构建页面时能省很多功夫。</p>\n<p>Bootstrap的源代码大概看了一下还是可以理解的。布局组件是通过给样式给一个类名，在特定的类写特定的CSS代码。JS插件其实也是我们经常练习的功能封装的。</p>\n<p>Bootstrap的组件和插件都挺多的，可以大概熟悉个遍，真正使用时再查看相关文档，同时如果想定制自己想要的风格可以在Bootstrap的源代码中更改相关参数。相关文章建议在less和sass文件夹中进行。</p>\n<p>Bootstrap最让人惊喜的是它的网格系统，我认为这是它的核心特性。</p>\n<h1 id=\"核心特性-网格系统\"><a href=\"#核心特性-网格系统\" class=\"headerlink\" title=\"核心特性-网格系统\"></a>核心特性-网格系统</h1><p>Bootstrap创建了一个行类名为<code>.row</code>，行内规定只能有12列（根据设备大小和你想要的列宽,类名为<code>.col-xs/sm/md/lg-*</code>)。</p>\n<p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p>\n<ul>\n<li>行必须放置在<code>.container</code>，以便获得适当的对齐（alignment）和内边距（padding）。</li>\n<li>使用行来创建列的水平组，类名为<code>.row</code>。</li>\n<li>内容应该放置在列内，且唯有列可以是行的直接子元素。</li>\n<li>网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个<code>.col-xs-4</code>。</li>\n</ul>\n<p>基本的网格系统代码应该是如下的：</p>\n<pre><code>&lt;div class=&quot;container&quot;&gt;\n   &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;      \n   &lt;/div&gt;\n   &lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><h2 id=\"网格系统的几个有用的属性\"><a href=\"#网格系统的几个有用的属性\" class=\"headerlink\" title=\"网格系统的几个有用的属性\"></a>网格系统的几个有用的属性</h2><h3 id=\"列偏移\"><a href=\"#列偏移\" class=\"headerlink\" title=\"列偏移\"></a>列偏移</h3><p>如，使用<code>.col-md-offset-*</code> 类。这些类会把一个列的左外边距（margin）增加<code>*</code>列，其中<code>*</code> 范围是从 1 到 11。注意偏移是向右的。</p>\n<h3 id=\"列排序\"><a href=\"#列排序\" class=\"headerlink\" title=\"列排序\"></a>列排序</h3><p>如，使用 <code>.col-md-push-*</code>和 <code>.col-md-pull-*</code> 类的内置网格列的顺序，其中 <em> 范围是从 1 到 11。使用 `.col-md-push-</em><code>和</code> .col-md-pull-* `类来可以互换互换两列的顺序，push向右，pull向左。</p>\n<h3 id=\"列嵌套\"><a href=\"#列嵌套\" class=\"headerlink\" title=\"列嵌套\"></a>列嵌套</h3><p>列嵌套其实很简单，就是在第一级网格系统的列中再重新添加<code>.row</code>的div，这一行同样是十二个列的宽度，同样也是父级元素的宽度。因为Bootstrap的网格系统宽度是通过百分比来确定的，也是说它是自适应的。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Bootstrap简介\"><a href=\"#Bootstrap简介\" class=\"headerlink\" title=\"Bootstrap简介\"></a>Bootstrap简介</h1><p>Bootstrap是一个前端开发框架，来自Twitter。它是基于HTML，CSS和JS编写的，使页面更加简洁灵活，它所提供的样式和组件在构建页面时能省很多功夫。</p>\n<p>Bootstrap的源代码大概看了一下还是可以理解的。布局组件是通过给样式给一个类名，在特定的类写特定的CSS代码。JS插件其实也是我们经常练习的功能封装的。</p>\n<p>Bootstrap的组件和插件都挺多的，可以大概熟悉个遍，真正使用时再查看相关文档，同时如果想定制自己想要的风格可以在Bootstrap的源代码中更改相关参数。相关文章建议在less和sass文件夹中进行。</p>\n<p>Bootstrap最让人惊喜的是它的网格系统，我认为这是它的核心特性。</p>\n<h1 id=\"核心特性-网格系统\"><a href=\"#核心特性-网格系统\" class=\"headerlink\" title=\"核心特性-网格系统\"></a>核心特性-网格系统</h1><p>Bootstrap创建了一个行类名为<code>.row</code>，行内规定只能有12列（根据设备大小和你想要的列宽,类名为<code>.col-xs/sm/md/lg-*</code>)。</p>\n<p>网格系统通过一系列包含内容的行和列来创建页面布局。下面列出了 Bootstrap 网格系统是如何工作的：</p>\n<ul>\n<li>行必须放置在<code>.container</code>，以便获得适当的对齐（alignment）和内边距（padding）。</li>\n<li>使用行来创建列的水平组，类名为<code>.row</code>。</li>\n<li>内容应该放置在列内，且唯有列可以是行的直接子元素。</li>\n<li>网格系统是通过指定您想要横跨的十二个可用的列来创建的。例如，要创建三个相等的列，则使用三个<code>.col-xs-4</code>。</li>\n</ul>\n<p>基本的网格系统代码应该是如下的：</p>\n<pre><code>&lt;div class=&quot;container&quot;&gt;\n   &lt;div class=&quot;row&quot;&gt;\n      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;\n      &lt;div class=&quot;col-*-*&quot;&gt;&lt;/div&gt;      \n   &lt;/div&gt;\n   &lt;div class=&quot;row&quot;&gt;...&lt;/div&gt;\n&lt;/div&gt;\n</code></pre><h2 id=\"网格系统的几个有用的属性\"><a href=\"#网格系统的几个有用的属性\" class=\"headerlink\" title=\"网格系统的几个有用的属性\"></a>网格系统的几个有用的属性</h2><h3 id=\"列偏移\"><a href=\"#列偏移\" class=\"headerlink\" title=\"列偏移\"></a>列偏移</h3><p>如，使用<code>.col-md-offset-*</code> 类。这些类会把一个列的左外边距（margin）增加<code>*</code>列，其中<code>*</code> 范围是从 1 到 11。注意偏移是向右的。</p>\n<h3 id=\"列排序\"><a href=\"#列排序\" class=\"headerlink\" title=\"列排序\"></a>列排序</h3><p>如，使用 <code>.col-md-push-*</code>和 <code>.col-md-pull-*</code> 类的内置网格列的顺序，其中 <em> 范围是从 1 到 11。使用 `.col-md-push-</em><code>和</code> .col-md-pull-* `类来可以互换互换两列的顺序，push向右，pull向左。</p>\n<h3 id=\"列嵌套\"><a href=\"#列嵌套\" class=\"headerlink\" title=\"列嵌套\"></a>列嵌套</h3><p>列嵌套其实很简单，就是在第一级网格系统的列中再重新添加<code>.row</code>的div，这一行同样是十二个列的宽度，同样也是父级元素的宽度。因为Bootstrap的网格系统宽度是通过百分比来确定的，也是说它是自适应的。</p>\n"},{"title":"AngularJS学习笔记二","date":"2017-02-13T16:10:56.000Z","_content":"\n>本文摘录自[玩转AngularJS的作用域][1]\n\n每当一个指令被创建时，都会有一个选择，是继承自己的父作用域还是创建一个新的自己的作用域。AngularJS指令的作用域有三种选择，分别是false，true，{}，默认情况下是false。\n\n# scope = false\n\n这种情况表示，在指令模板中直接使用父作用域中的变量。\n当我们在指令更改父作用域的方法和属性，父作用域绑定的数据也发生了响应的变化。\n\n# scope = true \n\n当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域。但是改变指令内的数据，只有指令的作用域发生了变化，父作用域数据并没有发生变化\n\n\n- 当我们将scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承了我们的父作用域；我觉得可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。\n- 当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。\n\n这就是两者继承父作用域的区别。\n\n# scope={}\n\n我们将scope设置为{}时，意味着我们创建的一个新的与父作用域隔离的新的作用域，这使我们在不知道外部环境的情况下，就可以正常工作，不依赖外部环境。\n\n实例代码如下：\n\n        angular.module(\"MyApp\", [])\n        .controller(\"MyController\", function ($scope) {\n        $scope.name = \"dreamapple\";\n        $scope.age = 20;\n        $scope.changeAge = function(){\n            $scope.age = 0;\n        }\n    })\n        .directive(\"myDirective\", function () {\n        var obj = {\n            restrict: \"AE\",\n            scope: {\n                name: '@myName',\n                age: '=',\n                changeAge: '&changeMyAge'\n            },\n            replace: true,\n            template: \"<div class='my-directive'>\" +\n                \"<h3>下面部分是我们创建的指令生成的</h3>\" +\n                \"我的名字是：<span ng-bind='name'></span><br/>\" +\n                \"我的年龄是：<span ng-bind='age'></span><br/>\" +\n                \"在这里修改名字：<input type='text' ng-model='name'><br/>\" +\n                \"<button ng-click='changeAge()'>修改年龄</button>\" +\n                \" </div>\"\n        }\n        return obj;\n    });\n    \n    \n我们使用了隔离的作用域，不代表我们不可以使用父作用域的属性和方法。我们可以通过向scope的{}中传入特殊的前缀标识符（即prefix），来进行数据的绑定。在创建了隔离的作用域，我们可以通过@,&,=引用应用指令的元素的属性。但是注意要使用驼峰命名法。\n\n## @\n\n这是一个单项绑定的前缀标识符。\n使用方法：在元素中使用属性，好比这样`<div my-directive my-name=\"{{name}}\"></div>`，注意，属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过使用两个大括号来绑定数据。\n\n## &\n\n这是一个双向数据绑定前缀标识符。\n使用方法：在元素中使用属性，好比这样`<div my-directive age=\"age\"></div>`,注意，数据的双向绑定要通过=前缀标识符实现，所以不可以使用两个大括号。\n\n## =\n\n这是一个绑定函数方法的前缀标识符\n使用方法：在元素中使用属性，好比这样`<div my-directive change-my-age=\"changeAge()\"></div>`，注意，属性的名字要用`-`将多个个单词连接。\n\n\n  [1]: https://segmentfault.com/a/1190000002773689","source":"_posts/AngularJS学习笔记二.md","raw":"---\ntitle: AngularJS学习笔记二\ndate: 2017-02-14 00:10:56\ntags: AngularJS\n---\n\n>本文摘录自[玩转AngularJS的作用域][1]\n\n每当一个指令被创建时，都会有一个选择，是继承自己的父作用域还是创建一个新的自己的作用域。AngularJS指令的作用域有三种选择，分别是false，true，{}，默认情况下是false。\n\n# scope = false\n\n这种情况表示，在指令模板中直接使用父作用域中的变量。\n当我们在指令更改父作用域的方法和属性，父作用域绑定的数据也发生了响应的变化。\n\n# scope = true \n\n当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域。但是改变指令内的数据，只有指令的作用域发生了变化，父作用域数据并没有发生变化\n\n\n- 当我们将scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承了我们的父作用域；我觉得可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。\n- 当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。\n\n这就是两者继承父作用域的区别。\n\n# scope={}\n\n我们将scope设置为{}时，意味着我们创建的一个新的与父作用域隔离的新的作用域，这使我们在不知道外部环境的情况下，就可以正常工作，不依赖外部环境。\n\n实例代码如下：\n\n        angular.module(\"MyApp\", [])\n        .controller(\"MyController\", function ($scope) {\n        $scope.name = \"dreamapple\";\n        $scope.age = 20;\n        $scope.changeAge = function(){\n            $scope.age = 0;\n        }\n    })\n        .directive(\"myDirective\", function () {\n        var obj = {\n            restrict: \"AE\",\n            scope: {\n                name: '@myName',\n                age: '=',\n                changeAge: '&changeMyAge'\n            },\n            replace: true,\n            template: \"<div class='my-directive'>\" +\n                \"<h3>下面部分是我们创建的指令生成的</h3>\" +\n                \"我的名字是：<span ng-bind='name'></span><br/>\" +\n                \"我的年龄是：<span ng-bind='age'></span><br/>\" +\n                \"在这里修改名字：<input type='text' ng-model='name'><br/>\" +\n                \"<button ng-click='changeAge()'>修改年龄</button>\" +\n                \" </div>\"\n        }\n        return obj;\n    });\n    \n    \n我们使用了隔离的作用域，不代表我们不可以使用父作用域的属性和方法。我们可以通过向scope的{}中传入特殊的前缀标识符（即prefix），来进行数据的绑定。在创建了隔离的作用域，我们可以通过@,&,=引用应用指令的元素的属性。但是注意要使用驼峰命名法。\n\n## @\n\n这是一个单项绑定的前缀标识符。\n使用方法：在元素中使用属性，好比这样`<div my-directive my-name=\"{{name}}\"></div>`，注意，属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过使用两个大括号来绑定数据。\n\n## &\n\n这是一个双向数据绑定前缀标识符。\n使用方法：在元素中使用属性，好比这样`<div my-directive age=\"age\"></div>`,注意，数据的双向绑定要通过=前缀标识符实现，所以不可以使用两个大括号。\n\n## =\n\n这是一个绑定函数方法的前缀标识符\n使用方法：在元素中使用属性，好比这样`<div my-directive change-my-age=\"changeAge()\"></div>`，注意，属性的名字要用`-`将多个个单词连接。\n\n\n  [1]: https://segmentfault.com/a/1190000002773689","slug":"AngularJS学习笔记二","published":1,"updated":"2019-03-17T03:04:24.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dj0005lvwvurt21bo7","content":"<blockquote>\n<p>本文摘录自<a href=\"https://segmentfault.com/a/1190000002773689\" target=\"_blank\" rel=\"noopener\">玩转AngularJS的作用域</a></p>\n</blockquote>\n<p>每当一个指令被创建时，都会有一个选择，是继承自己的父作用域还是创建一个新的自己的作用域。AngularJS指令的作用域有三种选择，分别是false，true，{}，默认情况下是false。</p>\n<h1 id=\"scope-false\"><a href=\"#scope-false\" class=\"headerlink\" title=\"scope = false\"></a>scope = false</h1><p>这种情况表示，在指令模板中直接使用父作用域中的变量。<br>当我们在指令更改父作用域的方法和属性，父作用域绑定的数据也发生了响应的变化。</p>\n<h1 id=\"scope-true\"><a href=\"#scope-true\" class=\"headerlink\" title=\"scope = true\"></a>scope = true</h1><p>当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域。但是改变指令内的数据，只有指令的作用域发生了变化，父作用域数据并没有发生变化</p>\n<ul>\n<li>当我们将scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承了我们的父作用域；我觉得可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。</li>\n<li>当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。</li>\n</ul>\n<p>这就是两者继承父作用域的区别。</p>\n<h1 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope={}\"></a>scope={}</h1><p>我们将scope设置为{}时，意味着我们创建的一个新的与父作用域隔离的新的作用域，这使我们在不知道外部环境的情况下，就可以正常工作，不依赖外部环境。</p>\n<p>实例代码如下：</p>\n<pre><code>    angular.module(&quot;MyApp&quot;, [])\n    .controller(&quot;MyController&quot;, function ($scope) {\n    $scope.name = &quot;dreamapple&quot;;\n    $scope.age = 20;\n    $scope.changeAge = function(){\n        $scope.age = 0;\n    }\n})\n    .directive(&quot;myDirective&quot;, function () {\n    var obj = {\n        restrict: &quot;AE&quot;,\n        scope: {\n            name: &apos;@myName&apos;,\n            age: &apos;=&apos;,\n            changeAge: &apos;&amp;changeMyAge&apos;\n        },\n        replace: true,\n        template: &quot;&lt;div class=&apos;my-directive&apos;&gt;&quot; +\n            &quot;&lt;h3&gt;下面部分是我们创建的指令生成的&lt;/h3&gt;&quot; +\n            &quot;我的名字是：&lt;span ng-bind=&apos;name&apos;&gt;&lt;/span&gt;&lt;br/&gt;&quot; +\n            &quot;我的年龄是：&lt;span ng-bind=&apos;age&apos;&gt;&lt;/span&gt;&lt;br/&gt;&quot; +\n            &quot;在这里修改名字：&lt;input type=&apos;text&apos; ng-model=&apos;name&apos;&gt;&lt;br/&gt;&quot; +\n            &quot;&lt;button ng-click=&apos;changeAge()&apos;&gt;修改年龄&lt;/button&gt;&quot; +\n            &quot; &lt;/div&gt;&quot;\n    }\n    return obj;\n});\n</code></pre><p>我们使用了隔离的作用域，不代表我们不可以使用父作用域的属性和方法。我们可以通过向scope的{}中传入特殊的前缀标识符（即prefix），来进行数据的绑定。在创建了隔离的作用域，我们可以通过@,&amp;,=引用应用指令的元素的属性。但是注意要使用驼峰命名法。</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\"@\"></a>@</h2><p>这是一个单项绑定的前缀标识符。<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive my-name=&quot;&quot;&gt;&lt;/div&gt;</code>，注意，属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过使用两个大括号来绑定数据。</p>\n<h2 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h2><p>这是一个双向数据绑定前缀标识符。<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive age=&quot;age&quot;&gt;&lt;/div&gt;</code>,注意，数据的双向绑定要通过=前缀标识符实现，所以不可以使用两个大括号。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"=\"></a>=</h2><p>这是一个绑定函数方法的前缀标识符<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive change-my-age=&quot;changeAge()&quot;&gt;&lt;/div&gt;</code>，注意，属性的名字要用<code>-</code>将多个个单词连接。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文摘录自<a href=\"https://segmentfault.com/a/1190000002773689\" target=\"_blank\" rel=\"noopener\">玩转AngularJS的作用域</a></p>\n</blockquote>\n<p>每当一个指令被创建时，都会有一个选择，是继承自己的父作用域还是创建一个新的自己的作用域。AngularJS指令的作用域有三种选择，分别是false，true，{}，默认情况下是false。</p>\n<h1 id=\"scope-false\"><a href=\"#scope-false\" class=\"headerlink\" title=\"scope = false\"></a>scope = false</h1><p>这种情况表示，在指令模板中直接使用父作用域中的变量。<br>当我们在指令更改父作用域的方法和属性，父作用域绑定的数据也发生了响应的变化。</p>\n<h1 id=\"scope-true\"><a href=\"#scope-true\" class=\"headerlink\" title=\"scope = true\"></a>scope = true</h1><p>当把scope属性设置为true时，这表明我们创建的指令要创建一个新的作用域，这个作用域继承自我们的父作用域。但是改变指令内的数据，只有指令的作用域发生了变化，父作用域数据并没有发生变化</p>\n<ul>\n<li>当我们将scope设置为true的时候，我们就新创建了一个作用域，只不过这个作用域是继承了我们的父作用域；我觉得可以这样理解，我们新创建的作用域是一个新的作用域，只不过在初始化的时候，用了父作用域的属性和方法去填充我们这个新的作用域。它和父作用域不是同一个作用域。</li>\n<li>当我们将scope设置为false的时候,我们创建的指令和父作用域（其实是同一个作用域）共享同一个model模型，所以在指令中修改模型数据，它会反映到父作用域的模型中。</li>\n</ul>\n<p>这就是两者继承父作用域的区别。</p>\n<h1 id=\"scope\"><a href=\"#scope\" class=\"headerlink\" title=\"scope={}\"></a>scope={}</h1><p>我们将scope设置为{}时，意味着我们创建的一个新的与父作用域隔离的新的作用域，这使我们在不知道外部环境的情况下，就可以正常工作，不依赖外部环境。</p>\n<p>实例代码如下：</p>\n<pre><code>    angular.module(&quot;MyApp&quot;, [])\n    .controller(&quot;MyController&quot;, function ($scope) {\n    $scope.name = &quot;dreamapple&quot;;\n    $scope.age = 20;\n    $scope.changeAge = function(){\n        $scope.age = 0;\n    }\n})\n    .directive(&quot;myDirective&quot;, function () {\n    var obj = {\n        restrict: &quot;AE&quot;,\n        scope: {\n            name: &apos;@myName&apos;,\n            age: &apos;=&apos;,\n            changeAge: &apos;&amp;changeMyAge&apos;\n        },\n        replace: true,\n        template: &quot;&lt;div class=&apos;my-directive&apos;&gt;&quot; +\n            &quot;&lt;h3&gt;下面部分是我们创建的指令生成的&lt;/h3&gt;&quot; +\n            &quot;我的名字是：&lt;span ng-bind=&apos;name&apos;&gt;&lt;/span&gt;&lt;br/&gt;&quot; +\n            &quot;我的年龄是：&lt;span ng-bind=&apos;age&apos;&gt;&lt;/span&gt;&lt;br/&gt;&quot; +\n            &quot;在这里修改名字：&lt;input type=&apos;text&apos; ng-model=&apos;name&apos;&gt;&lt;br/&gt;&quot; +\n            &quot;&lt;button ng-click=&apos;changeAge()&apos;&gt;修改年龄&lt;/button&gt;&quot; +\n            &quot; &lt;/div&gt;&quot;\n    }\n    return obj;\n});\n</code></pre><p>我们使用了隔离的作用域，不代表我们不可以使用父作用域的属性和方法。我们可以通过向scope的{}中传入特殊的前缀标识符（即prefix），来进行数据的绑定。在创建了隔离的作用域，我们可以通过@,&amp;,=引用应用指令的元素的属性。但是注意要使用驼峰命名法。</p>\n<h2 id><a href=\"#\" class=\"headerlink\" title=\"@\"></a>@</h2><p>这是一个单项绑定的前缀标识符。<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive my-name=&quot;&quot;&gt;&lt;/div&gt;</code>，注意，属性的名字要用-将两个单词连接，因为是数据的单项绑定所以要通过使用两个大括号来绑定数据。</p>\n<h2 id=\"amp\"><a href=\"#amp\" class=\"headerlink\" title=\"&amp;\"></a>&amp;</h2><p>这是一个双向数据绑定前缀标识符。<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive age=&quot;age&quot;&gt;&lt;/div&gt;</code>,注意，数据的双向绑定要通过=前缀标识符实现，所以不可以使用两个大括号。</p>\n<h2 id=\"-1\"><a href=\"#-1\" class=\"headerlink\" title=\"=\"></a>=</h2><p>这是一个绑定函数方法的前缀标识符<br>使用方法：在元素中使用属性，好比这样<code>&lt;div my-directive change-my-age=&quot;changeAge()&quot;&gt;&lt;/div&gt;</code>，注意，属性的名字要用<code>-</code>将多个个单词连接。</p>\n"},{"title":"HEXO+GithubPages搭建博客指南","date":"2017-02-08T13:36:01.000Z","_content":"\n\n> Hexo是一个快速、简介且高效的博客框架，配置了多种主题，定制自己风格的博客。PS 我的博客地址传送门在这：[shelia's blog][1]\n\n[TOC]\n\n# 前期准备 #\n\n## 安装Git Bash ##\n \ngithub是程序员的标配，因为使用的是Windows系统，所以下了个github的客户端。里面包含了Git Bash和图形界面的Git GUI,使用哪个看个人习惯。建议使用GitBash，可以在日常的操作中熟悉常用指令。\n\n廖雪峰的Git教程有提供国内的镜像下载，或者可以到这个地址下载https://desktop.github.com/。\n \n## 安装Node.js ##\n\nNodejs我是直接下载的客户端，直接用搜索引擎搜索一下就能找到。\n**注意：**安装时一路next的时候请选择Add to Path方式安装。\n\n## 安装HEXO ##\n\n所有必须的软件安装后，打开终端（随你选择）输入以下命令安装hexo：\n\n> npm install -g hexo-cli\n\n**注意：**安装的时候如果出现warming不要管它之后也可以用，如果是ERROR的话可能需要你用管理员权限运行终端来安装。\n\n为了测试hexo是否正常安装，我们可以通过以下命令来测试（我的所有命令都是在管理员权限下的）。\n\n在你喜欢的任意一个地方，新建一个博客文件夹：\n\n> hexo init hexoblog\n\n安装依赖：\n\n> npm install\n\n本地运行测试\n\n> hexo s\n\n如果成功会打印:Hexo is running at  http://localhost:4000/. Press Ctrl+C to stop,再打开你的浏览器输入localhost:4000地址就可以看到你的博客了。\n\n# 在github上创建GithubPages #\n\n## 配置SSH ##\n\ngithub本地和远程连接有两种方式，一种是通过https，另一种是SSH，推荐后一种。\n\n配置SSH的步骤如下：\n\n- 在本地生成公钥和私钥,命令如下：\n\n > ssh-keygen\n\n- 找到你保存公钥和私钥的文件夹，用记事本打开之前生成的id_rsa.pub文件,复制里面的公钥字符串。打开你的github网站，在setting里面的SSH keys，再点击Add SSH key 按钮添加，title域随便命名，Key域粘贴之前复制的内容。\n\n## 创建仓库 ##\n\ngithub有专门的一种格式来创建博客仓库的。新建一个仓库，仓库名为:**youusername.github.io**.\n\n# 建站 #\n\n## 克隆远程仓库 ##\n\n为了管理方便，建议再一个分支上存放hexo博客的源代码，master分支用来发布静态博客，步骤如下：\n\n - 在你的仓库中新建一个分支，我命名为hexo，然后切换到仓库的settitng的branch选项设置为默认分支。\n - 打开Git Bash，复制远程仓库\n    > git clone git@github.com:username/username.github.io.git\n - 克隆好远程仓库我们就可以开始建站了。在执行其它命令前，把根目录下的.git文件夹复制到另一个地方保存先，因为 hexo init命令会覆盖掉它。\n \n## 搭建hexo博客 ##\n\n打开终端，依次执行以下命令：\n\n> npm install hexo\n> hexo init\n> hexo install\n\n复制之前保存在另一个地方的.git文件夹再放到根目录下。\n\n> npm install hexo-deployer-git\n\n**注意：**这些命令都是工作在hexo分支上，以后也是。\n\n修改_config.yml中的deploy参数，分支应为master，可以按照如下设置：\n\n> deploy:\n> &nbsp;&nbsp;&nbsp;&nbsp;type:git\n> &nbsp;&nbsp;&nbsp;&nbsp;typerepo:（复制你的项目地址到这里）\n> &nbsp;&nbsp;&nbsp;&nbsp;typebranch:master\n \n- 依次执行 `git add .`,`git commit -m \"...\"`,`git push origin hexo`提交网站相关的文件\n- 执行`hexo g -d`生成网站并部署到GitHub上。\n\n此方法由知乎上的一位网友提供，链接在此：[hexo分支管理][2]， 必须记得复制.git文件夹不然本地仓库就失效了。\n\n## 配置个人信息 ##\n\n在根目录下有一个`_confug.yml`文件夹，在里面你可以通过相关字段来设置自己的个人信息。\n\n## 配置主题 ##\n\n我的博客使用的主题是nexT，网上有具体的使用文档 [NexT使用文档传送门][3]\n\n同时在文档中也介绍了如何安装第三方插件。\n\n# 添加域名 #\n\n添加域名有三个步骤：\n\n- 首先现在万网上买一个域名\n- 下一步注册DNSpod，然后添加域名，添加记录即可\n- 返回在你的仓库setting里面绑定域名，它会生成一个CNAME文件。\n\n**注意：**我在绑定域名后在本地重新提交代码部署静态博客时，CNAME文件总是被覆盖。解决办法是下载CNAME文件，放到本地站点目录下的source文件夹，注意CNAME是无格式的，不然会被部署到网站上。\n\n\n\n   \n\n\n  [1]: http://shelia.site/\n  [2]: https://www.zhihu.com/question/21193762\n  [3]: http://theme-next.iissnan.com/%20%E2%80%9CNexT%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D","source":"_posts/HEXO-GithubPages搭建博客指南.md","raw":"---\ntitle: HEXO+GithubPages搭建博客指南\ndate: 2017-02-08 21:36:01\ntags: hexo\n---\n\n\n> Hexo是一个快速、简介且高效的博客框架，配置了多种主题，定制自己风格的博客。PS 我的博客地址传送门在这：[shelia's blog][1]\n\n[TOC]\n\n# 前期准备 #\n\n## 安装Git Bash ##\n \ngithub是程序员的标配，因为使用的是Windows系统，所以下了个github的客户端。里面包含了Git Bash和图形界面的Git GUI,使用哪个看个人习惯。建议使用GitBash，可以在日常的操作中熟悉常用指令。\n\n廖雪峰的Git教程有提供国内的镜像下载，或者可以到这个地址下载https://desktop.github.com/。\n \n## 安装Node.js ##\n\nNodejs我是直接下载的客户端，直接用搜索引擎搜索一下就能找到。\n**注意：**安装时一路next的时候请选择Add to Path方式安装。\n\n## 安装HEXO ##\n\n所有必须的软件安装后，打开终端（随你选择）输入以下命令安装hexo：\n\n> npm install -g hexo-cli\n\n**注意：**安装的时候如果出现warming不要管它之后也可以用，如果是ERROR的话可能需要你用管理员权限运行终端来安装。\n\n为了测试hexo是否正常安装，我们可以通过以下命令来测试（我的所有命令都是在管理员权限下的）。\n\n在你喜欢的任意一个地方，新建一个博客文件夹：\n\n> hexo init hexoblog\n\n安装依赖：\n\n> npm install\n\n本地运行测试\n\n> hexo s\n\n如果成功会打印:Hexo is running at  http://localhost:4000/. Press Ctrl+C to stop,再打开你的浏览器输入localhost:4000地址就可以看到你的博客了。\n\n# 在github上创建GithubPages #\n\n## 配置SSH ##\n\ngithub本地和远程连接有两种方式，一种是通过https，另一种是SSH，推荐后一种。\n\n配置SSH的步骤如下：\n\n- 在本地生成公钥和私钥,命令如下：\n\n > ssh-keygen\n\n- 找到你保存公钥和私钥的文件夹，用记事本打开之前生成的id_rsa.pub文件,复制里面的公钥字符串。打开你的github网站，在setting里面的SSH keys，再点击Add SSH key 按钮添加，title域随便命名，Key域粘贴之前复制的内容。\n\n## 创建仓库 ##\n\ngithub有专门的一种格式来创建博客仓库的。新建一个仓库，仓库名为:**youusername.github.io**.\n\n# 建站 #\n\n## 克隆远程仓库 ##\n\n为了管理方便，建议再一个分支上存放hexo博客的源代码，master分支用来发布静态博客，步骤如下：\n\n - 在你的仓库中新建一个分支，我命名为hexo，然后切换到仓库的settitng的branch选项设置为默认分支。\n - 打开Git Bash，复制远程仓库\n    > git clone git@github.com:username/username.github.io.git\n - 克隆好远程仓库我们就可以开始建站了。在执行其它命令前，把根目录下的.git文件夹复制到另一个地方保存先，因为 hexo init命令会覆盖掉它。\n \n## 搭建hexo博客 ##\n\n打开终端，依次执行以下命令：\n\n> npm install hexo\n> hexo init\n> hexo install\n\n复制之前保存在另一个地方的.git文件夹再放到根目录下。\n\n> npm install hexo-deployer-git\n\n**注意：**这些命令都是工作在hexo分支上，以后也是。\n\n修改_config.yml中的deploy参数，分支应为master，可以按照如下设置：\n\n> deploy:\n> &nbsp;&nbsp;&nbsp;&nbsp;type:git\n> &nbsp;&nbsp;&nbsp;&nbsp;typerepo:（复制你的项目地址到这里）\n> &nbsp;&nbsp;&nbsp;&nbsp;typebranch:master\n \n- 依次执行 `git add .`,`git commit -m \"...\"`,`git push origin hexo`提交网站相关的文件\n- 执行`hexo g -d`生成网站并部署到GitHub上。\n\n此方法由知乎上的一位网友提供，链接在此：[hexo分支管理][2]， 必须记得复制.git文件夹不然本地仓库就失效了。\n\n## 配置个人信息 ##\n\n在根目录下有一个`_confug.yml`文件夹，在里面你可以通过相关字段来设置自己的个人信息。\n\n## 配置主题 ##\n\n我的博客使用的主题是nexT，网上有具体的使用文档 [NexT使用文档传送门][3]\n\n同时在文档中也介绍了如何安装第三方插件。\n\n# 添加域名 #\n\n添加域名有三个步骤：\n\n- 首先现在万网上买一个域名\n- 下一步注册DNSpod，然后添加域名，添加记录即可\n- 返回在你的仓库setting里面绑定域名，它会生成一个CNAME文件。\n\n**注意：**我在绑定域名后在本地重新提交代码部署静态博客时，CNAME文件总是被覆盖。解决办法是下载CNAME文件，放到本地站点目录下的source文件夹，注意CNAME是无格式的，不然会被部署到网站上。\n\n\n\n   \n\n\n  [1]: http://shelia.site/\n  [2]: https://www.zhihu.com/question/21193762\n  [3]: http://theme-next.iissnan.com/%20%E2%80%9CNexT%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D","slug":"HEXO-GithubPages搭建博客指南","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dk0006lvwv9lrttyif","content":"<blockquote>\n<p>Hexo是一个快速、简介且高效的博客框架，配置了多种主题，定制自己风格的博客。PS 我的博客地址传送门在这：<a href=\"http://shelia.site/\" target=\"_blank\" rel=\"noopener\">shelia’s blog</a></p>\n</blockquote>\n<p>[TOC]</p>\n<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><h2 id=\"安装Git-Bash\"><a href=\"#安装Git-Bash\" class=\"headerlink\" title=\"安装Git Bash\"></a>安装Git Bash</h2><p>github是程序员的标配，因为使用的是Windows系统，所以下了个github的客户端。里面包含了Git Bash和图形界面的Git GUI,使用哪个看个人习惯。建议使用GitBash，可以在日常的操作中熟悉常用指令。</p>\n<p>廖雪峰的Git教程有提供国内的镜像下载，或者可以到这个地址下载<a href=\"https://desktop.github.com/。\" target=\"_blank\" rel=\"noopener\">https://desktop.github.com/。</a></p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>Nodejs我是直接下载的客户端，直接用搜索引擎搜索一下就能找到。<br><strong>注意：</strong>安装时一路next的时候请选择Add to Path方式安装。</p>\n<h2 id=\"安装HEXO\"><a href=\"#安装HEXO\" class=\"headerlink\" title=\"安装HEXO\"></a>安装HEXO</h2><p>所有必须的软件安装后，打开终端（随你选择）输入以下命令安装hexo：</p>\n<blockquote>\n<p>npm install -g hexo-cli</p>\n</blockquote>\n<p><strong>注意：</strong>安装的时候如果出现warming不要管它之后也可以用，如果是ERROR的话可能需要你用管理员权限运行终端来安装。</p>\n<p>为了测试hexo是否正常安装，我们可以通过以下命令来测试（我的所有命令都是在管理员权限下的）。</p>\n<p>在你喜欢的任意一个地方，新建一个博客文件夹：</p>\n<blockquote>\n<p>hexo init hexoblog</p>\n</blockquote>\n<p>安装依赖：</p>\n<blockquote>\n<p>npm install</p>\n</blockquote>\n<p>本地运行测试</p>\n<blockquote>\n<p>hexo s</p>\n</blockquote>\n<p>如果成功会打印:Hexo is running at  <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a>. Press Ctrl+C to stop,再打开你的浏览器输入localhost:4000地址就可以看到你的博客了。</p>\n<h1 id=\"在github上创建GithubPages\"><a href=\"#在github上创建GithubPages\" class=\"headerlink\" title=\"在github上创建GithubPages\"></a>在github上创建GithubPages</h1><h2 id=\"配置SSH\"><a href=\"#配置SSH\" class=\"headerlink\" title=\"配置SSH\"></a>配置SSH</h2><p>github本地和远程连接有两种方式，一种是通过https，另一种是SSH，推荐后一种。</p>\n<p>配置SSH的步骤如下：</p>\n<ul>\n<li><p>在本地生成公钥和私钥,命令如下：</p>\n<blockquote>\n<p>ssh-keygen</p>\n</blockquote>\n</li>\n<li><p>找到你保存公钥和私钥的文件夹，用记事本打开之前生成的id_rsa.pub文件,复制里面的公钥字符串。打开你的github网站，在setting里面的SSH keys，再点击Add SSH key 按钮添加，title域随便命名，Key域粘贴之前复制的内容。</p>\n</li>\n</ul>\n<h2 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h2><p>github有专门的一种格式来创建博客仓库的。新建一个仓库，仓库名为:<strong>youusername.github.io</strong>.</p>\n<h1 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h1><h2 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h2><p>为了管理方便，建议再一个分支上存放hexo博客的源代码，master分支用来发布静态博客，步骤如下：</p>\n<ul>\n<li>在你的仓库中新建一个分支，我命名为hexo，然后切换到仓库的settitng的branch选项设置为默认分支。</li>\n<li>打开Git Bash，复制远程仓库<blockquote>\n<p>git clone git@github.com:username/username.github.io.git</p>\n</blockquote>\n</li>\n<li>克隆好远程仓库我们就可以开始建站了。在执行其它命令前，把根目录下的.git文件夹复制到另一个地方保存先，因为 hexo init命令会覆盖掉它。</li>\n</ul>\n<h2 id=\"搭建hexo博客\"><a href=\"#搭建hexo博客\" class=\"headerlink\" title=\"搭建hexo博客\"></a>搭建hexo博客</h2><p>打开终端，依次执行以下命令：</p>\n<blockquote>\n<p>npm install hexo<br>hexo init<br>hexo install</p>\n</blockquote>\n<p>复制之前保存在另一个地方的.git文件夹再放到根目录下。</p>\n<blockquote>\n<p>npm install hexo-deployer-git</p>\n</blockquote>\n<p><strong>注意：</strong>这些命令都是工作在hexo分支上，以后也是。</p>\n<p>修改_config.yml中的deploy参数，分支应为master，可以按照如下设置：</p>\n<blockquote>\n<p>deploy:<br>&nbsp;&nbsp;&nbsp;&nbsp;type:git<br>&nbsp;&nbsp;&nbsp;&nbsp;typerepo:（复制你的项目地址到这里）<br>&nbsp;&nbsp;&nbsp;&nbsp;typebranch:master</p>\n</blockquote>\n<ul>\n<li>依次执行 <code>git add .</code>,<code>git commit -m &quot;...&quot;</code>,<code>git push origin hexo</code>提交网站相关的文件</li>\n<li>执行<code>hexo g -d</code>生成网站并部署到GitHub上。</li>\n</ul>\n<p>此方法由知乎上的一位网友提供，链接在此：<a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">hexo分支管理</a>， 必须记得复制.git文件夹不然本地仓库就失效了。</p>\n<h2 id=\"配置个人信息\"><a href=\"#配置个人信息\" class=\"headerlink\" title=\"配置个人信息\"></a>配置个人信息</h2><p>在根目录下有一个<code>_confug.yml</code>文件夹，在里面你可以通过相关字段来设置自己的个人信息。</p>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p>我的博客使用的主题是nexT，网上有具体的使用文档 <a href=\"http://theme-next.iissnan.com/%20%E2%80%9CNexT%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D\" target=\"_blank\" rel=\"noopener\">NexT使用文档传送门</a></p>\n<p>同时在文档中也介绍了如何安装第三方插件。</p>\n<h1 id=\"添加域名\"><a href=\"#添加域名\" class=\"headerlink\" title=\"添加域名\"></a>添加域名</h1><p>添加域名有三个步骤：</p>\n<ul>\n<li>首先现在万网上买一个域名</li>\n<li>下一步注册DNSpod，然后添加域名，添加记录即可</li>\n<li>返回在你的仓库setting里面绑定域名，它会生成一个CNAME文件。</li>\n</ul>\n<p><strong>注意：</strong>我在绑定域名后在本地重新提交代码部署静态博客时，CNAME文件总是被覆盖。解决办法是下载CNAME文件，放到本地站点目录下的source文件夹，注意CNAME是无格式的，不然会被部署到网站上。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>Hexo是一个快速、简介且高效的博客框架，配置了多种主题，定制自己风格的博客。PS 我的博客地址传送门在这：<a href=\"http://shelia.site/\" target=\"_blank\" rel=\"noopener\">shelia’s blog</a></p>\n</blockquote>\n<p>[TOC]</p>\n<h1 id=\"前期准备\"><a href=\"#前期准备\" class=\"headerlink\" title=\"前期准备\"></a>前期准备</h1><h2 id=\"安装Git-Bash\"><a href=\"#安装Git-Bash\" class=\"headerlink\" title=\"安装Git Bash\"></a>安装Git Bash</h2><p>github是程序员的标配，因为使用的是Windows系统，所以下了个github的客户端。里面包含了Git Bash和图形界面的Git GUI,使用哪个看个人习惯。建议使用GitBash，可以在日常的操作中熟悉常用指令。</p>\n<p>廖雪峰的Git教程有提供国内的镜像下载，或者可以到这个地址下载<a href=\"https://desktop.github.com/。\" target=\"_blank\" rel=\"noopener\">https://desktop.github.com/。</a></p>\n<h2 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h2><p>Nodejs我是直接下载的客户端，直接用搜索引擎搜索一下就能找到。<br><strong>注意：</strong>安装时一路next的时候请选择Add to Path方式安装。</p>\n<h2 id=\"安装HEXO\"><a href=\"#安装HEXO\" class=\"headerlink\" title=\"安装HEXO\"></a>安装HEXO</h2><p>所有必须的软件安装后，打开终端（随你选择）输入以下命令安装hexo：</p>\n<blockquote>\n<p>npm install -g hexo-cli</p>\n</blockquote>\n<p><strong>注意：</strong>安装的时候如果出现warming不要管它之后也可以用，如果是ERROR的话可能需要你用管理员权限运行终端来安装。</p>\n<p>为了测试hexo是否正常安装，我们可以通过以下命令来测试（我的所有命令都是在管理员权限下的）。</p>\n<p>在你喜欢的任意一个地方，新建一个博客文件夹：</p>\n<blockquote>\n<p>hexo init hexoblog</p>\n</blockquote>\n<p>安装依赖：</p>\n<blockquote>\n<p>npm install</p>\n</blockquote>\n<p>本地运行测试</p>\n<blockquote>\n<p>hexo s</p>\n</blockquote>\n<p>如果成功会打印:Hexo is running at  <a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a>. Press Ctrl+C to stop,再打开你的浏览器输入localhost:4000地址就可以看到你的博客了。</p>\n<h1 id=\"在github上创建GithubPages\"><a href=\"#在github上创建GithubPages\" class=\"headerlink\" title=\"在github上创建GithubPages\"></a>在github上创建GithubPages</h1><h2 id=\"配置SSH\"><a href=\"#配置SSH\" class=\"headerlink\" title=\"配置SSH\"></a>配置SSH</h2><p>github本地和远程连接有两种方式，一种是通过https，另一种是SSH，推荐后一种。</p>\n<p>配置SSH的步骤如下：</p>\n<ul>\n<li><p>在本地生成公钥和私钥,命令如下：</p>\n<blockquote>\n<p>ssh-keygen</p>\n</blockquote>\n</li>\n<li><p>找到你保存公钥和私钥的文件夹，用记事本打开之前生成的id_rsa.pub文件,复制里面的公钥字符串。打开你的github网站，在setting里面的SSH keys，再点击Add SSH key 按钮添加，title域随便命名，Key域粘贴之前复制的内容。</p>\n</li>\n</ul>\n<h2 id=\"创建仓库\"><a href=\"#创建仓库\" class=\"headerlink\" title=\"创建仓库\"></a>创建仓库</h2><p>github有专门的一种格式来创建博客仓库的。新建一个仓库，仓库名为:<strong>youusername.github.io</strong>.</p>\n<h1 id=\"建站\"><a href=\"#建站\" class=\"headerlink\" title=\"建站\"></a>建站</h1><h2 id=\"克隆远程仓库\"><a href=\"#克隆远程仓库\" class=\"headerlink\" title=\"克隆远程仓库\"></a>克隆远程仓库</h2><p>为了管理方便，建议再一个分支上存放hexo博客的源代码，master分支用来发布静态博客，步骤如下：</p>\n<ul>\n<li>在你的仓库中新建一个分支，我命名为hexo，然后切换到仓库的settitng的branch选项设置为默认分支。</li>\n<li>打开Git Bash，复制远程仓库<blockquote>\n<p>git clone git@github.com:username/username.github.io.git</p>\n</blockquote>\n</li>\n<li>克隆好远程仓库我们就可以开始建站了。在执行其它命令前，把根目录下的.git文件夹复制到另一个地方保存先，因为 hexo init命令会覆盖掉它。</li>\n</ul>\n<h2 id=\"搭建hexo博客\"><a href=\"#搭建hexo博客\" class=\"headerlink\" title=\"搭建hexo博客\"></a>搭建hexo博客</h2><p>打开终端，依次执行以下命令：</p>\n<blockquote>\n<p>npm install hexo<br>hexo init<br>hexo install</p>\n</blockquote>\n<p>复制之前保存在另一个地方的.git文件夹再放到根目录下。</p>\n<blockquote>\n<p>npm install hexo-deployer-git</p>\n</blockquote>\n<p><strong>注意：</strong>这些命令都是工作在hexo分支上，以后也是。</p>\n<p>修改_config.yml中的deploy参数，分支应为master，可以按照如下设置：</p>\n<blockquote>\n<p>deploy:<br>&nbsp;&nbsp;&nbsp;&nbsp;type:git<br>&nbsp;&nbsp;&nbsp;&nbsp;typerepo:（复制你的项目地址到这里）<br>&nbsp;&nbsp;&nbsp;&nbsp;typebranch:master</p>\n</blockquote>\n<ul>\n<li>依次执行 <code>git add .</code>,<code>git commit -m &quot;...&quot;</code>,<code>git push origin hexo</code>提交网站相关的文件</li>\n<li>执行<code>hexo g -d</code>生成网站并部署到GitHub上。</li>\n</ul>\n<p>此方法由知乎上的一位网友提供，链接在此：<a href=\"https://www.zhihu.com/question/21193762\" target=\"_blank\" rel=\"noopener\">hexo分支管理</a>， 必须记得复制.git文件夹不然本地仓库就失效了。</p>\n<h2 id=\"配置个人信息\"><a href=\"#配置个人信息\" class=\"headerlink\" title=\"配置个人信息\"></a>配置个人信息</h2><p>在根目录下有一个<code>_confug.yml</code>文件夹，在里面你可以通过相关字段来设置自己的个人信息。</p>\n<h2 id=\"配置主题\"><a href=\"#配置主题\" class=\"headerlink\" title=\"配置主题\"></a>配置主题</h2><p>我的博客使用的主题是nexT，网上有具体的使用文档 <a href=\"http://theme-next.iissnan.com/%20%E2%80%9CNexT%E4%BD%BF%E7%94%A8%E6%96%87%E6%A1%A3%E4%BC%A0%E9%80%81%E9%97%A8%E2%80%9D\" target=\"_blank\" rel=\"noopener\">NexT使用文档传送门</a></p>\n<p>同时在文档中也介绍了如何安装第三方插件。</p>\n<h1 id=\"添加域名\"><a href=\"#添加域名\" class=\"headerlink\" title=\"添加域名\"></a>添加域名</h1><p>添加域名有三个步骤：</p>\n<ul>\n<li>首先现在万网上买一个域名</li>\n<li>下一步注册DNSpod，然后添加域名，添加记录即可</li>\n<li>返回在你的仓库setting里面绑定域名，它会生成一个CNAME文件。</li>\n</ul>\n<p><strong>注意：</strong>我在绑定域名后在本地重新提交代码部署静态博客时，CNAME文件总是被覆盖。解决办法是下载CNAME文件，放到本地站点目录下的source文件夹，注意CNAME是无格式的，不然会被部署到网站上。</p>\n"},{"title":"Less学习笔记一","date":"2017-02-16T13:06:27.000Z","_content":"\n> 一直很想学习下CSS预处理语言，选择了Less，无论是Sass还是Less，选择合适自己的就好，没有优劣，下面是这几天的学习笔记。\n\n# Less简介\n\n开头还是老样子，介绍一下什么是Less。Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。\n\n使用Less是编写.less后缀的文件后进行编译，编译会输出一个CSS文件。\n\n最简单的使用方式是通过npm安装，如下：\n`$npm install -g less`\n安装后，就可以在命令行调用Less编译器：\n`$lessc style.less>style.css`\n\n接下来的重点是Less的语法。\n\n# 变量\n\n变量的格式为：@name:value，如：\n\n    @nice-blue:#5B83AD\n    @light-blue:@nice-blue + #111;\n    #header{color:@light-blue;}\n\n编译后输出为：\n\n    #header{color:#6C94BE;}\n    \n- 可以在定义变量值时使用其他的变量\n- 变量是按需加载的，因此不必强制在使用前声明\n- 如果对同一个变量声明两次的话，在当前作用域中最后一次定义的将会被使用\n\n# 混合（Mixins）\n\n在Less中我们可以定义一些通用的属性集为一个class，然后在另一个class去调用这些属性。\n\n## 直接引用某个类的全部属性\n\n示例：\n\n    .bordered{\n    border-top:dotted 1px black;\n    border-bottom:solid 2px black;\n    }\n    \n    #menu a{\n    color:#111;\n    .bordered;\n    }\n\n\n## 引用带参数无默认值的类属性\n\n示例：\n\n    .border-radius(@radius){\n    border-radius:@radius;\n    -moz-border-radius:@radius;\n    -webkit-border-radius:@radius;\n    }\n    \n    #header{\n    .border-radius(4px);\n    }\n\n## 引用带参数有默认值的类属性\n\n    .bordered(@border_width:2px){\n    border:@border_width solid black;\n    }\n    \n    #header{.bordered();//有默认值，可以不传参}\n\n**注意：**\n\n- @arguments可以表示所有的参数\n- @rest可以表示某个参数之后的变量，如：`.mixin(@a,@rest...){...}`，这里的@rest表示@a之后的参数。\n\n# 模式匹配与Guard表达式\n\nLess提供了通过参数值控制Minxin行为的功能，根据switch的值控制，示例如下：\n\n    .mixin(dark,@color){\n    color:darken(@color,10%);\n    }\n    .mixin(light,@color){\n    color:lighten(@color,10%);\n    }\n    .mixin(@_,@color){\n    display:block;\n    }\n    调用:\n    @switch:light;\n    .class{\n    .mixin(@switch,#888);\n    }\n    将会得到:\n    .class{\n    color:#a2a2a2;\n    display:block;\n    }\n    \n**注意：**也可以根据参数的数量进行匹配\n\n#Guards\n\n上面的匹配为匹配值或者参数数量，Guards被用来匹配表达式。\n示例：\n\n    .mixin(@a)when(lightness(@a)>=50%){\n    background-color:black;\n    }\n    .mixin(@a)when(lightness(@a)<50%){\n    background-color:white;\n    }\n    .mixin(@a){\n    color:@a;\n    }\n    \n重点在于关键词when，它引入了一个Guards条件，运行以下代码：\n\n    .class1{.mixin(#ddd)}\n    .class2(.mixin(#555)}\n    \n输出：\n\n    .class1{\n    background-color:black;\n    color:#ddd;\n    }\n    .class2{\n    background-color:white;\n    color:#555;\n    }\n\n它根据了参数的颜色值用when选择了不同的背景色。\n- Guards支持的运算符包括：>,>=,<,<=,=\n- 多个Guards可以通过逗号分隔，如果其中一个结果为true，则匹配成功\n","source":"_posts/Less学习笔记一.md","raw":"---\ntitle: Less学习笔记一\ndate: 2017-02-16 21:06:27\ntags: Less\n---\n\n> 一直很想学习下CSS预处理语言，选择了Less，无论是Sass还是Less，选择合适自己的就好，没有优劣，下面是这几天的学习笔记。\n\n# Less简介\n\n开头还是老样子，介绍一下什么是Less。Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。\n\n使用Less是编写.less后缀的文件后进行编译，编译会输出一个CSS文件。\n\n最简单的使用方式是通过npm安装，如下：\n`$npm install -g less`\n安装后，就可以在命令行调用Less编译器：\n`$lessc style.less>style.css`\n\n接下来的重点是Less的语法。\n\n# 变量\n\n变量的格式为：@name:value，如：\n\n    @nice-blue:#5B83AD\n    @light-blue:@nice-blue + #111;\n    #header{color:@light-blue;}\n\n编译后输出为：\n\n    #header{color:#6C94BE;}\n    \n- 可以在定义变量值时使用其他的变量\n- 变量是按需加载的，因此不必强制在使用前声明\n- 如果对同一个变量声明两次的话，在当前作用域中最后一次定义的将会被使用\n\n# 混合（Mixins）\n\n在Less中我们可以定义一些通用的属性集为一个class，然后在另一个class去调用这些属性。\n\n## 直接引用某个类的全部属性\n\n示例：\n\n    .bordered{\n    border-top:dotted 1px black;\n    border-bottom:solid 2px black;\n    }\n    \n    #menu a{\n    color:#111;\n    .bordered;\n    }\n\n\n## 引用带参数无默认值的类属性\n\n示例：\n\n    .border-radius(@radius){\n    border-radius:@radius;\n    -moz-border-radius:@radius;\n    -webkit-border-radius:@radius;\n    }\n    \n    #header{\n    .border-radius(4px);\n    }\n\n## 引用带参数有默认值的类属性\n\n    .bordered(@border_width:2px){\n    border:@border_width solid black;\n    }\n    \n    #header{.bordered();//有默认值，可以不传参}\n\n**注意：**\n\n- @arguments可以表示所有的参数\n- @rest可以表示某个参数之后的变量，如：`.mixin(@a,@rest...){...}`，这里的@rest表示@a之后的参数。\n\n# 模式匹配与Guard表达式\n\nLess提供了通过参数值控制Minxin行为的功能，根据switch的值控制，示例如下：\n\n    .mixin(dark,@color){\n    color:darken(@color,10%);\n    }\n    .mixin(light,@color){\n    color:lighten(@color,10%);\n    }\n    .mixin(@_,@color){\n    display:block;\n    }\n    调用:\n    @switch:light;\n    .class{\n    .mixin(@switch,#888);\n    }\n    将会得到:\n    .class{\n    color:#a2a2a2;\n    display:block;\n    }\n    \n**注意：**也可以根据参数的数量进行匹配\n\n#Guards\n\n上面的匹配为匹配值或者参数数量，Guards被用来匹配表达式。\n示例：\n\n    .mixin(@a)when(lightness(@a)>=50%){\n    background-color:black;\n    }\n    .mixin(@a)when(lightness(@a)<50%){\n    background-color:white;\n    }\n    .mixin(@a){\n    color:@a;\n    }\n    \n重点在于关键词when，它引入了一个Guards条件，运行以下代码：\n\n    .class1{.mixin(#ddd)}\n    .class2(.mixin(#555)}\n    \n输出：\n\n    .class1{\n    background-color:black;\n    color:#ddd;\n    }\n    .class2{\n    background-color:white;\n    color:#555;\n    }\n\n它根据了参数的颜色值用when选择了不同的背景色。\n- Guards支持的运算符包括：>,>=,<,<=,=\n- 多个Guards可以通过逗号分隔，如果其中一个结果为true，则匹配成功\n","slug":"Less学习笔记一","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dl0007lvwvjmkzpxs9","content":"<blockquote>\n<p>一直很想学习下CSS预处理语言，选择了Less，无论是Sass还是Less，选择合适自己的就好，没有优劣，下面是这几天的学习笔记。</p>\n</blockquote>\n<h1 id=\"Less简介\"><a href=\"#Less简介\" class=\"headerlink\" title=\"Less简介\"></a>Less简介</h1><p>开头还是老样子，介绍一下什么是Less。Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。</p>\n<p>使用Less是编写.less后缀的文件后进行编译，编译会输出一个CSS文件。</p>\n<p>最简单的使用方式是通过npm安装，如下：<br><code>$npm install -g less</code><br>安装后，就可以在命令行调用Less编译器：<br><code>$lessc style.less&gt;style.css</code></p>\n<p>接下来的重点是Less的语法。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>变量的格式为：@name:value，如：</p>\n<pre><code>@nice-blue:#5B83AD\n@light-blue:@nice-blue + #111;\n#header{color:@light-blue;}\n</code></pre><p>编译后输出为：</p>\n<pre><code>#header{color:#6C94BE;}\n</code></pre><ul>\n<li>可以在定义变量值时使用其他的变量</li>\n<li>变量是按需加载的，因此不必强制在使用前声明</li>\n<li>如果对同一个变量声明两次的话，在当前作用域中最后一次定义的将会被使用</li>\n</ul>\n<h1 id=\"混合（Mixins）\"><a href=\"#混合（Mixins）\" class=\"headerlink\" title=\"混合（Mixins）\"></a>混合（Mixins）</h1><p>在Less中我们可以定义一些通用的属性集为一个class，然后在另一个class去调用这些属性。</p>\n<h2 id=\"直接引用某个类的全部属性\"><a href=\"#直接引用某个类的全部属性\" class=\"headerlink\" title=\"直接引用某个类的全部属性\"></a>直接引用某个类的全部属性</h2><p>示例：</p>\n<pre><code>.bordered{\nborder-top:dotted 1px black;\nborder-bottom:solid 2px black;\n}\n\n#menu a{\ncolor:#111;\n.bordered;\n}\n</code></pre><h2 id=\"引用带参数无默认值的类属性\"><a href=\"#引用带参数无默认值的类属性\" class=\"headerlink\" title=\"引用带参数无默认值的类属性\"></a>引用带参数无默认值的类属性</h2><p>示例：</p>\n<pre><code>.border-radius(@radius){\nborder-radius:@radius;\n-moz-border-radius:@radius;\n-webkit-border-radius:@radius;\n}\n\n#header{\n.border-radius(4px);\n}\n</code></pre><h2 id=\"引用带参数有默认值的类属性\"><a href=\"#引用带参数有默认值的类属性\" class=\"headerlink\" title=\"引用带参数有默认值的类属性\"></a>引用带参数有默认值的类属性</h2><pre><code>.bordered(@border_width:2px){\nborder:@border_width solid black;\n}\n\n#header{.bordered();//有默认值，可以不传参}\n</code></pre><p><strong>注意：</strong></p>\n<ul>\n<li>@arguments可以表示所有的参数</li>\n<li>@rest可以表示某个参数之后的变量，如：<code>.mixin(@a,@rest...){...}</code>，这里的@rest表示@a之后的参数。</li>\n</ul>\n<h1 id=\"模式匹配与Guard表达式\"><a href=\"#模式匹配与Guard表达式\" class=\"headerlink\" title=\"模式匹配与Guard表达式\"></a>模式匹配与Guard表达式</h1><p>Less提供了通过参数值控制Minxin行为的功能，根据switch的值控制，示例如下：</p>\n<pre><code>.mixin(dark,@color){\ncolor:darken(@color,10%);\n}\n.mixin(light,@color){\ncolor:lighten(@color,10%);\n}\n.mixin(@_,@color){\ndisplay:block;\n}\n调用:\n@switch:light;\n.class{\n.mixin(@switch,#888);\n}\n将会得到:\n.class{\ncolor:#a2a2a2;\ndisplay:block;\n}\n</code></pre><p><strong>注意：</strong>也可以根据参数的数量进行匹配</p>\n<p>#Guards</p>\n<p>上面的匹配为匹配值或者参数数量，Guards被用来匹配表达式。<br>示例：</p>\n<pre><code>.mixin(@a)when(lightness(@a)&gt;=50%){\nbackground-color:black;\n}\n.mixin(@a)when(lightness(@a)&lt;50%){\nbackground-color:white;\n}\n.mixin(@a){\ncolor:@a;\n}\n</code></pre><p>重点在于关键词when，它引入了一个Guards条件，运行以下代码：</p>\n<pre><code>.class1{.mixin(#ddd)}\n.class2(.mixin(#555)}\n</code></pre><p>输出：</p>\n<pre><code>.class1{\nbackground-color:black;\ncolor:#ddd;\n}\n.class2{\nbackground-color:white;\ncolor:#555;\n}\n</code></pre><p>它根据了参数的颜色值用when选择了不同的背景色。</p>\n<ul>\n<li>Guards支持的运算符包括：&gt;,&gt;=,&lt;,&lt;=,=</li>\n<li>多个Guards可以通过逗号分隔，如果其中一个结果为true，则匹配成功</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>一直很想学习下CSS预处理语言，选择了Less，无论是Sass还是Less，选择合适自己的就好，没有优劣，下面是这几天的学习笔记。</p>\n</blockquote>\n<h1 id=\"Less简介\"><a href=\"#Less简介\" class=\"headerlink\" title=\"Less简介\"></a>Less简介</h1><p>开头还是老样子，介绍一下什么是Less。Less是一门CSS预处理语言，它扩充了CSS语言，增加了诸如变量、混合、函数等功能，让CSS更易维护、方便制作主题、扩充。</p>\n<p>使用Less是编写.less后缀的文件后进行编译，编译会输出一个CSS文件。</p>\n<p>最简单的使用方式是通过npm安装，如下：<br><code>$npm install -g less</code><br>安装后，就可以在命令行调用Less编译器：<br><code>$lessc style.less&gt;style.css</code></p>\n<p>接下来的重点是Less的语法。</p>\n<h1 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h1><p>变量的格式为：@name:value，如：</p>\n<pre><code>@nice-blue:#5B83AD\n@light-blue:@nice-blue + #111;\n#header{color:@light-blue;}\n</code></pre><p>编译后输出为：</p>\n<pre><code>#header{color:#6C94BE;}\n</code></pre><ul>\n<li>可以在定义变量值时使用其他的变量</li>\n<li>变量是按需加载的，因此不必强制在使用前声明</li>\n<li>如果对同一个变量声明两次的话，在当前作用域中最后一次定义的将会被使用</li>\n</ul>\n<h1 id=\"混合（Mixins）\"><a href=\"#混合（Mixins）\" class=\"headerlink\" title=\"混合（Mixins）\"></a>混合（Mixins）</h1><p>在Less中我们可以定义一些通用的属性集为一个class，然后在另一个class去调用这些属性。</p>\n<h2 id=\"直接引用某个类的全部属性\"><a href=\"#直接引用某个类的全部属性\" class=\"headerlink\" title=\"直接引用某个类的全部属性\"></a>直接引用某个类的全部属性</h2><p>示例：</p>\n<pre><code>.bordered{\nborder-top:dotted 1px black;\nborder-bottom:solid 2px black;\n}\n\n#menu a{\ncolor:#111;\n.bordered;\n}\n</code></pre><h2 id=\"引用带参数无默认值的类属性\"><a href=\"#引用带参数无默认值的类属性\" class=\"headerlink\" title=\"引用带参数无默认值的类属性\"></a>引用带参数无默认值的类属性</h2><p>示例：</p>\n<pre><code>.border-radius(@radius){\nborder-radius:@radius;\n-moz-border-radius:@radius;\n-webkit-border-radius:@radius;\n}\n\n#header{\n.border-radius(4px);\n}\n</code></pre><h2 id=\"引用带参数有默认值的类属性\"><a href=\"#引用带参数有默认值的类属性\" class=\"headerlink\" title=\"引用带参数有默认值的类属性\"></a>引用带参数有默认值的类属性</h2><pre><code>.bordered(@border_width:2px){\nborder:@border_width solid black;\n}\n\n#header{.bordered();//有默认值，可以不传参}\n</code></pre><p><strong>注意：</strong></p>\n<ul>\n<li>@arguments可以表示所有的参数</li>\n<li>@rest可以表示某个参数之后的变量，如：<code>.mixin(@a,@rest...){...}</code>，这里的@rest表示@a之后的参数。</li>\n</ul>\n<h1 id=\"模式匹配与Guard表达式\"><a href=\"#模式匹配与Guard表达式\" class=\"headerlink\" title=\"模式匹配与Guard表达式\"></a>模式匹配与Guard表达式</h1><p>Less提供了通过参数值控制Minxin行为的功能，根据switch的值控制，示例如下：</p>\n<pre><code>.mixin(dark,@color){\ncolor:darken(@color,10%);\n}\n.mixin(light,@color){\ncolor:lighten(@color,10%);\n}\n.mixin(@_,@color){\ndisplay:block;\n}\n调用:\n@switch:light;\n.class{\n.mixin(@switch,#888);\n}\n将会得到:\n.class{\ncolor:#a2a2a2;\ndisplay:block;\n}\n</code></pre><p><strong>注意：</strong>也可以根据参数的数量进行匹配</p>\n<p>#Guards</p>\n<p>上面的匹配为匹配值或者参数数量，Guards被用来匹配表达式。<br>示例：</p>\n<pre><code>.mixin(@a)when(lightness(@a)&gt;=50%){\nbackground-color:black;\n}\n.mixin(@a)when(lightness(@a)&lt;50%){\nbackground-color:white;\n}\n.mixin(@a){\ncolor:@a;\n}\n</code></pre><p>重点在于关键词when，它引入了一个Guards条件，运行以下代码：</p>\n<pre><code>.class1{.mixin(#ddd)}\n.class2(.mixin(#555)}\n</code></pre><p>输出：</p>\n<pre><code>.class1{\nbackground-color:black;\ncolor:#ddd;\n}\n.class2{\nbackground-color:white;\ncolor:#555;\n}\n</code></pre><p>它根据了参数的颜色值用when选择了不同的背景色。</p>\n<ul>\n<li>Guards支持的运算符包括：&gt;,&gt;=,&lt;,&lt;=,=</li>\n<li>多个Guards可以通过逗号分隔，如果其中一个结果为true，则匹配成功</li>\n</ul>\n"},{"title":"Less学习笔记二","date":"2017-02-16T13:06:39.000Z","_content":"> 第二篇Less学习笔记,接着Less学习笔记一。\n\n# 嵌套规则\n\n在Less中可以嵌套地写CSS，如下：\n\n    #header{\n    color:black;\n    .navigation{\n    font-size:12px\n    }\n    .logon{\n    width:300px;\n    &:hover{text-decoration:none;}\n    }\n    }\n    \n注意&符号的使用，如果想写串联选择器可以使用，这点对伪类尤其有用：如`:hover`,`:focus`。\n\n\n# 运算\n\n任何数字、yanse或者变量都可以参与运算，运算应该被包裹在括号中。\n\n# 函数\n\nLess提供了很多便利的函数，想具体了解可以点击[函数手册][1]。\n\n如`percentage(0.5)`为转化为50%。\n\n# 命名空间\n\n将一些变量或者混合模块打包起来，为了更好地封装，示例如下：\n\n    #bundle{\n    .button(){\n    display：block;\n    border:1px silid black;\n    ...\n    }\n    .tab{...}\n    ...\n    }\n    \n你只需在#header a 中像这样引入.button:\n\n    #header a{\n    color:orange;\n    #bundle > .button;\n    }\n\n# 作用域\n\n首先会从本地查找变量或者混合模块，如果没找到的话就会去父级作用域查找，知道找到为止。\n\n# 注释\n\n在Less中：\n\n - /*...*/注释在编译成CSS会保留\n - //在编译成CSS会自动过滤掉\n\n\n# 导入(Import)\n\n - 既可以导入CSS文件，也可以导入Less文件\n - 对CSS文件只做一处处理，将导入语句提前到前面\n - 被导入的Less文件会和当前文件共享所有的混合、变量、命名空间等\n - 导入语句是通过media query指定的，编译后包裹在@media声明中\n - Less文件的导入语句可以随意放置\n\n# 字符串插值\n\n变量可以用像@{name}这样的结构：\n\n     @base-url: \"http://assets.fnord.com\";\n    background-image: url(\"@{base-url}/images/bg.png\");\n\n# 避免编译\n\n有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。\n\n要输出这样的值我们可以在字符串前加上一个 ~，例如：\n\n    .class {\n    filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";\n}\n输出结果为：\n\n    .class {\n    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();\n}\n\n# 选择器插值\n\n如果需要在选择器中使用变量，使用方式为`@{name}`，示例：\n\n    @name:blocked;\n    .@{name}{\n    color:red;\n    }\n    \n\n# media query作为变量\n\n如果你希望在media query中使用LESS变量，你可以直接使用普通的变量方式。例如：\n\n    @singleQuery: ~\"(max-width: 500px)\";\n@media screen, @singleQuery {\n    set {\n        padding: 3 3 3 3;\n    }\n}\n输出结果为：\n\n    @media screen, (max-width: 500px) {\n    set {\n        padding: 3 3 3 3;\n    }\n}\n\n结语：这两篇笔记差不多讲完了Less的语法，没有很详细，熟练还是靠多使用和练习。在前端的道路上还有很多东西要学习，just go on！！！\n\n\n  [1]: http://lesscss.cn/functions/","source":"_posts/Less学习笔记二.md","raw":"---\ntitle: Less学习笔记二\ndate: 2017-02-16 21:06:39\ntags: Less\n---\n> 第二篇Less学习笔记,接着Less学习笔记一。\n\n# 嵌套规则\n\n在Less中可以嵌套地写CSS，如下：\n\n    #header{\n    color:black;\n    .navigation{\n    font-size:12px\n    }\n    .logon{\n    width:300px;\n    &:hover{text-decoration:none;}\n    }\n    }\n    \n注意&符号的使用，如果想写串联选择器可以使用，这点对伪类尤其有用：如`:hover`,`:focus`。\n\n\n# 运算\n\n任何数字、yanse或者变量都可以参与运算，运算应该被包裹在括号中。\n\n# 函数\n\nLess提供了很多便利的函数，想具体了解可以点击[函数手册][1]。\n\n如`percentage(0.5)`为转化为50%。\n\n# 命名空间\n\n将一些变量或者混合模块打包起来，为了更好地封装，示例如下：\n\n    #bundle{\n    .button(){\n    display：block;\n    border:1px silid black;\n    ...\n    }\n    .tab{...}\n    ...\n    }\n    \n你只需在#header a 中像这样引入.button:\n\n    #header a{\n    color:orange;\n    #bundle > .button;\n    }\n\n# 作用域\n\n首先会从本地查找变量或者混合模块，如果没找到的话就会去父级作用域查找，知道找到为止。\n\n# 注释\n\n在Less中：\n\n - /*...*/注释在编译成CSS会保留\n - //在编译成CSS会自动过滤掉\n\n\n# 导入(Import)\n\n - 既可以导入CSS文件，也可以导入Less文件\n - 对CSS文件只做一处处理，将导入语句提前到前面\n - 被导入的Less文件会和当前文件共享所有的混合、变量、命名空间等\n - 导入语句是通过media query指定的，编译后包裹在@media声明中\n - Less文件的导入语句可以随意放置\n\n# 字符串插值\n\n变量可以用像@{name}这样的结构：\n\n     @base-url: \"http://assets.fnord.com\";\n    background-image: url(\"@{base-url}/images/bg.png\");\n\n# 避免编译\n\n有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。\n\n要输出这样的值我们可以在字符串前加上一个 ~，例如：\n\n    .class {\n    filter: ~\"ms:alwaysHasItsOwnSyntax.For.Stuff()\";\n}\n输出结果为：\n\n    .class {\n    filter: ms:alwaysHasItsOwnSyntax.For.Stuff();\n}\n\n# 选择器插值\n\n如果需要在选择器中使用变量，使用方式为`@{name}`，示例：\n\n    @name:blocked;\n    .@{name}{\n    color:red;\n    }\n    \n\n# media query作为变量\n\n如果你希望在media query中使用LESS变量，你可以直接使用普通的变量方式。例如：\n\n    @singleQuery: ~\"(max-width: 500px)\";\n@media screen, @singleQuery {\n    set {\n        padding: 3 3 3 3;\n    }\n}\n输出结果为：\n\n    @media screen, (max-width: 500px) {\n    set {\n        padding: 3 3 3 3;\n    }\n}\n\n结语：这两篇笔记差不多讲完了Less的语法，没有很详细，熟练还是靠多使用和练习。在前端的道路上还有很多东西要学习，just go on！！！\n\n\n  [1]: http://lesscss.cn/functions/","slug":"Less学习笔记二","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dm000alvwvi6ts25p7","content":"<blockquote>\n<p>第二篇Less学习笔记,接着Less学习笔记一。</p>\n</blockquote>\n<h1 id=\"嵌套规则\"><a href=\"#嵌套规则\" class=\"headerlink\" title=\"嵌套规则\"></a>嵌套规则</h1><p>在Less中可以嵌套地写CSS，如下：</p>\n<pre><code>#header{\ncolor:black;\n.navigation{\nfont-size:12px\n}\n.logon{\nwidth:300px;\n&amp;:hover{text-decoration:none;}\n}\n}\n</code></pre><p>注意&amp;符号的使用，如果想写串联选择器可以使用，这点对伪类尤其有用：如<code>:hover</code>,<code>:focus</code>。</p>\n<h1 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h1><p>任何数字、yanse或者变量都可以参与运算，运算应该被包裹在括号中。</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>Less提供了很多便利的函数，想具体了解可以点击<a href=\"http://lesscss.cn/functions/\" target=\"_blank\" rel=\"noopener\">函数手册</a>。</p>\n<p>如<code>percentage(0.5)</code>为转化为50%。</p>\n<h1 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h1><p>将一些变量或者混合模块打包起来，为了更好地封装，示例如下：</p>\n<pre><code>#bundle{\n.button(){\ndisplay：block;\nborder:1px silid black;\n...\n}\n.tab{...}\n...\n}\n</code></pre><p>你只需在#header a 中像这样引入.button:</p>\n<pre><code>#header a{\ncolor:orange;\n#bundle &gt; .button;\n}\n</code></pre><h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>首先会从本地查找变量或者混合模块，如果没找到的话就会去父级作用域查找，知道找到为止。</p>\n<h1 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h1><p>在Less中：</p>\n<ul>\n<li>/<em>…</em>/注释在编译成CSS会保留</li>\n<li>//在编译成CSS会自动过滤掉</li>\n</ul>\n<h1 id=\"导入-Import\"><a href=\"#导入-Import\" class=\"headerlink\" title=\"导入(Import)\"></a>导入(Import)</h1><ul>\n<li>既可以导入CSS文件，也可以导入Less文件</li>\n<li>对CSS文件只做一处处理，将导入语句提前到前面</li>\n<li>被导入的Less文件会和当前文件共享所有的混合、变量、命名空间等</li>\n<li>导入语句是通过media query指定的，编译后包裹在@media声明中</li>\n<li>Less文件的导入语句可以随意放置</li>\n</ul>\n<h1 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h1><p>变量可以用像@{name}这样的结构：</p>\n<pre><code> @base-url: &quot;http://assets.fnord.com&quot;;\nbackground-image: url(&quot;@{base-url}/images/bg.png&quot;);\n</code></pre><h1 id=\"避免编译\"><a href=\"#避免编译\" class=\"headerlink\" title=\"避免编译\"></a>避免编译</h1><p>有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。</p>\n<p>要输出这样的值我们可以在字符串前加上一个 ~，例如：</p>\n<pre><code>.class {\nfilter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;\n</code></pre><p>}<br>输出结果为：</p>\n<pre><code>.class {\nfilter: ms:alwaysHasItsOwnSyntax.For.Stuff();\n</code></pre><p>}</p>\n<h1 id=\"选择器插值\"><a href=\"#选择器插值\" class=\"headerlink\" title=\"选择器插值\"></a>选择器插值</h1><p>如果需要在选择器中使用变量，使用方式为<code>@{name}</code>，示例：</p>\n<pre><code>@name:blocked;\n.@{name}{\ncolor:red;\n}\n</code></pre><h1 id=\"media-query作为变量\"><a href=\"#media-query作为变量\" class=\"headerlink\" title=\"media query作为变量\"></a>media query作为变量</h1><p>如果你希望在media query中使用LESS变量，你可以直接使用普通的变量方式。例如：</p>\n<pre><code>@singleQuery: ~&quot;(max-width: 500px)&quot;;\n</code></pre><p>@media screen, @singleQuery {<br>    set {<br>        padding: 3 3 3 3;<br>    }<br>}<br>输出结果为：</p>\n<pre><code>@media screen, (max-width: 500px) {\nset {\n    padding: 3 3 3 3;\n}\n</code></pre><p>}</p>\n<p>结语：这两篇笔记差不多讲完了Less的语法，没有很详细，熟练还是靠多使用和练习。在前端的道路上还有很多东西要学习，just go on！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>第二篇Less学习笔记,接着Less学习笔记一。</p>\n</blockquote>\n<h1 id=\"嵌套规则\"><a href=\"#嵌套规则\" class=\"headerlink\" title=\"嵌套规则\"></a>嵌套规则</h1><p>在Less中可以嵌套地写CSS，如下：</p>\n<pre><code>#header{\ncolor:black;\n.navigation{\nfont-size:12px\n}\n.logon{\nwidth:300px;\n&amp;:hover{text-decoration:none;}\n}\n}\n</code></pre><p>注意&amp;符号的使用，如果想写串联选择器可以使用，这点对伪类尤其有用：如<code>:hover</code>,<code>:focus</code>。</p>\n<h1 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h1><p>任何数字、yanse或者变量都可以参与运算，运算应该被包裹在括号中。</p>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><p>Less提供了很多便利的函数，想具体了解可以点击<a href=\"http://lesscss.cn/functions/\" target=\"_blank\" rel=\"noopener\">函数手册</a>。</p>\n<p>如<code>percentage(0.5)</code>为转化为50%。</p>\n<h1 id=\"命名空间\"><a href=\"#命名空间\" class=\"headerlink\" title=\"命名空间\"></a>命名空间</h1><p>将一些变量或者混合模块打包起来，为了更好地封装，示例如下：</p>\n<pre><code>#bundle{\n.button(){\ndisplay：block;\nborder:1px silid black;\n...\n}\n.tab{...}\n...\n}\n</code></pre><p>你只需在#header a 中像这样引入.button:</p>\n<pre><code>#header a{\ncolor:orange;\n#bundle &gt; .button;\n}\n</code></pre><h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>首先会从本地查找变量或者混合模块，如果没找到的话就会去父级作用域查找，知道找到为止。</p>\n<h1 id=\"注释\"><a href=\"#注释\" class=\"headerlink\" title=\"注释\"></a>注释</h1><p>在Less中：</p>\n<ul>\n<li>/<em>…</em>/注释在编译成CSS会保留</li>\n<li>//在编译成CSS会自动过滤掉</li>\n</ul>\n<h1 id=\"导入-Import\"><a href=\"#导入-Import\" class=\"headerlink\" title=\"导入(Import)\"></a>导入(Import)</h1><ul>\n<li>既可以导入CSS文件，也可以导入Less文件</li>\n<li>对CSS文件只做一处处理，将导入语句提前到前面</li>\n<li>被导入的Less文件会和当前文件共享所有的混合、变量、命名空间等</li>\n<li>导入语句是通过media query指定的，编译后包裹在@media声明中</li>\n<li>Less文件的导入语句可以随意放置</li>\n</ul>\n<h1 id=\"字符串插值\"><a href=\"#字符串插值\" class=\"headerlink\" title=\"字符串插值\"></a>字符串插值</h1><p>变量可以用像@{name}这样的结构：</p>\n<pre><code> @base-url: &quot;http://assets.fnord.com&quot;;\nbackground-image: url(&quot;@{base-url}/images/bg.png&quot;);\n</code></pre><h1 id=\"避免编译\"><a href=\"#避免编译\" class=\"headerlink\" title=\"避免编译\"></a>避免编译</h1><p>有时候我们需要输出一些不正确的 CSS 语法或者使用一些 LESS 不认识的专有语法。</p>\n<p>要输出这样的值我们可以在字符串前加上一个 ~，例如：</p>\n<pre><code>.class {\nfilter: ~&quot;ms:alwaysHasItsOwnSyntax.For.Stuff()&quot;;\n</code></pre><p>}<br>输出结果为：</p>\n<pre><code>.class {\nfilter: ms:alwaysHasItsOwnSyntax.For.Stuff();\n</code></pre><p>}</p>\n<h1 id=\"选择器插值\"><a href=\"#选择器插值\" class=\"headerlink\" title=\"选择器插值\"></a>选择器插值</h1><p>如果需要在选择器中使用变量，使用方式为<code>@{name}</code>，示例：</p>\n<pre><code>@name:blocked;\n.@{name}{\ncolor:red;\n}\n</code></pre><h1 id=\"media-query作为变量\"><a href=\"#media-query作为变量\" class=\"headerlink\" title=\"media query作为变量\"></a>media query作为变量</h1><p>如果你希望在media query中使用LESS变量，你可以直接使用普通的变量方式。例如：</p>\n<pre><code>@singleQuery: ~&quot;(max-width: 500px)&quot;;\n</code></pre><p>@media screen, @singleQuery {<br>    set {<br>        padding: 3 3 3 3;<br>    }<br>}<br>输出结果为：</p>\n<pre><code>@media screen, (max-width: 500px) {\nset {\n    padding: 3 3 3 3;\n}\n</code></pre><p>}</p>\n<p>结语：这两篇笔记差不多讲完了Less的语法，没有很详细，熟练还是靠多使用和练习。在前端的道路上还有很多东西要学习，just go on！！！</p>\n"},{"title":"canvas的几个知识点","date":"2017-02-20T14:08:14.000Z","_content":"今天重新复习了HTML5，对canvas标签理解加深了一点，有几个知识点想记下来以免忘记。\n\n# 绘制矩形\n\n绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)\n\nx:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）\n\ny:矩形起点纵坐标\n\nwidth:矩形长度\n\nheight:矩形高度\n\n# 绘制圆弧\n\n圆弧context.arc(x, y, radius, starAngle,endAngle, anticlockwise)\n\nx:圆心的x坐标\n\ny:圆心的y坐标\n\nstraAngle:开始角度\n\nendAngle:结束角度\n\nanticlockwise:是否逆时针（true）为逆时针，(false)为顺时针\n\nps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大。\n\n# 路径\n\n这是今天理解的重点。\n\n- 系统默认在绘制第一个路径的开始点为beginPath\n- 如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制\n- 每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分。\n\n# 渐变\n\n1.线性渐变 var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)\n2.线性渐变颜色lg.addColorStop(offset,color)\n\nxstart:渐变开始点x坐标\n\nystart:渐变开始点y坐标\n\nxEnd:渐变结束点x坐标\n\nyEnd:渐变结束点y坐标\n\noffset:设定的颜色离渐变结束点的偏移量(0~1)\n\ncolor:绘制时要使用的颜色","source":"_posts/canvas的几个知识点.md","raw":"---\ntitle: canvas的几个知识点\ndate: 2017-02-20 22:08:14\ntags: HTML5\n---\n今天重新复习了HTML5，对canvas标签理解加深了一点，有几个知识点想记下来以免忘记。\n\n# 绘制矩形\n\n绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)\n\nx:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）\n\ny:矩形起点纵坐标\n\nwidth:矩形长度\n\nheight:矩形高度\n\n# 绘制圆弧\n\n圆弧context.arc(x, y, radius, starAngle,endAngle, anticlockwise)\n\nx:圆心的x坐标\n\ny:圆心的y坐标\n\nstraAngle:开始角度\n\nendAngle:结束角度\n\nanticlockwise:是否逆时针（true）为逆时针，(false)为顺时针\n\nps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大。\n\n# 路径\n\n这是今天理解的重点。\n\n- 系统默认在绘制第一个路径的开始点为beginPath\n- 如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制\n- 每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分。\n\n# 渐变\n\n1.线性渐变 var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)\n2.线性渐变颜色lg.addColorStop(offset,color)\n\nxstart:渐变开始点x坐标\n\nystart:渐变开始点y坐标\n\nxEnd:渐变结束点x坐标\n\nyEnd:渐变结束点y坐标\n\noffset:设定的颜色离渐变结束点的偏移量(0~1)\n\ncolor:绘制时要使用的颜色","slug":"canvas的几个知识点","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dm000blvwvtcewsumx","content":"<p>今天重新复习了HTML5，对canvas标签理解加深了一点，有几个知识点想记下来以免忘记。</p>\n<h1 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h1><p>绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</p>\n<p>x:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）</p>\n<p>y:矩形起点纵坐标</p>\n<p>width:矩形长度</p>\n<p>height:矩形高度</p>\n<h1 id=\"绘制圆弧\"><a href=\"#绘制圆弧\" class=\"headerlink\" title=\"绘制圆弧\"></a>绘制圆弧</h1><p>圆弧context.arc(x, y, radius, starAngle,endAngle, anticlockwise)</p>\n<p>x:圆心的x坐标</p>\n<p>y:圆心的y坐标</p>\n<p>straAngle:开始角度</p>\n<p>endAngle:结束角度</p>\n<p>anticlockwise:是否逆时针（true）为逆时针，(false)为顺时针</p>\n<p>ps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大。</p>\n<h1 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h1><p>这是今天理解的重点。</p>\n<ul>\n<li>系统默认在绘制第一个路径的开始点为beginPath</li>\n<li>如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制</li>\n<li>每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分。</li>\n</ul>\n<h1 id=\"渐变\"><a href=\"#渐变\" class=\"headerlink\" title=\"渐变\"></a>渐变</h1><p>1.线性渐变 var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)<br>2.线性渐变颜色lg.addColorStop(offset,color)</p>\n<p>xstart:渐变开始点x坐标</p>\n<p>ystart:渐变开始点y坐标</p>\n<p>xEnd:渐变结束点x坐标</p>\n<p>yEnd:渐变结束点y坐标</p>\n<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>\n<p>color:绘制时要使用的颜色</p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天重新复习了HTML5，对canvas标签理解加深了一点，有几个知识点想记下来以免忘记。</p>\n<h1 id=\"绘制矩形\"><a href=\"#绘制矩形\" class=\"headerlink\" title=\"绘制矩形\"></a>绘制矩形</h1><p>绘制矩形 context.fillRect(x,y,width,height) strokeRect(x,y,width,height)</p>\n<p>x:矩形起点横坐标（坐标原点为canvas的左上角，当然确切的来说是原始原点，后面写到变形的时候你就懂了，现在暂时不用关系）</p>\n<p>y:矩形起点纵坐标</p>\n<p>width:矩形长度</p>\n<p>height:矩形高度</p>\n<h1 id=\"绘制圆弧\"><a href=\"#绘制圆弧\" class=\"headerlink\" title=\"绘制圆弧\"></a>绘制圆弧</h1><p>圆弧context.arc(x, y, radius, starAngle,endAngle, anticlockwise)</p>\n<p>x:圆心的x坐标</p>\n<p>y:圆心的y坐标</p>\n<p>straAngle:开始角度</p>\n<p>endAngle:结束角度</p>\n<p>anticlockwise:是否逆时针（true）为逆时针，(false)为顺时针</p>\n<p>ps：经过试验证明书本上ture是顺时针，false是逆时针是错误的，而且无论是逆时针还是顺时针，角度都沿着顺时针扩大。</p>\n<h1 id=\"路径\"><a href=\"#路径\" class=\"headerlink\" title=\"路径\"></a>路径</h1><p>这是今天理解的重点。</p>\n<ul>\n<li>系统默认在绘制第一个路径的开始点为beginPath</li>\n<li>如果画完前面的路径没有重新指定beginPath，那么画第其他路径的时候会将前面最近指定的beginPath后的全部路径重新绘制</li>\n<li>每次调用context.fill（）的时候会自动把当次绘制的路径的开始点和结束点相连，接着填充封闭的部分。</li>\n</ul>\n<h1 id=\"渐变\"><a href=\"#渐变\" class=\"headerlink\" title=\"渐变\"></a>渐变</h1><p>1.线性渐变 var lg= context.createLinearGradient(xStart,yStart,xEnd,yEnd)<br>2.线性渐变颜色lg.addColorStop(offset,color)</p>\n<p>xstart:渐变开始点x坐标</p>\n<p>ystart:渐变开始点y坐标</p>\n<p>xEnd:渐变结束点x坐标</p>\n<p>yEnd:渐变结束点y坐标</p>\n<p>offset:设定的颜色离渐变结束点的偏移量(0~1)</p>\n<p>color:绘制时要使用的颜色</p>\n"},{"title":"Hello World","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"date":"2019-03-17T03:04:24.033Z","updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6do000dlvwvs71uxiog","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"jQuery中的常用事件","date":"2017-02-23T13:52:00.000Z","_content":"> 这篇文章介绍了自己在学习jQuery中不太明白的几个事件，以便加深理解。\n\n# $(function(){})\n\n这个函数是`$(document).ready()`的简写，把代码放在里面是为了在页面内容都加载完成后再执行，避免在js中调用了还没加载好的dom而出现错误。但是，有的时候会使页面跳动，很多jQuery插件都是在加载完成后才改变样式的，页面会有跳动或闪动的感觉。\n\n# 事件对象\n\n我们常常需要获取正在执行事件的对象。在程序中使用事件对象非常简单，如下：\n\n    $('element').click(function(event){\n    //event:事件对象\n    })\n    \n当点击'element'元素时候，事件对象就被创建了。这个对象只有事件处理函数能访问。当事件处理函数执行完毕，事件对象就被销毁了。\n\n事件处理程序中event保存着事件对象。而event.tatget属性保存着发生事件的目标元素。通过.target，可以确定DOM中首先接收到事件的元素。而且，我们知道this引用的是处理事件的DOM元素。\n\n**因为事件会冒泡，this不一定是event.target**\n\n# 合成事件\n\n在进行事件捕获时常常需要捕获组合的用户操作，并且以多个函数来响应。\n\n## toggle()\n\n在w3school中可以看到定义如下：\ntoggle() 方法用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。\n该方法也可用于切换被选元素的 hide() 与 show() 方法。\n\n## hover()\n\n.hover(enter,leave)一个模仿悬停事件，当鼠标移动到对象时执行第一个参数函数，当鼠标移出对象时执行第二个参数函数。\n\n# 事件绑定\n\n事件绑定方法主要有四种：bind(),live(),delegate(),on()\n\n## bind()与unbind()\n\n在w3scholl中定义如下：\n`$(selector).bind(event,data,function)`\n\n参数和描述：\nevent：必需。规定添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。\ndata 可选。规定传递到函数的额外数据。\nfunction 必需。规定当事件发生时运行的函数。\n对应的有unbind()：移除事件\n示例：` $(‘#idchoose').unbind(“click”,Function_Name)`\n\n其它的事件绑定函数使用方式都是大同小异的，最重要是理解这四个之间的异同。\n\n - 相同点：\n\n　　 1. 都支持单元素多事件的绑定；空格相隔方式或者大括号替代方式\n　　 2. 均是通过事件冒泡方式，将事件传递到document进行事件的响应\n\n 1. 区别\n\n    1. bind()函数只能针对已经存在的元素进行事件的设置；但是live(),on(),delegate()均支持未来新添加元素的事件设置\n\n 2. bind()函数在jquery1.7版本以前比较受推崇，1.7版本出来之后，官方已经不推荐用bind()，替代函数为on(),这也是1.7版本新添加的函数，同样，可以用来代替live()函数，live()函数在1.9版本已经删除\n\n 3. live()函数和delegate()函数两者类似，但是live()函数在执行速度，灵活性和CSS选择器支持方面较delegate()差些。\n\n 4. .bind()支持Jquery所有版本；live()支持jquery1.8-；delegate()支持jquery1.4.2+；on()支持jquery1.7+；　\n\n\n","source":"_posts/jQuery中的常用事件.md","raw":"---\ntitle: jQuery中的常用事件\ndate: 2017-02-23 21:52:00\ntags: jQuery\n---\n> 这篇文章介绍了自己在学习jQuery中不太明白的几个事件，以便加深理解。\n\n# $(function(){})\n\n这个函数是`$(document).ready()`的简写，把代码放在里面是为了在页面内容都加载完成后再执行，避免在js中调用了还没加载好的dom而出现错误。但是，有的时候会使页面跳动，很多jQuery插件都是在加载完成后才改变样式的，页面会有跳动或闪动的感觉。\n\n# 事件对象\n\n我们常常需要获取正在执行事件的对象。在程序中使用事件对象非常简单，如下：\n\n    $('element').click(function(event){\n    //event:事件对象\n    })\n    \n当点击'element'元素时候，事件对象就被创建了。这个对象只有事件处理函数能访问。当事件处理函数执行完毕，事件对象就被销毁了。\n\n事件处理程序中event保存着事件对象。而event.tatget属性保存着发生事件的目标元素。通过.target，可以确定DOM中首先接收到事件的元素。而且，我们知道this引用的是处理事件的DOM元素。\n\n**因为事件会冒泡，this不一定是event.target**\n\n# 合成事件\n\n在进行事件捕获时常常需要捕获组合的用户操作，并且以多个函数来响应。\n\n## toggle()\n\n在w3school中可以看到定义如下：\ntoggle() 方法用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。\n该方法也可用于切换被选元素的 hide() 与 show() 方法。\n\n## hover()\n\n.hover(enter,leave)一个模仿悬停事件，当鼠标移动到对象时执行第一个参数函数，当鼠标移出对象时执行第二个参数函数。\n\n# 事件绑定\n\n事件绑定方法主要有四种：bind(),live(),delegate(),on()\n\n## bind()与unbind()\n\n在w3scholl中定义如下：\n`$(selector).bind(event,data,function)`\n\n参数和描述：\nevent：必需。规定添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。\ndata 可选。规定传递到函数的额外数据。\nfunction 必需。规定当事件发生时运行的函数。\n对应的有unbind()：移除事件\n示例：` $(‘#idchoose').unbind(“click”,Function_Name)`\n\n其它的事件绑定函数使用方式都是大同小异的，最重要是理解这四个之间的异同。\n\n - 相同点：\n\n　　 1. 都支持单元素多事件的绑定；空格相隔方式或者大括号替代方式\n　　 2. 均是通过事件冒泡方式，将事件传递到document进行事件的响应\n\n 1. 区别\n\n    1. bind()函数只能针对已经存在的元素进行事件的设置；但是live(),on(),delegate()均支持未来新添加元素的事件设置\n\n 2. bind()函数在jquery1.7版本以前比较受推崇，1.7版本出来之后，官方已经不推荐用bind()，替代函数为on(),这也是1.7版本新添加的函数，同样，可以用来代替live()函数，live()函数在1.9版本已经删除\n\n 3. live()函数和delegate()函数两者类似，但是live()函数在执行速度，灵活性和CSS选择器支持方面较delegate()差些。\n\n 4. .bind()支持Jquery所有版本；live()支持jquery1.8-；delegate()支持jquery1.4.2+；on()支持jquery1.7+；　\n\n\n","slug":"jQuery中的常用事件","published":1,"updated":"2019-03-17T03:04:24.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dp000flvwvs8i4oy0l","content":"<blockquote>\n<p>这篇文章介绍了自己在学习jQuery中不太明白的几个事件，以便加深理解。</p>\n</blockquote>\n<h1 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"$(function(){})\"></a>$(function(){})</h1><p>这个函数是<code>$(document).ready()</code>的简写，把代码放在里面是为了在页面内容都加载完成后再执行，避免在js中调用了还没加载好的dom而出现错误。但是，有的时候会使页面跳动，很多jQuery插件都是在加载完成后才改变样式的，页面会有跳动或闪动的感觉。</p>\n<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>我们常常需要获取正在执行事件的对象。在程序中使用事件对象非常简单，如下：</p>\n<pre><code>$(&apos;element&apos;).click(function(event){\n//event:事件对象\n})\n</code></pre><p>当点击’element’元素时候，事件对象就被创建了。这个对象只有事件处理函数能访问。当事件处理函数执行完毕，事件对象就被销毁了。</p>\n<p>事件处理程序中event保存着事件对象。而event.tatget属性保存着发生事件的目标元素。通过.target，可以确定DOM中首先接收到事件的元素。而且，我们知道this引用的是处理事件的DOM元素。</p>\n<p><strong>因为事件会冒泡，this不一定是event.target</strong></p>\n<h1 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h1><p>在进行事件捕获时常常需要捕获组合的用户操作，并且以多个函数来响应。</p>\n<h2 id=\"toggle\"><a href=\"#toggle\" class=\"headerlink\" title=\"toggle()\"></a>toggle()</h2><p>在w3school中可以看到定义如下：<br>toggle() 方法用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。<br>该方法也可用于切换被选元素的 hide() 与 show() 方法。</p>\n<h2 id=\"hover\"><a href=\"#hover\" class=\"headerlink\" title=\"hover()\"></a>hover()</h2><p>.hover(enter,leave)一个模仿悬停事件，当鼠标移动到对象时执行第一个参数函数，当鼠标移出对象时执行第二个参数函数。</p>\n<h1 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h1><p>事件绑定方法主要有四种：bind(),live(),delegate(),on()</p>\n<h2 id=\"bind-与unbind\"><a href=\"#bind-与unbind\" class=\"headerlink\" title=\"bind()与unbind()\"></a>bind()与unbind()</h2><p>在w3scholl中定义如下：<br><code>$(selector).bind(event,data,function)</code></p>\n<p>参数和描述：<br>event：必需。规定添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。<br>data 可选。规定传递到函数的额外数据。<br>function 必需。规定当事件发生时运行的函数。<br>对应的有unbind()：移除事件<br>示例：<code>$(‘#idchoose&#39;).unbind(“click”,Function_Name)</code></p>\n<p>其它的事件绑定函数使用方式都是大同小异的，最重要是理解这四个之间的异同。</p>\n<ul>\n<li>相同点：</li>\n</ul>\n<p>　　 1. 都支持单元素多事件的绑定；空格相隔方式或者大括号替代方式<br>　　 2. 均是通过事件冒泡方式，将事件传递到document进行事件的响应</p>\n<ol>\n<li><p>区别</p>\n<ol>\n<li>bind()函数只能针对已经存在的元素进行事件的设置；但是live(),on(),delegate()均支持未来新添加元素的事件设置</li>\n</ol>\n</li>\n<li><p>bind()函数在jquery1.7版本以前比较受推崇，1.7版本出来之后，官方已经不推荐用bind()，替代函数为on(),这也是1.7版本新添加的函数，同样，可以用来代替live()函数，live()函数在1.9版本已经删除</p>\n</li>\n<li><p>live()函数和delegate()函数两者类似，但是live()函数在执行速度，灵活性和CSS选择器支持方面较delegate()差些。</p>\n</li>\n<li><p>.bind()支持Jquery所有版本；live()支持jquery1.8-；delegate()支持jquery1.4.2+；on()支持jquery1.7+；　</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这篇文章介绍了自己在学习jQuery中不太明白的几个事件，以便加深理解。</p>\n</blockquote>\n<h1 id=\"function\"><a href=\"#function\" class=\"headerlink\" title=\"$(function(){})\"></a>$(function(){})</h1><p>这个函数是<code>$(document).ready()</code>的简写，把代码放在里面是为了在页面内容都加载完成后再执行，避免在js中调用了还没加载好的dom而出现错误。但是，有的时候会使页面跳动，很多jQuery插件都是在加载完成后才改变样式的，页面会有跳动或闪动的感觉。</p>\n<h1 id=\"事件对象\"><a href=\"#事件对象\" class=\"headerlink\" title=\"事件对象\"></a>事件对象</h1><p>我们常常需要获取正在执行事件的对象。在程序中使用事件对象非常简单，如下：</p>\n<pre><code>$(&apos;element&apos;).click(function(event){\n//event:事件对象\n})\n</code></pre><p>当点击’element’元素时候，事件对象就被创建了。这个对象只有事件处理函数能访问。当事件处理函数执行完毕，事件对象就被销毁了。</p>\n<p>事件处理程序中event保存着事件对象。而event.tatget属性保存着发生事件的目标元素。通过.target，可以确定DOM中首先接收到事件的元素。而且，我们知道this引用的是处理事件的DOM元素。</p>\n<p><strong>因为事件会冒泡，this不一定是event.target</strong></p>\n<h1 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h1><p>在进行事件捕获时常常需要捕获组合的用户操作，并且以多个函数来响应。</p>\n<h2 id=\"toggle\"><a href=\"#toggle\" class=\"headerlink\" title=\"toggle()\"></a>toggle()</h2><p>在w3school中可以看到定义如下：<br>toggle() 方法用于绑定两个或多个事件处理器函数，以响应被选元素的轮流的 click 事件。<br>该方法也可用于切换被选元素的 hide() 与 show() 方法。</p>\n<h2 id=\"hover\"><a href=\"#hover\" class=\"headerlink\" title=\"hover()\"></a>hover()</h2><p>.hover(enter,leave)一个模仿悬停事件，当鼠标移动到对象时执行第一个参数函数，当鼠标移出对象时执行第二个参数函数。</p>\n<h1 id=\"事件绑定\"><a href=\"#事件绑定\" class=\"headerlink\" title=\"事件绑定\"></a>事件绑定</h1><p>事件绑定方法主要有四种：bind(),live(),delegate(),on()</p>\n<h2 id=\"bind-与unbind\"><a href=\"#bind-与unbind\" class=\"headerlink\" title=\"bind()与unbind()\"></a>bind()与unbind()</h2><p>在w3scholl中定义如下：<br><code>$(selector).bind(event,data,function)</code></p>\n<p>参数和描述：<br>event：必需。规定添加到元素的一个或多个事件。由空格分隔多个事件。必须是有效的事件。<br>data 可选。规定传递到函数的额外数据。<br>function 必需。规定当事件发生时运行的函数。<br>对应的有unbind()：移除事件<br>示例：<code>$(‘#idchoose&#39;).unbind(“click”,Function_Name)</code></p>\n<p>其它的事件绑定函数使用方式都是大同小异的，最重要是理解这四个之间的异同。</p>\n<ul>\n<li>相同点：</li>\n</ul>\n<p>　　 1. 都支持单元素多事件的绑定；空格相隔方式或者大括号替代方式<br>　　 2. 均是通过事件冒泡方式，将事件传递到document进行事件的响应</p>\n<ol>\n<li><p>区别</p>\n<ol>\n<li>bind()函数只能针对已经存在的元素进行事件的设置；但是live(),on(),delegate()均支持未来新添加元素的事件设置</li>\n</ol>\n</li>\n<li><p>bind()函数在jquery1.7版本以前比较受推崇，1.7版本出来之后，官方已经不推荐用bind()，替代函数为on(),这也是1.7版本新添加的函数，同样，可以用来代替live()函数，live()函数在1.9版本已经删除</p>\n</li>\n<li><p>live()函数和delegate()函数两者类似，但是live()函数在执行速度，灵活性和CSS选择器支持方面较delegate()差些。</p>\n</li>\n<li><p>.bind()支持Jquery所有版本；live()支持jquery1.8-；delegate()支持jquery1.4.2+；on()支持jquery1.7+；　</p>\n</li>\n</ol>\n"},{"title":"jQuery里的Ajax","date":"2017-02-27T14:28:16.000Z","_content":"> 在项目上自己很少有机会用到ajax，但是这是前端与后端发送接收数据必要用到的。在这里写下笔记，毕竟好记性不如烂笔头。\n\n#`$.ajax()`#\n    jQuery里面提供了一个`$.ajax()`的方法封装,通常的例子如下：\n    \n    $.ajax({\n    type: \"post\",\n    url: \"http://...\",\n    data: {\"username\":\"shelia\",\"sex\":\"female\"},\n    success:function(result){\n    ...\n    }\n    });\n    \n接下来是函数的几个主要参数：\n\n - url\n要求为String类型的参数，（默认为当前页地址）发送请求的地址。\n - type \n要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。\n - timeout \n要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。\n - async \n要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\n - cache\n要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\n - data \n要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:\"bar1\",foo2:\"bar2\"}转换为&foo1=bar1&foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[\"bar1\",\"bar2\"]}转换为&foo=bar1&foo=bar2。\n - dataType \n要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：\nxml：返回XML文档，可用JQuery处理。\nhtml：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。\nscript：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。\njson：返回JSON数据。\njsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。\ntext：返回纯文本字符串。\n - complete\n要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。\n          function(XMLHttpRequest, textStatus){\n             this;    //调用本次ajax请求时传递的options参数\n          }\n - success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。\n         (1)由服务器返回，并根据dataType参数进行处理后的数据。\n         (2)描述状态的字符串。\n         function(data, textStatus){\n            //data可能是xmlDoc、jsonObj、html、text等等\n            this;  //调用本次ajax请求时传递的options参数\n         }\n - error\n要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：\n       function(XMLHttpRequest, textStatus, errorThrown){\n          //通常情况下textStatus和errorThrown只有其中一个包含信息\n          this;   //调用本次ajax请求时传递的options参数\n       }\n - contentType\n要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为\"application/x-www-form-urlencoded\"。该默认值适合大多数应用场合。\n\n同样的方法有`$.post`和`$.get()`。这两个方法是针对post和get方式的，两者是将ajax方法简化了，两者的使用方式如下：\n\n- `$.get(url,[data],[callback])`\n- `$.post(url,[data],[callback],[type])`","source":"_posts/jQuery里的Ajax.md","raw":"---\ntitle: jQuery里的Ajax\ndate: 2017-02-27 22:28:16\ntags: Ajax\n---\n> 在项目上自己很少有机会用到ajax，但是这是前端与后端发送接收数据必要用到的。在这里写下笔记，毕竟好记性不如烂笔头。\n\n#`$.ajax()`#\n    jQuery里面提供了一个`$.ajax()`的方法封装,通常的例子如下：\n    \n    $.ajax({\n    type: \"post\",\n    url: \"http://...\",\n    data: {\"username\":\"shelia\",\"sex\":\"female\"},\n    success:function(result){\n    ...\n    }\n    });\n    \n接下来是函数的几个主要参数：\n\n - url\n要求为String类型的参数，（默认为当前页地址）发送请求的地址。\n - type \n要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。\n - timeout \n要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。\n - async \n要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。\n - cache\n要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。\n - data \n要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:\"bar1\",foo2:\"bar2\"}转换为&foo1=bar1&foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[\"bar1\",\"bar2\"]}转换为&foo=bar1&foo=bar2。\n - dataType \n要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：\nxml：返回XML文档，可用JQuery处理。\nhtml：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。\nscript：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。\njson：返回JSON数据。\njsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。\ntext：返回纯文本字符串。\n - complete\n要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。\n          function(XMLHttpRequest, textStatus){\n             this;    //调用本次ajax请求时传递的options参数\n          }\n - success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。\n         (1)由服务器返回，并根据dataType参数进行处理后的数据。\n         (2)描述状态的字符串。\n         function(data, textStatus){\n            //data可能是xmlDoc、jsonObj、html、text等等\n            this;  //调用本次ajax请求时传递的options参数\n         }\n - error\n要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：\n       function(XMLHttpRequest, textStatus, errorThrown){\n          //通常情况下textStatus和errorThrown只有其中一个包含信息\n          this;   //调用本次ajax请求时传递的options参数\n       }\n - contentType\n要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为\"application/x-www-form-urlencoded\"。该默认值适合大多数应用场合。\n\n同样的方法有`$.post`和`$.get()`。这两个方法是针对post和get方式的，两者是将ajax方法简化了，两者的使用方式如下：\n\n- `$.get(url,[data],[callback])`\n- `$.post(url,[data],[callback],[type])`","slug":"jQuery里的Ajax","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dq000hlvwvqlzvr2ky","content":"<blockquote>\n<p>在项目上自己很少有机会用到ajax，但是这是前端与后端发送接收数据必要用到的。在这里写下笔记，毕竟好记性不如烂笔头。</p>\n</blockquote>\n<p>#<code>$.ajax()</code>#<br>    jQuery里面提供了一个<code>$.ajax()</code>的方法封装,通常的例子如下：</p>\n<pre><code>$.ajax({\ntype: &quot;post&quot;,\nurl: &quot;http://...&quot;,\ndata: {&quot;username&quot;:&quot;shelia&quot;,&quot;sex&quot;:&quot;female&quot;},\nsuccess:function(result){\n...\n}\n});\n</code></pre><p>接下来是函数的几个主要参数：</p>\n<ul>\n<li>url<br>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</li>\n<li>type<br>要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</li>\n<li>timeout<br>要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</li>\n<li>async<br>要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</li>\n<li>cache<br>要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</li>\n<li>data<br>要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。</li>\n<li>dataType<br>要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：<br>xml：返回XML文档，可用JQuery处理。<br>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br>json：返回JSON数据。<br>jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br>text：返回纯文本字符串。</li>\n<li>complete<br>要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。<pre><code>function(XMLHttpRequest, textStatus){\n   this;    //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。<pre><code>(1)由服务器返回，并根据dataType参数进行处理后的数据。\n(2)描述状态的字符串。\nfunction(data, textStatus){\n   //data可能是xmlDoc、jsonObj、html、text等等\n   this;  //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>error<br>要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：<pre><code>function(XMLHttpRequest, textStatus, errorThrown){\n   //通常情况下textStatus和errorThrown只有其中一个包含信息\n   this;   //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>contentType<br>要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。</li>\n</ul>\n<p>同样的方法有<code>$.post</code>和<code>$.get()</code>。这两个方法是针对post和get方式的，两者是将ajax方法简化了，两者的使用方式如下：</p>\n<ul>\n<li><code>$.get(url,[data],[callback])</code></li>\n<li><code>$.post(url,[data],[callback],[type])</code></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>在项目上自己很少有机会用到ajax，但是这是前端与后端发送接收数据必要用到的。在这里写下笔记，毕竟好记性不如烂笔头。</p>\n</blockquote>\n<p>#<code>$.ajax()</code>#<br>    jQuery里面提供了一个<code>$.ajax()</code>的方法封装,通常的例子如下：</p>\n<pre><code>$.ajax({\ntype: &quot;post&quot;,\nurl: &quot;http://...&quot;,\ndata: {&quot;username&quot;:&quot;shelia&quot;,&quot;sex&quot;:&quot;female&quot;},\nsuccess:function(result){\n...\n}\n});\n</code></pre><p>接下来是函数的几个主要参数：</p>\n<ul>\n<li>url<br>要求为String类型的参数，（默认为当前页地址）发送请求的地址。</li>\n<li>type<br>要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。</li>\n<li>timeout<br>要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。</li>\n<li>async<br>要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。</li>\n<li>cache<br>要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false），设置为false将不会从浏览器缓存中加载请求信息。</li>\n<li>data<br>要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看　　processData选项。对象必须为key/value格式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。</li>\n<li>dataType<br>要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。可用的类型如下：<br>xml：返回XML文档，可用JQuery处理。<br>html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br>script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br>json：返回JSON数据。<br>jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br>text：返回纯文本字符串。</li>\n<li>complete<br>要求为Function类型的参数，请求完成后调用的回调函数（请求成功或失败时均调用）。参数：XMLHttpRequest对象和一个描述成功请求类型的字符串。<pre><code>function(XMLHttpRequest, textStatus){\n   this;    //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>success：要求为Function类型的参数，请求成功后调用的回调函数，有两个参数。<pre><code>(1)由服务器返回，并根据dataType参数进行处理后的数据。\n(2)描述状态的字符串。\nfunction(data, textStatus){\n   //data可能是xmlDoc、jsonObj、html、text等等\n   this;  //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>error<br>要求为Function类型的参数，请求失败时被调用的函数。该函数有3个参数，即XMLHttpRequest对象、错误信息、捕获的错误对象(可选)。ajax事件函数如下：<pre><code>function(XMLHttpRequest, textStatus, errorThrown){\n   //通常情况下textStatus和errorThrown只有其中一个包含信息\n   this;   //调用本次ajax请求时传递的options参数\n}\n</code></pre></li>\n<li>contentType<br>要求为String类型的参数，当发送信息至服务器时，内容编码类型默认为”application/x-www-form-urlencoded”。该默认值适合大多数应用场合。</li>\n</ul>\n<p>同样的方法有<code>$.post</code>和<code>$.get()</code>。这两个方法是针对post和get方式的，两者是将ajax方法简化了，两者的使用方式如下：</p>\n<ul>\n<li><code>$.get(url,[data],[callback])</code></li>\n<li><code>$.post(url,[data],[callback],[type])</code></li>\n</ul>\n"},{"title":"javascript的this笔记","date":"2017-02-26T13:57:11.000Z","_content":"> 这几天在写贪吃蛇小游戏遇到了`this`到底指的是什么的问题，现将笔记总结如下。(参考MDN文档)\n\n`this`是javascript中的一个关键字，this不能再执行期间赋值，它到底是什么取决于每次的函数调用方式。\n\n# 全局上下文\n\n通常时候当我们没有对函数进行封装，或者直接写一个纯粹的函数，这里的`this`指的就是全局对象，window。\n\n# 函数上下文\n\n在函数内部，`this`的值取决于函数是怎么调用。\n\n## 对象方法中的this\n\n    var o = {\n      prop: 37,\n      f: function() {\n        return this.prop;\n      }\n    };\n    console.log(o.f()); // logs 37\n    \n当o.f()被调用时，this被绑定到o对象。\n\n## 构造函数的this\n\n当一个函数被作为一个构造函数来使用(使用new关键字)，它的this与即将被创建的新对象绑定。\n\n拿刚做的贪吃蛇项目来说。\n\n    var Snake=function(options){\n    \t\tthis.options=$.extend({},defaults,options);\n            this.width=this.options.width;\n            this.height=this.options.height;\n            this.cellWidth=this.options.cellWidth;\n            this.speed=this.options.speed;\n            this.initialLength=this.options.initialLength;\n            this.snakeLength=this.options.initialLength;\n            this.$stage=this.options.stage;\n            this.$eatNum=this.options.eatNum;\n            this.$score=this.options.score;\n            this.$recordTable=this.options.recordTable;\n    \n            this.record='';\n            this.grid=new Array();\n            this.snake=new Array();\n            this.food=new Array();\n            this.die=false;\n            this.direction = 1;//向右  2下 3左  4 上\n            this.nextDirection = '';\n            this.snakeTimer='';\n            this.num=0;\n            this.score=0;\n    \n    \t}\n    \t\n上面是一个构造函数，当我new出一个实例,并调用函数时(函数定义在原型上)：\n`var snake=new Snake({});\nsnake.init();`\n\n之后的函数被调用时指的就是new出来的实例。\n\n但是绑定事件时，this并不是new出来的实例，这是在写demo上遇到的问题。\n\n## DOM事件处理函数中的this\n\n当函数被用作事件处理函数时，它的this指向触发事件的元素。还不太懂这个知识点的时候，我在事件函数中调用原型的属性总是出错，因此解决问题的要点在怎么绑定上下文。\n\n# 绑定上下文\n\n绑定上下文的方法有：bind(),apply(),call()\n\n`add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34`\n使用 call 和 apply 函数的时候要注意，如果传递的 this 值不是一个对象，JavaScript 将会尝试使用内部 ToObject 操作将其转换为对象。\n\n\n    function f(){\n      return this.a;\n    }\n    var g = f.bind({a:\"azerty\"});\n    console.log(g()); // azerty\n    var o = {a:37, f:f, g:g};\n    console.log(o.f(), o.g()); // 37, azerty\n    \n调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。\n\n**jQuery的方法**\n在项目中，我是通过使用jq的`$.proxy(function,this)`来把实例绑定到DOM事件的this的。\n\n","source":"_posts/javascript的this笔记.md","raw":"---\ntitle: javascript的this笔记\ndate: 2017-02-26 21:57:11\ntags: javascript this\n---\n> 这几天在写贪吃蛇小游戏遇到了`this`到底指的是什么的问题，现将笔记总结如下。(参考MDN文档)\n\n`this`是javascript中的一个关键字，this不能再执行期间赋值，它到底是什么取决于每次的函数调用方式。\n\n# 全局上下文\n\n通常时候当我们没有对函数进行封装，或者直接写一个纯粹的函数，这里的`this`指的就是全局对象，window。\n\n# 函数上下文\n\n在函数内部，`this`的值取决于函数是怎么调用。\n\n## 对象方法中的this\n\n    var o = {\n      prop: 37,\n      f: function() {\n        return this.prop;\n      }\n    };\n    console.log(o.f()); // logs 37\n    \n当o.f()被调用时，this被绑定到o对象。\n\n## 构造函数的this\n\n当一个函数被作为一个构造函数来使用(使用new关键字)，它的this与即将被创建的新对象绑定。\n\n拿刚做的贪吃蛇项目来说。\n\n    var Snake=function(options){\n    \t\tthis.options=$.extend({},defaults,options);\n            this.width=this.options.width;\n            this.height=this.options.height;\n            this.cellWidth=this.options.cellWidth;\n            this.speed=this.options.speed;\n            this.initialLength=this.options.initialLength;\n            this.snakeLength=this.options.initialLength;\n            this.$stage=this.options.stage;\n            this.$eatNum=this.options.eatNum;\n            this.$score=this.options.score;\n            this.$recordTable=this.options.recordTable;\n    \n            this.record='';\n            this.grid=new Array();\n            this.snake=new Array();\n            this.food=new Array();\n            this.die=false;\n            this.direction = 1;//向右  2下 3左  4 上\n            this.nextDirection = '';\n            this.snakeTimer='';\n            this.num=0;\n            this.score=0;\n    \n    \t}\n    \t\n上面是一个构造函数，当我new出一个实例,并调用函数时(函数定义在原型上)：\n`var snake=new Snake({});\nsnake.init();`\n\n之后的函数被调用时指的就是new出来的实例。\n\n但是绑定事件时，this并不是new出来的实例，这是在写demo上遇到的问题。\n\n## DOM事件处理函数中的this\n\n当函数被用作事件处理函数时，它的this指向触发事件的元素。还不太懂这个知识点的时候，我在事件函数中调用原型的属性总是出错，因此解决问题的要点在怎么绑定上下文。\n\n# 绑定上下文\n\n绑定上下文的方法有：bind(),apply(),call()\n\n`add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34`\n使用 call 和 apply 函数的时候要注意，如果传递的 this 值不是一个对象，JavaScript 将会尝试使用内部 ToObject 操作将其转换为对象。\n\n\n    function f(){\n      return this.a;\n    }\n    var g = f.bind({a:\"azerty\"});\n    console.log(g()); // azerty\n    var o = {a:37, f:f, g:g};\n    console.log(o.f(), o.g()); // 37, azerty\n    \n调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。\n\n**jQuery的方法**\n在项目中，我是通过使用jq的`$.proxy(function,this)`来把实例绑定到DOM事件的this的。\n\n","slug":"javascript的this笔记","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dr000jlvwvvnqfumt5","content":"<blockquote>\n<p>这几天在写贪吃蛇小游戏遇到了<code>this</code>到底指的是什么的问题，现将笔记总结如下。(参考MDN文档)</p>\n</blockquote>\n<p><code>this</code>是javascript中的一个关键字，this不能再执行期间赋值，它到底是什么取决于每次的函数调用方式。</p>\n<h1 id=\"全局上下文\"><a href=\"#全局上下文\" class=\"headerlink\" title=\"全局上下文\"></a>全局上下文</h1><p>通常时候当我们没有对函数进行封装，或者直接写一个纯粹的函数，这里的<code>this</code>指的就是全局对象，window。</p>\n<h1 id=\"函数上下文\"><a href=\"#函数上下文\" class=\"headerlink\" title=\"函数上下文\"></a>函数上下文</h1><p>在函数内部，<code>this</code>的值取决于函数是怎么调用。</p>\n<h2 id=\"对象方法中的this\"><a href=\"#对象方法中的this\" class=\"headerlink\" title=\"对象方法中的this\"></a>对象方法中的this</h2><pre><code>var o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\nconsole.log(o.f()); // logs 37\n</code></pre><p>当o.f()被调用时，this被绑定到o对象。</p>\n<h2 id=\"构造函数的this\"><a href=\"#构造函数的this\" class=\"headerlink\" title=\"构造函数的this\"></a>构造函数的this</h2><p>当一个函数被作为一个构造函数来使用(使用new关键字)，它的this与即将被创建的新对象绑定。</p>\n<p>拿刚做的贪吃蛇项目来说。</p>\n<pre><code>var Snake=function(options){\n        this.options=$.extend({},defaults,options);\n        this.width=this.options.width;\n        this.height=this.options.height;\n        this.cellWidth=this.options.cellWidth;\n        this.speed=this.options.speed;\n        this.initialLength=this.options.initialLength;\n        this.snakeLength=this.options.initialLength;\n        this.$stage=this.options.stage;\n        this.$eatNum=this.options.eatNum;\n        this.$score=this.options.score;\n        this.$recordTable=this.options.recordTable;\n\n        this.record=&apos;&apos;;\n        this.grid=new Array();\n        this.snake=new Array();\n        this.food=new Array();\n        this.die=false;\n        this.direction = 1;//向右  2下 3左  4 上\n        this.nextDirection = &apos;&apos;;\n        this.snakeTimer=&apos;&apos;;\n        this.num=0;\n        this.score=0;\n\n    }\n</code></pre><p>上面是一个构造函数，当我new出一个实例,并调用函数时(函数定义在原型上)：<br><code>var snake=new Snake({});\nsnake.init();</code></p>\n<p>之后的函数被调用时指的就是new出来的实例。</p>\n<p>但是绑定事件时，this并不是new出来的实例，这是在写demo上遇到的问题。</p>\n<h2 id=\"DOM事件处理函数中的this\"><a href=\"#DOM事件处理函数中的this\" class=\"headerlink\" title=\"DOM事件处理函数中的this\"></a>DOM事件处理函数中的this</h2><p>当函数被用作事件处理函数时，它的this指向触发事件的元素。还不太懂这个知识点的时候，我在事件函数中调用原型的属性总是出错，因此解决问题的要点在怎么绑定上下文。</p>\n<h1 id=\"绑定上下文\"><a href=\"#绑定上下文\" class=\"headerlink\" title=\"绑定上下文\"></a>绑定上下文</h1><p>绑定上下文的方法有：bind(),apply(),call()</p>\n<p><code>add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</code><br>使用 call 和 apply 函数的时候要注意，如果传递的 this 值不是一个对象，JavaScript 将会尝试使用内部 ToObject 操作将其转换为对象。</p>\n<pre><code>function f(){\n  return this.a;\n}\nvar g = f.bind({a:&quot;azerty&quot;});\nconsole.log(g()); // azerty\nvar o = {a:37, f:f, g:g};\nconsole.log(o.f(), o.g()); // 37, azerty\n</code></pre><p>调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。</p>\n<p><strong>jQuery的方法</strong><br>在项目中，我是通过使用jq的<code>$.proxy(function,this)</code>来把实例绑定到DOM事件的this的。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>这几天在写贪吃蛇小游戏遇到了<code>this</code>到底指的是什么的问题，现将笔记总结如下。(参考MDN文档)</p>\n</blockquote>\n<p><code>this</code>是javascript中的一个关键字，this不能再执行期间赋值，它到底是什么取决于每次的函数调用方式。</p>\n<h1 id=\"全局上下文\"><a href=\"#全局上下文\" class=\"headerlink\" title=\"全局上下文\"></a>全局上下文</h1><p>通常时候当我们没有对函数进行封装，或者直接写一个纯粹的函数，这里的<code>this</code>指的就是全局对象，window。</p>\n<h1 id=\"函数上下文\"><a href=\"#函数上下文\" class=\"headerlink\" title=\"函数上下文\"></a>函数上下文</h1><p>在函数内部，<code>this</code>的值取决于函数是怎么调用。</p>\n<h2 id=\"对象方法中的this\"><a href=\"#对象方法中的this\" class=\"headerlink\" title=\"对象方法中的this\"></a>对象方法中的this</h2><pre><code>var o = {\n  prop: 37,\n  f: function() {\n    return this.prop;\n  }\n};\nconsole.log(o.f()); // logs 37\n</code></pre><p>当o.f()被调用时，this被绑定到o对象。</p>\n<h2 id=\"构造函数的this\"><a href=\"#构造函数的this\" class=\"headerlink\" title=\"构造函数的this\"></a>构造函数的this</h2><p>当一个函数被作为一个构造函数来使用(使用new关键字)，它的this与即将被创建的新对象绑定。</p>\n<p>拿刚做的贪吃蛇项目来说。</p>\n<pre><code>var Snake=function(options){\n        this.options=$.extend({},defaults,options);\n        this.width=this.options.width;\n        this.height=this.options.height;\n        this.cellWidth=this.options.cellWidth;\n        this.speed=this.options.speed;\n        this.initialLength=this.options.initialLength;\n        this.snakeLength=this.options.initialLength;\n        this.$stage=this.options.stage;\n        this.$eatNum=this.options.eatNum;\n        this.$score=this.options.score;\n        this.$recordTable=this.options.recordTable;\n\n        this.record=&apos;&apos;;\n        this.grid=new Array();\n        this.snake=new Array();\n        this.food=new Array();\n        this.die=false;\n        this.direction = 1;//向右  2下 3左  4 上\n        this.nextDirection = &apos;&apos;;\n        this.snakeTimer=&apos;&apos;;\n        this.num=0;\n        this.score=0;\n\n    }\n</code></pre><p>上面是一个构造函数，当我new出一个实例,并调用函数时(函数定义在原型上)：<br><code>var snake=new Snake({});\nsnake.init();</code></p>\n<p>之后的函数被调用时指的就是new出来的实例。</p>\n<p>但是绑定事件时，this并不是new出来的实例，这是在写demo上遇到的问题。</p>\n<h2 id=\"DOM事件处理函数中的this\"><a href=\"#DOM事件处理函数中的this\" class=\"headerlink\" title=\"DOM事件处理函数中的this\"></a>DOM事件处理函数中的this</h2><p>当函数被用作事件处理函数时，它的this指向触发事件的元素。还不太懂这个知识点的时候，我在事件函数中调用原型的属性总是出错，因此解决问题的要点在怎么绑定上下文。</p>\n<h1 id=\"绑定上下文\"><a href=\"#绑定上下文\" class=\"headerlink\" title=\"绑定上下文\"></a>绑定上下文</h1><p>绑定上下文的方法有：bind(),apply(),call()</p>\n<p><code>add.call(o, 5, 7); // 1 + 3 + 5 + 7 = 16\nadd.apply(o, [10, 20]); // 1 + 3 + 10 + 20 = 34</code><br>使用 call 和 apply 函数的时候要注意，如果传递的 this 值不是一个对象，JavaScript 将会尝试使用内部 ToObject 操作将其转换为对象。</p>\n<pre><code>function f(){\n  return this.a;\n}\nvar g = f.bind({a:&quot;azerty&quot;});\nconsole.log(g()); // azerty\nvar o = {a:37, f:f, g:g};\nconsole.log(o.f(), o.g()); // 37, azerty\n</code></pre><p>调用f.bind(someObject)会创建一个与f具有相同函数体和作用域的函数，但是在这个新函数中，this将永久地被绑定到了bind的第一个参数，无论这个函数是如何被调用的。</p>\n<p><strong>jQuery的方法</strong><br>在项目中，我是通过使用jq的<code>$.proxy(function,this)</code>来把实例绑定到DOM事件的this的。</p>\n"},{"title":"js事件循环机制","date":"2019-04-13T16:00:00.000Z","_content":"Javascript是一个单线程的脚本语言，所谓的单线程是代码的执行是按顺序执行的，前面的代码执行后才能执行后面的代码。这样的同步执行在实际使用中很不方便，如果有些代码执行了大量运算，会导致后续代码难以执行，甚至网页出现假死。\b异步的出现，解决了这个问题。通常异步操作会注册一个回调函数，当异步操作完成后，会通过回调函数通知我们，这样我们就不用一直去轮询操作是否完成。但是如果程序在执行其他事件函数，异步完成了也需要等待程序空 下来才能执行。\n\n## macrotask和microtask\n在js中，浏览器的任务分为两种，一种是宏任务(macrotask)，另一种是微任务(microtask)。\n\n宏任务通常是普通的js代码，通常是以下几种 ：\n* script整体代码\n* 浏览器事件\n* 定时事件(setTimeout setInterval setImmediate)\n*  I/O操作\n* ui渲染\n\n微任务主要是一下的代码操作：\n* Promise\n* Object.observe(已弃用)\n* MutaitionObserver\n\n在学习vue的源代码中，在vue.$nextTick()中，优先使用了微任务的操作推入一个timerFunc,在当前栈执行完毕以后\b执行nexttick传入的function。\n\n## Event Loop，\b执行栈，任务队列\n\n执行栈，当一个函数调用时就会形成一个调用帧并压入栈中，当函数返回时，则帧弹栈。\n\n任务队列，每一个任务都包含一个处理该任务的函数，当任务产生时，任务及其处理函数会被作为一个整体推入任务队列中。任务队列按照先进先出的顺序执行。当任务队列中的任务需要被处理时，\b将会被移出队列，调用其处理函数，这是形成一个调用帧，并压入执行栈。当执行栈唯恐时，会接着处理任务队列中的接下来一个任务。\n\n事件循环值的是主线程从任务队列中循环读取事件并\b调用执行。\n\n在事件循环模型中，首先从task queue中选择最先进入的task执行，每执行完一个task都会检查microtask queue是否为空，若不为空则执行完microtsk queue中的所有任务。然后再选择task queue中最先进入的task执行，以此循环。\n\n![事件模型](../uploads/eventloop.jpeg)\n\n## async和await\nasync函数是promise的一个语法糖，简单理解为：await中的语句相当于在promise.resolve()中；await后面的语句相当于.then中的语句","source":"_posts/js事件循环机制.md","raw":"---\ntitle: js事件循环机制\ndate: 2019-04-14\ntags: microtask macrotask\n---\nJavascript是一个单线程的脚本语言，所谓的单线程是代码的执行是按顺序执行的，前面的代码执行后才能执行后面的代码。这样的同步执行在实际使用中很不方便，如果有些代码执行了大量运算，会导致后续代码难以执行，甚至网页出现假死。\b异步的出现，解决了这个问题。通常异步操作会注册一个回调函数，当异步操作完成后，会通过回调函数通知我们，这样我们就不用一直去轮询操作是否完成。但是如果程序在执行其他事件函数，异步完成了也需要等待程序空 下来才能执行。\n\n## macrotask和microtask\n在js中，浏览器的任务分为两种，一种是宏任务(macrotask)，另一种是微任务(microtask)。\n\n宏任务通常是普通的js代码，通常是以下几种 ：\n* script整体代码\n* 浏览器事件\n* 定时事件(setTimeout setInterval setImmediate)\n*  I/O操作\n* ui渲染\n\n微任务主要是一下的代码操作：\n* Promise\n* Object.observe(已弃用)\n* MutaitionObserver\n\n在学习vue的源代码中，在vue.$nextTick()中，优先使用了微任务的操作推入一个timerFunc,在当前栈执行完毕以后\b执行nexttick传入的function。\n\n## Event Loop，\b执行栈，任务队列\n\n执行栈，当一个函数调用时就会形成一个调用帧并压入栈中，当函数返回时，则帧弹栈。\n\n任务队列，每一个任务都包含一个处理该任务的函数，当任务产生时，任务及其处理函数会被作为一个整体推入任务队列中。任务队列按照先进先出的顺序执行。当任务队列中的任务需要被处理时，\b将会被移出队列，调用其处理函数，这是形成一个调用帧，并压入执行栈。当执行栈唯恐时，会接着处理任务队列中的接下来一个任务。\n\n事件循环值的是主线程从任务队列中循环读取事件并\b调用执行。\n\n在事件循环模型中，首先从task queue中选择最先进入的task执行，每执行完一个task都会检查microtask queue是否为空，若不为空则执行完microtsk queue中的所有任务。然后再选择task queue中最先进入的task执行，以此循环。\n\n![事件模型](../uploads/eventloop.jpeg)\n\n## async和await\nasync函数是promise的一个语法糖，简单理解为：await中的语句相当于在promise.resolve()中；await后面的语句相当于.then中的语句","slug":"js事件循环机制","published":1,"updated":"2019-04-14T16:41:44.778Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dr000llvwv3iiblr7q","content":"<p>Javascript是一个单线程的脚本语言，所谓的单线程是代码的执行是按顺序执行的，前面的代码执行后才能执行后面的代码。这样的同步执行在实际使用中很不方便，如果有些代码执行了大量运算，会导致后续代码难以执行，甚至网页出现假死。\b异步的出现，解决了这个问题。通常异步操作会注册一个回调函数，当异步操作完成后，会通过回调函数通知我们，这样我们就不用一直去轮询操作是否完成。但是如果程序在执行其他事件函数，异步完成了也需要等待程序空 下来才能执行。</p>\n<h2 id=\"macrotask和microtask\"><a href=\"#macrotask和microtask\" class=\"headerlink\" title=\"macrotask和microtask\"></a>macrotask和microtask</h2><p>在js中，浏览器的任务分为两种，一种是宏任务(macrotask)，另一种是微任务(microtask)。</p>\n<p>宏任务通常是普通的js代码，通常是以下几种 ：</p>\n<ul>\n<li>script整体代码</li>\n<li>浏览器事件</li>\n<li>定时事件(setTimeout setInterval setImmediate)</li>\n<li>I/O操作</li>\n<li>ui渲染</li>\n</ul>\n<p>微任务主要是一下的代码操作：</p>\n<ul>\n<li>Promise</li>\n<li>Object.observe(已弃用)</li>\n<li>MutaitionObserver</li>\n</ul>\n<p>在学习vue的源代码中，在vue.$nextTick()中，优先使用了微任务的操作推入一个timerFunc,在当前栈执行完毕以后\b执行nexttick传入的function。</p>\n<h2 id=\"Event-Loop，执行栈，任务队列\"><a href=\"#Event-Loop，执行栈，任务队列\" class=\"headerlink\" title=\"Event Loop，\b执行栈，任务队列\"></a>Event Loop，\b执行栈，任务队列</h2><p>执行栈，当一个函数调用时就会形成一个调用帧并压入栈中，当函数返回时，则帧弹栈。</p>\n<p>任务队列，每一个任务都包含一个处理该任务的函数，当任务产生时，任务及其处理函数会被作为一个整体推入任务队列中。任务队列按照先进先出的顺序执行。当任务队列中的任务需要被处理时，\b将会被移出队列，调用其处理函数，这是形成一个调用帧，并压入执行栈。当执行栈唯恐时，会接着处理任务队列中的接下来一个任务。</p>\n<p>事件循环值的是主线程从任务队列中循环读取事件并\b调用执行。</p>\n<p>在事件循环模型中，首先从task queue中选择最先进入的task执行，每执行完一个task都会检查microtask queue是否为空，若不为空则执行完microtsk queue中的所有任务。然后再选择task queue中最先进入的task执行，以此循环。</p>\n<p><img src=\"../uploads/eventloop.jpeg\" alt=\"事件模型\"></p>\n<h2 id=\"async和await\"><a href=\"#async和await\" class=\"headerlink\" title=\"async和await\"></a>async和await</h2><p>async函数是promise的一个语法糖，简单理解为：await中的语句相当于在promise.resolve()中；await后面的语句相当于.then中的语句</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript是一个单线程的脚本语言，所谓的单线程是代码的执行是按顺序执行的，前面的代码执行后才能执行后面的代码。这样的同步执行在实际使用中很不方便，如果有些代码执行了大量运算，会导致后续代码难以执行，甚至网页出现假死。\b异步的出现，解决了这个问题。通常异步操作会注册一个回调函数，当异步操作完成后，会通过回调函数通知我们，这样我们就不用一直去轮询操作是否完成。但是如果程序在执行其他事件函数，异步完成了也需要等待程序空 下来才能执行。</p>\n<h2 id=\"macrotask和microtask\"><a href=\"#macrotask和microtask\" class=\"headerlink\" title=\"macrotask和microtask\"></a>macrotask和microtask</h2><p>在js中，浏览器的任务分为两种，一种是宏任务(macrotask)，另一种是微任务(microtask)。</p>\n<p>宏任务通常是普通的js代码，通常是以下几种 ：</p>\n<ul>\n<li>script整体代码</li>\n<li>浏览器事件</li>\n<li>定时事件(setTimeout setInterval setImmediate)</li>\n<li>I/O操作</li>\n<li>ui渲染</li>\n</ul>\n<p>微任务主要是一下的代码操作：</p>\n<ul>\n<li>Promise</li>\n<li>Object.observe(已弃用)</li>\n<li>MutaitionObserver</li>\n</ul>\n<p>在学习vue的源代码中，在vue.$nextTick()中，优先使用了微任务的操作推入一个timerFunc,在当前栈执行完毕以后\b执行nexttick传入的function。</p>\n<h2 id=\"Event-Loop，执行栈，任务队列\"><a href=\"#Event-Loop，执行栈，任务队列\" class=\"headerlink\" title=\"Event Loop，\b执行栈，任务队列\"></a>Event Loop，\b执行栈，任务队列</h2><p>执行栈，当一个函数调用时就会形成一个调用帧并压入栈中，当函数返回时，则帧弹栈。</p>\n<p>任务队列，每一个任务都包含一个处理该任务的函数，当任务产生时，任务及其处理函数会被作为一个整体推入任务队列中。任务队列按照先进先出的顺序执行。当任务队列中的任务需要被处理时，\b将会被移出队列，调用其处理函数，这是形成一个调用帧，并压入执行栈。当执行栈唯恐时，会接着处理任务队列中的接下来一个任务。</p>\n<p>事件循环值的是主线程从任务队列中循环读取事件并\b调用执行。</p>\n<p>在事件循环模型中，首先从task queue中选择最先进入的task执行，每执行完一个task都会检查microtask queue是否为空，若不为空则执行完microtsk queue中的所有任务。然后再选择task queue中最先进入的task执行，以此循环。</p>\n<p><img src=\"../uploads/eventloop.jpeg\" alt=\"事件模型\"></p>\n<h2 id=\"async和await\"><a href=\"#async和await\" class=\"headerlink\" title=\"async和await\"></a>async和await</h2><p>async函数是promise的一个语法糖，简单理解为：await中的语句相当于在promise.resolve()中；await后面的语句相当于.then中的语句</p>\n"},{"title":"js中`!!`的小知识点","date":"2017-02-13T16:05:03.000Z","_content":"今天在写网页音乐播放器的时候发现一个很有意思的小知识点。\n\n在从API获取歌词的时候，我要判断通过服务器返回的数据歌词是否为空，通常我的做法会是这样写`if(lyr.lyric!=='undefined'）`，现在提供一种双重否定的写法。\n示例代码如下：\n\n    function getlyric(){\n\tvar Sid=$('audio').attr('sid');\n\tvar Ssid=$('audio').attr('ssid');\n\t$.post('http://api.jirengu.com/fm/getLyric.php',{ssid:Ssid,sid:Sid})\n\t.done(function(lyr){\n\t\t//解析歌词\n\t\tconsole.log(lyr); \n\t\tvar lyr=JSON.parse(lyr);\n\t\t//!!一般用来将后面的表达式强制转换为布尔类型的数据（boolean）\n\t\tif(!!lyr.lyric){\n\t\t\t$('.music-lyrics .lyric').empty();\n\t\t\tvar line=lyr.lyric.split('\\n');\n\t\t\tvar timeReg=/\\[\\d{2}:\\d{2}.\\d{2}\\]/g;//时间正则\n\t\t\tvar result=[];\n\t\t\t//result是一个时间（秒）+歌词数组\n\t\t\tif(line!=\"\"){\n\t\t\t\tfor(var i in line){\n\t\t\t\t\tvar time=line[i].match(timeReg);//每组匹配时间，得到时间数组\n\t\t\t\t\tif(!time) continue;\n\t\t\t\t\tvar value=line[i].replace(timeReg,\"\");//纯歌词\n\t\t\t\t\tfor(var j in time){\n\t\t\t\t\t\tvar t=time[j].slice(1,-1).split(':');\n\t\t\t\t\t\tvar timeArr=parseInt(t[0],10)*60+parseFloat(t[1]);\n\t\t\t\t\t\tresult.push([timeArr,value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n`!!lyr.lyric`就相当于`lyr.lyric=lyr.lyric||false`。当值为undifined和null时，用一个感叹号返回的都是true,用两个感叹号返回的就是false。所以两个感叹号的作用就在于，如果明确设置了变量的值（非null/undifined/0/\"\"等值),结果就会根据变量的实际值来返回，如果没有设置，结果就会返回false。 \n\n","source":"_posts/js双重否定的小知识点.md","raw":"---\ntitle: js中`!!`的小知识点\ndate: 2017-02-14 00:05:03\ntags: javascript\n---\n今天在写网页音乐播放器的时候发现一个很有意思的小知识点。\n\n在从API获取歌词的时候，我要判断通过服务器返回的数据歌词是否为空，通常我的做法会是这样写`if(lyr.lyric!=='undefined'）`，现在提供一种双重否定的写法。\n示例代码如下：\n\n    function getlyric(){\n\tvar Sid=$('audio').attr('sid');\n\tvar Ssid=$('audio').attr('ssid');\n\t$.post('http://api.jirengu.com/fm/getLyric.php',{ssid:Ssid,sid:Sid})\n\t.done(function(lyr){\n\t\t//解析歌词\n\t\tconsole.log(lyr); \n\t\tvar lyr=JSON.parse(lyr);\n\t\t//!!一般用来将后面的表达式强制转换为布尔类型的数据（boolean）\n\t\tif(!!lyr.lyric){\n\t\t\t$('.music-lyrics .lyric').empty();\n\t\t\tvar line=lyr.lyric.split('\\n');\n\t\t\tvar timeReg=/\\[\\d{2}:\\d{2}.\\d{2}\\]/g;//时间正则\n\t\t\tvar result=[];\n\t\t\t//result是一个时间（秒）+歌词数组\n\t\t\tif(line!=\"\"){\n\t\t\t\tfor(var i in line){\n\t\t\t\t\tvar time=line[i].match(timeReg);//每组匹配时间，得到时间数组\n\t\t\t\t\tif(!time) continue;\n\t\t\t\t\tvar value=line[i].replace(timeReg,\"\");//纯歌词\n\t\t\t\t\tfor(var j in time){\n\t\t\t\t\t\tvar t=time[j].slice(1,-1).split(':');\n\t\t\t\t\t\tvar timeArr=parseInt(t[0],10)*60+parseFloat(t[1]);\n\t\t\t\t\t\tresult.push([timeArr,value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n`!!lyr.lyric`就相当于`lyr.lyric=lyr.lyric||false`。当值为undifined和null时，用一个感叹号返回的都是true,用两个感叹号返回的就是false。所以两个感叹号的作用就在于，如果明确设置了变量的值（非null/undifined/0/\"\"等值),结果就会根据变量的实际值来返回，如果没有设置，结果就会返回false。 \n\n","slug":"js双重否定的小知识点","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6ds000nlvwvas3jnn5i","content":"<p>今天在写网页音乐播放器的时候发现一个很有意思的小知识点。</p>\n<p>在从API获取歌词的时候，我要判断通过服务器返回的数据歌词是否为空，通常我的做法会是这样写<code>if(lyr.lyric!==&#39;undefined&#39;）</code>，现在提供一种双重否定的写法。<br>示例代码如下：</p>\n<pre><code>function getlyric(){\nvar Sid=$(&apos;audio&apos;).attr(&apos;sid&apos;);\nvar Ssid=$(&apos;audio&apos;).attr(&apos;ssid&apos;);\n$.post(&apos;http://api.jirengu.com/fm/getLyric.php&apos;,{ssid:Ssid,sid:Sid})\n.done(function(lyr){\n    //解析歌词\n    console.log(lyr); \n    var lyr=JSON.parse(lyr);\n    //!!一般用来将后面的表达式强制转换为布尔类型的数据（boolean）\n    if(!!lyr.lyric){\n        $(&apos;.music-lyrics .lyric&apos;).empty();\n        var line=lyr.lyric.split(&apos;\\n&apos;);\n        var timeReg=/\\[\\d{2}:\\d{2}.\\d{2}\\]/g;//时间正则\n        var result=[];\n        //result是一个时间（秒）+歌词数组\n        if(line!=&quot;&quot;){\n            for(var i in line){\n                var time=line[i].match(timeReg);//每组匹配时间，得到时间数组\n                if(!time) continue;\n                var value=line[i].replace(timeReg,&quot;&quot;);//纯歌词\n                for(var j in time){\n                    var t=time[j].slice(1,-1).split(&apos;:&apos;);\n                    var timeArr=parseInt(t[0],10)*60+parseFloat(t[1]);\n                    result.push([timeArr,value]);\n                }\n            }\n        }\n</code></pre><p><code>!!lyr.lyric</code>就相当于<code>lyr.lyric=lyr.lyric||false</code>。当值为undifined和null时，用一个感叹号返回的都是true,用两个感叹号返回的就是false。所以两个感叹号的作用就在于，如果明确设置了变量的值（非null/undifined/0/“”等值),结果就会根据变量的实际值来返回，如果没有设置，结果就会返回false。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天在写网页音乐播放器的时候发现一个很有意思的小知识点。</p>\n<p>在从API获取歌词的时候，我要判断通过服务器返回的数据歌词是否为空，通常我的做法会是这样写<code>if(lyr.lyric!==&#39;undefined&#39;）</code>，现在提供一种双重否定的写法。<br>示例代码如下：</p>\n<pre><code>function getlyric(){\nvar Sid=$(&apos;audio&apos;).attr(&apos;sid&apos;);\nvar Ssid=$(&apos;audio&apos;).attr(&apos;ssid&apos;);\n$.post(&apos;http://api.jirengu.com/fm/getLyric.php&apos;,{ssid:Ssid,sid:Sid})\n.done(function(lyr){\n    //解析歌词\n    console.log(lyr); \n    var lyr=JSON.parse(lyr);\n    //!!一般用来将后面的表达式强制转换为布尔类型的数据（boolean）\n    if(!!lyr.lyric){\n        $(&apos;.music-lyrics .lyric&apos;).empty();\n        var line=lyr.lyric.split(&apos;\\n&apos;);\n        var timeReg=/\\[\\d{2}:\\d{2}.\\d{2}\\]/g;//时间正则\n        var result=[];\n        //result是一个时间（秒）+歌词数组\n        if(line!=&quot;&quot;){\n            for(var i in line){\n                var time=line[i].match(timeReg);//每组匹配时间，得到时间数组\n                if(!time) continue;\n                var value=line[i].replace(timeReg,&quot;&quot;);//纯歌词\n                for(var j in time){\n                    var t=time[j].slice(1,-1).split(&apos;:&apos;);\n                    var timeArr=parseInt(t[0],10)*60+parseFloat(t[1]);\n                    result.push([timeArr,value]);\n                }\n            }\n        }\n</code></pre><p><code>!!lyr.lyric</code>就相当于<code>lyr.lyric=lyr.lyric||false</code>。当值为undifined和null时，用一个感叹号返回的都是true,用两个感叹号返回的就是false。所以两个感叹号的作用就在于，如果明确设置了变量的值（非null/undifined/0/“”等值),结果就会根据变量的实际值来返回，如果没有设置，结果就会返回false。 </p>\n"},{"title":"php圆形头像生成与合并","date":"2017-05-09T07:01:29.000Z","_content":"> 实习中的一个项目，用到将两张图片合并成一张，使用了PHP的图像函数，发现挺好处理的。\n\n#圆形头像的生成#\n\n在项目中需要获取用户头像并制作成固定大小的圆形头像，如果用css是很容易解决的，`border-radius`设置为尺寸的50%,但是不能用css，因为要求返回的是一张图片而不是页面，这确实让我困惑了很久。\n说一说代码的实现：\n \n\n 1. 明确头像要求的尺寸，假设为`new_size`，然后获取原始头像的url\n\n   ` $url = 'xxxx';`\n    `$new_size = 'xxx';`\n    `$oldimg = imagecreatefromjpeg($url);`\n    `size = [imagesx($oldimg),imagesy($oldimg)];\n    $newimg = imagecreatetruecolor($new_size);\n    imagecopyresized($newimg,$oldimg,0,0,0,0,$new_size,$new_size,size[1],size[2]);`\n   ` //圆形透明图像`\n   ` imagealphablending($newpic,false); ` \n    `$transparent = imagecolorallocatealpha($newimg, 0, 0, 0, 127);`  \n   ` $r=$new_size/2; ` \n    `for($x=0;$x<$new_size;$x++) {`\n       ` for($y=0;$y<$new_size;$y++){  `\n           ` $c = imagecolorat($src,$x,$y);`  \n          `  $_x = $x - $r;  `\n           ` $_y = $y - $r;  `\n          `  if((($_x*$_x) + ($_y*$_y)) < ($r*$r)){  `\n               `  imagesetpixel($newimg,$x,$y,$c);  `\n           ` }else{  `\n               ` imagesetpixel($newimg,$x,$y,$transparent); ` \n           `}  `\n                `}  `\n           ` imagesavealpha($newimg, true);  `\n           ` header('Content-Type: image/png');  `\n           ` imagepng($newpic);  `\n          `  imagedestroy($newpic);  `\n           ` imagedestroy($old);  `\n        `} `\n\n注意：图片最后保存为png格式，之前尝试过保存为jpeg，然后透明部分就变成了黑色，估计应该是png能保留透明通道的原因。\n\n#合并图片#\n合并图片用的是php的`imagecopymerge()`函数，接上代码：\n\n    $bgimgurl = 'xxx';\n$bgimg = imagecreatefromjpeg($bgimgurl);    $src_size= [imagesx($bgimg),imagesy($bgimg)];\n    imagecopymerge($bgimg, $newimg, $dst_x , $dst_y , $src_x , $src_y , $src_w , $src_h , $pct);\n    \n一些参数的释义如下：\ndst_x\t目标图像开始 x 坐标\ndst_y\t目标图像开始 y 坐标，x,y同为 0 则从左上角开始\nsrc_x\t拷贝图像开始 x 坐标\nsrc_y\t拷贝图像开始 y 坐标，x,y同为 0 则从左上角开始拷贝\nsrc_w\t（从 src_x 开始）拷贝的宽度\nsrc_h\t（从 src_y 开始）拷贝的高度\npct\t图像合并程度，取值 0-100 ，当 pct=0 时，实际上什么也没做，反之完全合并。\n\n","source":"_posts/php图像合并.md","raw":"---\ntitle: php圆形头像生成与合并\ndate: 2017-05-09 15:01:29\ntags: php\n---\n> 实习中的一个项目，用到将两张图片合并成一张，使用了PHP的图像函数，发现挺好处理的。\n\n#圆形头像的生成#\n\n在项目中需要获取用户头像并制作成固定大小的圆形头像，如果用css是很容易解决的，`border-radius`设置为尺寸的50%,但是不能用css，因为要求返回的是一张图片而不是页面，这确实让我困惑了很久。\n说一说代码的实现：\n \n\n 1. 明确头像要求的尺寸，假设为`new_size`，然后获取原始头像的url\n\n   ` $url = 'xxxx';`\n    `$new_size = 'xxx';`\n    `$oldimg = imagecreatefromjpeg($url);`\n    `size = [imagesx($oldimg),imagesy($oldimg)];\n    $newimg = imagecreatetruecolor($new_size);\n    imagecopyresized($newimg,$oldimg,0,0,0,0,$new_size,$new_size,size[1],size[2]);`\n   ` //圆形透明图像`\n   ` imagealphablending($newpic,false); ` \n    `$transparent = imagecolorallocatealpha($newimg, 0, 0, 0, 127);`  \n   ` $r=$new_size/2; ` \n    `for($x=0;$x<$new_size;$x++) {`\n       ` for($y=0;$y<$new_size;$y++){  `\n           ` $c = imagecolorat($src,$x,$y);`  \n          `  $_x = $x - $r;  `\n           ` $_y = $y - $r;  `\n          `  if((($_x*$_x) + ($_y*$_y)) < ($r*$r)){  `\n               `  imagesetpixel($newimg,$x,$y,$c);  `\n           ` }else{  `\n               ` imagesetpixel($newimg,$x,$y,$transparent); ` \n           `}  `\n                `}  `\n           ` imagesavealpha($newimg, true);  `\n           ` header('Content-Type: image/png');  `\n           ` imagepng($newpic);  `\n          `  imagedestroy($newpic);  `\n           ` imagedestroy($old);  `\n        `} `\n\n注意：图片最后保存为png格式，之前尝试过保存为jpeg，然后透明部分就变成了黑色，估计应该是png能保留透明通道的原因。\n\n#合并图片#\n合并图片用的是php的`imagecopymerge()`函数，接上代码：\n\n    $bgimgurl = 'xxx';\n$bgimg = imagecreatefromjpeg($bgimgurl);    $src_size= [imagesx($bgimg),imagesy($bgimg)];\n    imagecopymerge($bgimg, $newimg, $dst_x , $dst_y , $src_x , $src_y , $src_w , $src_h , $pct);\n    \n一些参数的释义如下：\ndst_x\t目标图像开始 x 坐标\ndst_y\t目标图像开始 y 坐标，x,y同为 0 则从左上角开始\nsrc_x\t拷贝图像开始 x 坐标\nsrc_y\t拷贝图像开始 y 坐标，x,y同为 0 则从左上角开始拷贝\nsrc_w\t（从 src_x 开始）拷贝的宽度\nsrc_h\t（从 src_y 开始）拷贝的高度\npct\t图像合并程度，取值 0-100 ，当 pct=0 时，实际上什么也没做，反之完全合并。\n\n","slug":"php图像合并","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dt000plvwvrlcke72k","content":"<blockquote>\n<p>实习中的一个项目，用到将两张图片合并成一张，使用了PHP的图像函数，发现挺好处理的。</p>\n</blockquote>\n<p>#圆形头像的生成#</p>\n<p>在项目中需要获取用户头像并制作成固定大小的圆形头像，如果用css是很容易解决的，<code>border-radius</code>设置为尺寸的50%,但是不能用css，因为要求返回的是一张图片而不是页面，这确实让我困惑了很久。<br>说一说代码的实现：</p>\n<ol>\n<li><p>明确头像要求的尺寸，假设为<code>new_size</code>，然后获取原始头像的url</p>\n<p><code>$url = &#39;xxxx&#39;;</code><br><code>$new_size = &#39;xxx&#39;;</code><br><code>$oldimg = imagecreatefromjpeg($url);</code><br><code>size = [imagesx($oldimg),imagesy($oldimg)];\n$newimg = imagecreatetruecolor($new_size);\nimagecopyresized($newimg,$oldimg,0,0,0,0,$new_size,$new_size,size[1],size[2]);</code><br><code>//圆形透明图像</code><br><code>imagealphablending($newpic,false);</code><br><code>$transparent = imagecolorallocatealpha($newimg, 0, 0, 0, 127);</code><br><code>$r=$new_size/2;</code><br><code>for($x=0;$x&lt;$new_size;$x++) {</code><br>   <code>for($y=0;$y&lt;$new_size;$y++){</code></p>\n<pre><code>   ` $c = imagecolorat($src,$x,$y);`  \n  `  $_x = $x - $r;  `\n   ` $_y = $y - $r;  `\n  `  if((($_x*$_x) + ($_y*$_y)) &lt; ($r*$r)){  `\n       `  imagesetpixel($newimg,$x,$y,$c);  `\n   ` }else{  `\n       ` imagesetpixel($newimg,$x,$y,$transparent); ` \n   `}  `\n        `}  `\n   ` imagesavealpha($newimg, true);  `\n   ` header(&apos;Content-Type: image/png&apos;);  `\n   ` imagepng($newpic);  `\n  `  imagedestroy($newpic);  `\n   ` imagedestroy($old);  `\n`} `\n</code></pre></li>\n</ol>\n<p>注意：图片最后保存为png格式，之前尝试过保存为jpeg，然后透明部分就变成了黑色，估计应该是png能保留透明通道的原因。</p>\n<p>#合并图片#<br>合并图片用的是php的<code>imagecopymerge()</code>函数，接上代码：</p>\n<pre><code>$bgimgurl = &apos;xxx&apos;;\n</code></pre><p>$bgimg = imagecreatefromjpeg($bgimgurl);    $src_size= [imagesx($bgimg),imagesy($bgimg)];<br>    imagecopymerge($bgimg, $newimg, $dst_x , $dst_y , $src_x , $src_y , $src_w , $src_h , $pct);</p>\n<p>一些参数的释义如下：<br>dst_x    目标图像开始 x 坐标<br>dst_y    目标图像开始 y 坐标，x,y同为 0 则从左上角开始<br>src_x    拷贝图像开始 x 坐标<br>src_y    拷贝图像开始 y 坐标，x,y同为 0 则从左上角开始拷贝<br>src_w    （从 src_x 开始）拷贝的宽度<br>src_h    （从 src_y 开始）拷贝的高度<br>pct    图像合并程度，取值 0-100 ，当 pct=0 时，实际上什么也没做，反之完全合并。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>实习中的一个项目，用到将两张图片合并成一张，使用了PHP的图像函数，发现挺好处理的。</p>\n</blockquote>\n<p>#圆形头像的生成#</p>\n<p>在项目中需要获取用户头像并制作成固定大小的圆形头像，如果用css是很容易解决的，<code>border-radius</code>设置为尺寸的50%,但是不能用css，因为要求返回的是一张图片而不是页面，这确实让我困惑了很久。<br>说一说代码的实现：</p>\n<ol>\n<li><p>明确头像要求的尺寸，假设为<code>new_size</code>，然后获取原始头像的url</p>\n<p><code>$url = &#39;xxxx&#39;;</code><br><code>$new_size = &#39;xxx&#39;;</code><br><code>$oldimg = imagecreatefromjpeg($url);</code><br><code>size = [imagesx($oldimg),imagesy($oldimg)];\n$newimg = imagecreatetruecolor($new_size);\nimagecopyresized($newimg,$oldimg,0,0,0,0,$new_size,$new_size,size[1],size[2]);</code><br><code>//圆形透明图像</code><br><code>imagealphablending($newpic,false);</code><br><code>$transparent = imagecolorallocatealpha($newimg, 0, 0, 0, 127);</code><br><code>$r=$new_size/2;</code><br><code>for($x=0;$x&lt;$new_size;$x++) {</code><br>   <code>for($y=0;$y&lt;$new_size;$y++){</code></p>\n<pre><code>   ` $c = imagecolorat($src,$x,$y);`  \n  `  $_x = $x - $r;  `\n   ` $_y = $y - $r;  `\n  `  if((($_x*$_x) + ($_y*$_y)) &lt; ($r*$r)){  `\n       `  imagesetpixel($newimg,$x,$y,$c);  `\n   ` }else{  `\n       ` imagesetpixel($newimg,$x,$y,$transparent); ` \n   `}  `\n        `}  `\n   ` imagesavealpha($newimg, true);  `\n   ` header(&apos;Content-Type: image/png&apos;);  `\n   ` imagepng($newpic);  `\n  `  imagedestroy($newpic);  `\n   ` imagedestroy($old);  `\n`} `\n</code></pre></li>\n</ol>\n<p>注意：图片最后保存为png格式，之前尝试过保存为jpeg，然后透明部分就变成了黑色，估计应该是png能保留透明通道的原因。</p>\n<p>#合并图片#<br>合并图片用的是php的<code>imagecopymerge()</code>函数，接上代码：</p>\n<pre><code>$bgimgurl = &apos;xxx&apos;;\n</code></pre><p>$bgimg = imagecreatefromjpeg($bgimgurl);    $src_size= [imagesx($bgimg),imagesy($bgimg)];<br>    imagecopymerge($bgimg, $newimg, $dst_x , $dst_y , $src_x , $src_y , $src_w , $src_h , $pct);</p>\n<p>一些参数的释义如下：<br>dst_x    目标图像开始 x 坐标<br>dst_y    目标图像开始 y 坐标，x,y同为 0 则从左上角开始<br>src_x    拷贝图像开始 x 坐标<br>src_y    拷贝图像开始 y 坐标，x,y同为 0 则从左上角开始拷贝<br>src_w    （从 src_x 开始）拷贝的宽度<br>src_h    （从 src_y 开始）拷贝的高度<br>pct    图像合并程度，取值 0-100 ，当 pct=0 时，实际上什么也没做，反之完全合并。</p>\n"},{"title":"setTimeout在循环中","date":"2017-02-19T12:09:30.000Z","_content":"> 考察了异步，作用域，闭包知识点。\n\n这个问题源于在知乎上碰到的一篇文章，文章传送门在这[如果你想靠前端技术还房贷，你不能连这个都不会][1]。之前看了《javascript高级程序设计》这本书，想着自己应该能理解，一复习发现还是半懂不懂那就是不懂，还是需要多敲代码多练习。\n\n题目是这样子的：\n\n        // 请问输出什么\n    for (var i = 0; i < 10; ++i) {\n        setTimeout(function () {console.log(i)}, 0);\n    }\n\n**第一问，这段代码输出什么？第二问，如果想让这段代码输出0123456789，应该怎么修改？**\n\n这题考察了闭包和setTimeout()的知识点。\n\n# 闭包的理解\n先说我对闭包的理解吧，闭包就是在我们定义一个外部函数时，又定义一个子函数，如果这个内部函数引用父函數作用域的變量，他就是一个闭包。因为javascript的“链式作用域”结构，子对象会向上寻找所有父对象的变量，所以子函数能访问父级函数的变量。\n\n# setTimeout（）的理解\nsetTimeout是异步的。\n正确的理解setTimeout的方式(注册事件)：\n有两个参数，第一个参数是函数，第二参数是时间值。\n调用setTimeout时，把函数参数，放到事件队列中。等主程序运行完，再调用。\n就像我们给按钮绑定时间一样，事件绑定了不会执行，只有去触发它了之后才会。而setTimeout()的执行条件就是等主程序执行完毕。那么时间参数怎么理解。我们可以理解为时间参数之后，再把setTimeout的function放入事件队列中，如果此时队列为空，那么就直接调用fn。如果前面还有其他的事件，那就等待。\n\n在上面的两个理解之下，我们再去看题目。\n\n# 答案解析\n> 不知道是否百分百准确。\n\n在执行这个函数时，在每一次循环时把setTimeout函数放进了事件队列中，但是主程序并没有执行完毕，在第十次放入事件队列后，主程序执行完毕开始依次执行setTimeout函数。因为setTimeout的函数参数引用了变量i的，所以i不会在主程序执行完毕后被垃圾回收，内存不会销毁，这时去寻找i的值`i=10`，因为var没有块级作用域，输出10，因此会输出十次10。\n\n怎样会输出0-9呢？我尝试了，有两种解决方法：\n(1)使用具有块级作用域的let定义变量\n\n    for(let i = 0; i < 10; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n\n\n(2)自执行匿名函数\n\n    for(var i = 0; i < 10; i++) {\n    (function(x){setTimeout(function() {\n        console.log(x);  \n    }, 1000);})(i)\n}\n外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 x 变量就拥有了 i 的一个拷贝。\n  [1]: https://www.zhihu.com/collection/142522312","source":"_posts/setTimeout在循环中.md","raw":"---\ntitle: setTimeout在循环中\ndate: 2017-02-19 20:09:30\ntags: javascript\n---\n> 考察了异步，作用域，闭包知识点。\n\n这个问题源于在知乎上碰到的一篇文章，文章传送门在这[如果你想靠前端技术还房贷，你不能连这个都不会][1]。之前看了《javascript高级程序设计》这本书，想着自己应该能理解，一复习发现还是半懂不懂那就是不懂，还是需要多敲代码多练习。\n\n题目是这样子的：\n\n        // 请问输出什么\n    for (var i = 0; i < 10; ++i) {\n        setTimeout(function () {console.log(i)}, 0);\n    }\n\n**第一问，这段代码输出什么？第二问，如果想让这段代码输出0123456789，应该怎么修改？**\n\n这题考察了闭包和setTimeout()的知识点。\n\n# 闭包的理解\n先说我对闭包的理解吧，闭包就是在我们定义一个外部函数时，又定义一个子函数，如果这个内部函数引用父函數作用域的變量，他就是一个闭包。因为javascript的“链式作用域”结构，子对象会向上寻找所有父对象的变量，所以子函数能访问父级函数的变量。\n\n# setTimeout（）的理解\nsetTimeout是异步的。\n正确的理解setTimeout的方式(注册事件)：\n有两个参数，第一个参数是函数，第二参数是时间值。\n调用setTimeout时，把函数参数，放到事件队列中。等主程序运行完，再调用。\n就像我们给按钮绑定时间一样，事件绑定了不会执行，只有去触发它了之后才会。而setTimeout()的执行条件就是等主程序执行完毕。那么时间参数怎么理解。我们可以理解为时间参数之后，再把setTimeout的function放入事件队列中，如果此时队列为空，那么就直接调用fn。如果前面还有其他的事件，那就等待。\n\n在上面的两个理解之下，我们再去看题目。\n\n# 答案解析\n> 不知道是否百分百准确。\n\n在执行这个函数时，在每一次循环时把setTimeout函数放进了事件队列中，但是主程序并没有执行完毕，在第十次放入事件队列后，主程序执行完毕开始依次执行setTimeout函数。因为setTimeout的函数参数引用了变量i的，所以i不会在主程序执行完毕后被垃圾回收，内存不会销毁，这时去寻找i的值`i=10`，因为var没有块级作用域，输出10，因此会输出十次10。\n\n怎样会输出0-9呢？我尝试了，有两种解决方法：\n(1)使用具有块级作用域的let定义变量\n\n    for(let i = 0; i < 10; i++) {\n    setTimeout(function() {\n        console.log(i);  \n    }, 1000);\n}\n\n\n(2)自执行匿名函数\n\n    for(var i = 0; i < 10; i++) {\n    (function(x){setTimeout(function() {\n        console.log(x);  \n    }, 1000);})(i)\n}\n外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 x 变量就拥有了 i 的一个拷贝。\n  [1]: https://www.zhihu.com/collection/142522312","slug":"setTimeout在循环中","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6du000rlvwvm27qa3ve","content":"<blockquote>\n<p>考察了异步，作用域，闭包知识点。</p>\n</blockquote>\n<p>这个问题源于在知乎上碰到的一篇文章，文章传送门在这<a href=\"https://www.zhihu.com/collection/142522312\" target=\"_blank\" rel=\"noopener\">如果你想靠前端技术还房贷，你不能连这个都不会</a>。之前看了《javascript高级程序设计》这本书，想着自己应该能理解，一复习发现还是半懂不懂那就是不懂，还是需要多敲代码多练习。</p>\n<p>题目是这样子的：</p>\n<pre><code>    // 请问输出什么\nfor (var i = 0; i &lt; 10; ++i) {\n    setTimeout(function () {console.log(i)}, 0);\n}\n</code></pre><p><strong>第一问，这段代码输出什么？第二问，如果想让这段代码输出0123456789，应该怎么修改？</strong></p>\n<p>这题考察了闭包和setTimeout()的知识点。</p>\n<h1 id=\"闭包的理解\"><a href=\"#闭包的理解\" class=\"headerlink\" title=\"闭包的理解\"></a>闭包的理解</h1><p>先说我对闭包的理解吧，闭包就是在我们定义一个外部函数时，又定义一个子函数，如果这个内部函数引用父函數作用域的變量，他就是一个闭包。因为javascript的“链式作用域”结构，子对象会向上寻找所有父对象的变量，所以子函数能访问父级函数的变量。</p>\n<h1 id=\"setTimeout（）的理解\"><a href=\"#setTimeout（）的理解\" class=\"headerlink\" title=\"setTimeout（）的理解\"></a>setTimeout（）的理解</h1><p>setTimeout是异步的。<br>正确的理解setTimeout的方式(注册事件)：<br>有两个参数，第一个参数是函数，第二参数是时间值。<br>调用setTimeout时，把函数参数，放到事件队列中。等主程序运行完，再调用。<br>就像我们给按钮绑定时间一样，事件绑定了不会执行，只有去触发它了之后才会。而setTimeout()的执行条件就是等主程序执行完毕。那么时间参数怎么理解。我们可以理解为时间参数之后，再把setTimeout的function放入事件队列中，如果此时队列为空，那么就直接调用fn。如果前面还有其他的事件，那就等待。</p>\n<p>在上面的两个理解之下，我们再去看题目。</p>\n<h1 id=\"答案解析\"><a href=\"#答案解析\" class=\"headerlink\" title=\"答案解析\"></a>答案解析</h1><blockquote>\n<p>不知道是否百分百准确。</p>\n</blockquote>\n<p>在执行这个函数时，在每一次循环时把setTimeout函数放进了事件队列中，但是主程序并没有执行完毕，在第十次放入事件队列后，主程序执行完毕开始依次执行setTimeout函数。因为setTimeout的函数参数引用了变量i的，所以i不会在主程序执行完毕后被垃圾回收，内存不会销毁，这时去寻找i的值<code>i=10</code>，因为var没有块级作用域，输出10，因此会输出十次10。</p>\n<p>怎样会输出0-9呢？我尝试了，有两种解决方法：<br>(1)使用具有块级作用域的let定义变量</p>\n<pre><code>for(let i = 0; i &lt; 10; i++) {\nsetTimeout(function() {\n    console.log(i);  \n}, 1000);\n</code></pre><p>}</p>\n<p>(2)自执行匿名函数</p>\n<pre><code>for(var i = 0; i &lt; 10; i++) {\n(function(x){setTimeout(function() {\n    console.log(x);  \n}, 1000);})(i)\n</code></pre><p>}<br>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 x 变量就拥有了 i 的一个拷贝。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>考察了异步，作用域，闭包知识点。</p>\n</blockquote>\n<p>这个问题源于在知乎上碰到的一篇文章，文章传送门在这<a href=\"https://www.zhihu.com/collection/142522312\" target=\"_blank\" rel=\"noopener\">如果你想靠前端技术还房贷，你不能连这个都不会</a>。之前看了《javascript高级程序设计》这本书，想着自己应该能理解，一复习发现还是半懂不懂那就是不懂，还是需要多敲代码多练习。</p>\n<p>题目是这样子的：</p>\n<pre><code>    // 请问输出什么\nfor (var i = 0; i &lt; 10; ++i) {\n    setTimeout(function () {console.log(i)}, 0);\n}\n</code></pre><p><strong>第一问，这段代码输出什么？第二问，如果想让这段代码输出0123456789，应该怎么修改？</strong></p>\n<p>这题考察了闭包和setTimeout()的知识点。</p>\n<h1 id=\"闭包的理解\"><a href=\"#闭包的理解\" class=\"headerlink\" title=\"闭包的理解\"></a>闭包的理解</h1><p>先说我对闭包的理解吧，闭包就是在我们定义一个外部函数时，又定义一个子函数，如果这个内部函数引用父函數作用域的變量，他就是一个闭包。因为javascript的“链式作用域”结构，子对象会向上寻找所有父对象的变量，所以子函数能访问父级函数的变量。</p>\n<h1 id=\"setTimeout（）的理解\"><a href=\"#setTimeout（）的理解\" class=\"headerlink\" title=\"setTimeout（）的理解\"></a>setTimeout（）的理解</h1><p>setTimeout是异步的。<br>正确的理解setTimeout的方式(注册事件)：<br>有两个参数，第一个参数是函数，第二参数是时间值。<br>调用setTimeout时，把函数参数，放到事件队列中。等主程序运行完，再调用。<br>就像我们给按钮绑定时间一样，事件绑定了不会执行，只有去触发它了之后才会。而setTimeout()的执行条件就是等主程序执行完毕。那么时间参数怎么理解。我们可以理解为时间参数之后，再把setTimeout的function放入事件队列中，如果此时队列为空，那么就直接调用fn。如果前面还有其他的事件，那就等待。</p>\n<p>在上面的两个理解之下，我们再去看题目。</p>\n<h1 id=\"答案解析\"><a href=\"#答案解析\" class=\"headerlink\" title=\"答案解析\"></a>答案解析</h1><blockquote>\n<p>不知道是否百分百准确。</p>\n</blockquote>\n<p>在执行这个函数时，在每一次循环时把setTimeout函数放进了事件队列中，但是主程序并没有执行完毕，在第十次放入事件队列后，主程序执行完毕开始依次执行setTimeout函数。因为setTimeout的函数参数引用了变量i的，所以i不会在主程序执行完毕后被垃圾回收，内存不会销毁，这时去寻找i的值<code>i=10</code>，因为var没有块级作用域，输出10，因此会输出十次10。</p>\n<p>怎样会输出0-9呢？我尝试了，有两种解决方法：<br>(1)使用具有块级作用域的let定义变量</p>\n<pre><code>for(let i = 0; i &lt; 10; i++) {\nsetTimeout(function() {\n    console.log(i);  \n}, 1000);\n</code></pre><p>}</p>\n<p>(2)自执行匿名函数</p>\n<pre><code>for(var i = 0; i &lt; 10; i++) {\n(function(x){setTimeout(function() {\n    console.log(x);  \n}, 1000);})(i)\n</code></pre><p>}<br>外部的匿名函数会立即执行，并把 i 作为它的参数，此时函数内 x 变量就拥有了 i 的一个拷贝。</p>\n"},{"title":"xss攻击","date":"2017-03-18T12:58:41.000Z","_content":"> 最近忙着参加春招笔试和IFE2017都没什么时间写日志了233 昨天笔试遇到了道xss攻击的题，xss攻击听了很多遍，自己没怎么深入了解过，留个笔记\n\n# 什么是xss攻击\nxss(cross-site scripting 跨域脚本攻击)攻击是常见的web攻击。在web页面里面插入恶意的script代码，当用户浏览该网页时恶意脚本被运行。我的理解就是xss攻击就是执行不被期望的恶意脚本代码。\nxss攻击有三种：\n\n - Reflected XSS(基于反射的XSS攻击)\n - Stored XSS(基于存储的XSS攻击)\n - DOM-based or local XSS(基于DOM或本地的XSS攻击)\n \n# 反射型 XSS\n将用户输入的存在XSS攻击的数据，发送到后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染而导致的XSS攻击。\n**开发安全措施：**\n1.前端在显示服务端数据时候，不仅是便签内容需要过滤、转义，就连属性值也都可能需要。\n2.后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。\n\n# 存储型XSS\n基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。\n**措施**\n后端应该尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。\n# DOM或本地XSS攻击\n基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。","source":"_posts/xss攻击.md","raw":"---\ntitle: xss攻击\ndate: 2017-03-18 20:58:41\ntags: xss\n---\n> 最近忙着参加春招笔试和IFE2017都没什么时间写日志了233 昨天笔试遇到了道xss攻击的题，xss攻击听了很多遍，自己没怎么深入了解过，留个笔记\n\n# 什么是xss攻击\nxss(cross-site scripting 跨域脚本攻击)攻击是常见的web攻击。在web页面里面插入恶意的script代码，当用户浏览该网页时恶意脚本被运行。我的理解就是xss攻击就是执行不被期望的恶意脚本代码。\nxss攻击有三种：\n\n - Reflected XSS(基于反射的XSS攻击)\n - Stored XSS(基于存储的XSS攻击)\n - DOM-based or local XSS(基于DOM或本地的XSS攻击)\n \n# 反射型 XSS\n将用户输入的存在XSS攻击的数据，发送到后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染而导致的XSS攻击。\n**开发安全措施：**\n1.前端在显示服务端数据时候，不仅是便签内容需要过滤、转义，就连属性值也都可能需要。\n2.后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。\n\n# 存储型XSS\n基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。\n**措施**\n后端应该尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。\n# DOM或本地XSS攻击\n基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。","slug":"xss攻击","published":1,"updated":"2019-03-17T03:04:24.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dv000tlvwvxjmx77h6","content":"<blockquote>\n<p>最近忙着参加春招笔试和IFE2017都没什么时间写日志了233 昨天笔试遇到了道xss攻击的题，xss攻击听了很多遍，自己没怎么深入了解过，留个笔记</p>\n</blockquote>\n<h1 id=\"什么是xss攻击\"><a href=\"#什么是xss攻击\" class=\"headerlink\" title=\"什么是xss攻击\"></a>什么是xss攻击</h1><p>xss(cross-site scripting 跨域脚本攻击)攻击是常见的web攻击。在web页面里面插入恶意的script代码，当用户浏览该网页时恶意脚本被运行。我的理解就是xss攻击就是执行不被期望的恶意脚本代码。<br>xss攻击有三种：</p>\n<ul>\n<li>Reflected XSS(基于反射的XSS攻击)</li>\n<li>Stored XSS(基于存储的XSS攻击)</li>\n<li>DOM-based or local XSS(基于DOM或本地的XSS攻击)</li>\n</ul>\n<h1 id=\"反射型-XSS\"><a href=\"#反射型-XSS\" class=\"headerlink\" title=\"反射型 XSS\"></a>反射型 XSS</h1><p>将用户输入的存在XSS攻击的数据，发送到后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染而导致的XSS攻击。<br><strong>开发安全措施：</strong><br>1.前端在显示服务端数据时候，不仅是便签内容需要过滤、转义，就连属性值也都可能需要。<br>2.后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。</p>\n<h1 id=\"存储型XSS\"><a href=\"#存储型XSS\" class=\"headerlink\" title=\"存储型XSS\"></a>存储型XSS</h1><p>基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。<br><strong>措施</strong><br>后端应该尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。</p>\n<h1 id=\"DOM或本地XSS攻击\"><a href=\"#DOM或本地XSS攻击\" class=\"headerlink\" title=\"DOM或本地XSS攻击\"></a>DOM或本地XSS攻击</h1><p>基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近忙着参加春招笔试和IFE2017都没什么时间写日志了233 昨天笔试遇到了道xss攻击的题，xss攻击听了很多遍，自己没怎么深入了解过，留个笔记</p>\n</blockquote>\n<h1 id=\"什么是xss攻击\"><a href=\"#什么是xss攻击\" class=\"headerlink\" title=\"什么是xss攻击\"></a>什么是xss攻击</h1><p>xss(cross-site scripting 跨域脚本攻击)攻击是常见的web攻击。在web页面里面插入恶意的script代码，当用户浏览该网页时恶意脚本被运行。我的理解就是xss攻击就是执行不被期望的恶意脚本代码。<br>xss攻击有三种：</p>\n<ul>\n<li>Reflected XSS(基于反射的XSS攻击)</li>\n<li>Stored XSS(基于存储的XSS攻击)</li>\n<li>DOM-based or local XSS(基于DOM或本地的XSS攻击)</li>\n</ul>\n<h1 id=\"反射型-XSS\"><a href=\"#反射型-XSS\" class=\"headerlink\" title=\"反射型 XSS\"></a>反射型 XSS</h1><p>将用户输入的存在XSS攻击的数据，发送到后台，后台并未对数据进行存储，也未经过任何过滤，直接返回给客户端。被浏览器渲染而导致的XSS攻击。<br><strong>开发安全措施：</strong><br>1.前端在显示服务端数据时候，不仅是便签内容需要过滤、转义，就连属性值也都可能需要。<br>2.后端接收请求时，验证请求是否为攻击请求，攻击则屏蔽。</p>\n<h1 id=\"存储型XSS\"><a href=\"#存储型XSS\" class=\"headerlink\" title=\"存储型XSS\"></a>存储型XSS</h1><p>基于存储的XSS攻击，是通过发表带有恶意跨域脚本的帖子/文章，从而把恶意脚本存储在服务器，每个访问该帖子/文章的人就会触发执行。<br><strong>措施</strong><br>后端应该尽可能对提交数据做过滤，在场景需求而不过滤的情况下，前端就需要做些处理了。</p>\n<h1 id=\"DOM或本地XSS攻击\"><a href=\"#DOM或本地XSS攻击\" class=\"headerlink\" title=\"DOM或本地XSS攻击\"></a>DOM或本地XSS攻击</h1><p>基于DOM或本地的XSS攻击。一般是提供一个免费的wifi，但是提供免费wifi的网关会往你访问的任何页面插入一段脚本或者是直接返回一个钓鱼页面，从而植入恶意脚本。这种直接存在于页面，无须经过服务器返回就是基于本地的XSS攻击。</p>\n"},{"title":"函数柯里化","date":"2018-03-26T15:18:56.000Z","_content":"\n> 最近在看阮一峰的《ES6入门》，在尾调用扩展中提到了函数柯里化。\n\n\n一、什么是尾调用\n==================\n尾调用是函数式编程的一个概念，就是某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要在最后一步操作即可。\n\n尾调用很特殊，函数调用会在内存中有一个调用帧，保存调用位置和内部变量等信息，函数嵌套调用形成一个调用栈。尾调用由于函数是最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等不会再用到了。\n\n二、尾调用和尾递归\n===============\n函数调用本身叫做递归，尾调用自身就称为尾递归。递归由于需要保存很多个调用帧很容易发生栈溢出，但是对于尾递归来说，由于只存在一个调用栈所以不会发生栈溢出。 \n\n三、尾递归的实现\n================\n终于要讲到函数柯里化(curring)。尾递归的实现往往是从递归函数改写而来的，改写的步骤就是把所有用到的内部变量改写成函数的参数。在递归函数改写成尾递归函数这里，没有函数柯里化什么事，函数柯里化是在尾递归改写完成后将多参数改写成单参数。先解释下柯里化的意思，指将多参数函数改写成单参数形式。\n\n根据张鑫旭的博文[JS中的柯里化][1]中写道柯里化主要有三个作用：1.参数服用；2.提前返回；3.延迟计算/运行。\n\n在本书中，关于柯里化的代码解释如下：\n```javascript\nfunction currying(fn,n){\n    return function(m){\n        return fn.call(this,m,n);\n    }\n}\nfunction tailFactorial(n, total){\n    if(n === 1) return total;\n    return tailFactorial(n-1, n*total);\n}\n\nconst factorial = curring(tailFactorial, 1);\n\nfactorial(5) //120\n```\n上面是一种笨拙的方法，这里，n指尾递归函数的参数默认值,m是尾递归参数真正的参数。以上代码将阶乘尾递归函数tailFactorial变成只接受一个参数的factorial.\n同时，利用ES6的函数默认值也能实现上面的函数柯里化：\n```javascript\nfunction factorial(n, total=1){\n    if(n === 1) return total;\n    return factorial(n, n*total);\n}\n```\n\n\n\n  [1]: http://www.zhangxinxu.com/wordpress/2013/02/js-currying/","source":"_posts/函数柯里化.md","raw":"---\ntitle: 函数柯里化\ndate: 2018-03-26 23:18:56\ntags: ES6\n---\n\n> 最近在看阮一峰的《ES6入门》，在尾调用扩展中提到了函数柯里化。\n\n\n一、什么是尾调用\n==================\n尾调用是函数式编程的一个概念，就是某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要在最后一步操作即可。\n\n尾调用很特殊，函数调用会在内存中有一个调用帧，保存调用位置和内部变量等信息，函数嵌套调用形成一个调用栈。尾调用由于函数是最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等不会再用到了。\n\n二、尾调用和尾递归\n===============\n函数调用本身叫做递归，尾调用自身就称为尾递归。递归由于需要保存很多个调用帧很容易发生栈溢出，但是对于尾递归来说，由于只存在一个调用栈所以不会发生栈溢出。 \n\n三、尾递归的实现\n================\n终于要讲到函数柯里化(curring)。尾递归的实现往往是从递归函数改写而来的，改写的步骤就是把所有用到的内部变量改写成函数的参数。在递归函数改写成尾递归函数这里，没有函数柯里化什么事，函数柯里化是在尾递归改写完成后将多参数改写成单参数。先解释下柯里化的意思，指将多参数函数改写成单参数形式。\n\n根据张鑫旭的博文[JS中的柯里化][1]中写道柯里化主要有三个作用：1.参数服用；2.提前返回；3.延迟计算/运行。\n\n在本书中，关于柯里化的代码解释如下：\n```javascript\nfunction currying(fn,n){\n    return function(m){\n        return fn.call(this,m,n);\n    }\n}\nfunction tailFactorial(n, total){\n    if(n === 1) return total;\n    return tailFactorial(n-1, n*total);\n}\n\nconst factorial = curring(tailFactorial, 1);\n\nfactorial(5) //120\n```\n上面是一种笨拙的方法，这里，n指尾递归函数的参数默认值,m是尾递归参数真正的参数。以上代码将阶乘尾递归函数tailFactorial变成只接受一个参数的factorial.\n同时，利用ES6的函数默认值也能实现上面的函数柯里化：\n```javascript\nfunction factorial(n, total=1){\n    if(n === 1) return total;\n    return factorial(n, n*total);\n}\n```\n\n\n\n  [1]: http://www.zhangxinxu.com/wordpress/2013/02/js-currying/","slug":"函数柯里化","published":1,"updated":"2019-03-17T03:04:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dv000vlvwvujg58vhd","content":"<blockquote>\n<p>最近在看阮一峰的《ES6入门》，在尾调用扩展中提到了函数柯里化。</p>\n</blockquote>\n<h1 id=\"一、什么是尾调用\"><a href=\"#一、什么是尾调用\" class=\"headerlink\" title=\"一、什么是尾调用\"></a>一、什么是尾调用</h1><p>尾调用是函数式编程的一个概念，就是某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要在最后一步操作即可。</p>\n<p>尾调用很特殊，函数调用会在内存中有一个调用帧，保存调用位置和内部变量等信息，函数嵌套调用形成一个调用栈。尾调用由于函数是最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等不会再用到了。</p>\n<h1 id=\"二、尾调用和尾递归\"><a href=\"#二、尾调用和尾递归\" class=\"headerlink\" title=\"二、尾调用和尾递归\"></a>二、尾调用和尾递归</h1><p>函数调用本身叫做递归，尾调用自身就称为尾递归。递归由于需要保存很多个调用帧很容易发生栈溢出，但是对于尾递归来说，由于只存在一个调用栈所以不会发生栈溢出。 </p>\n<h1 id=\"三、尾递归的实现\"><a href=\"#三、尾递归的实现\" class=\"headerlink\" title=\"三、尾递归的实现\"></a>三、尾递归的实现</h1><p>终于要讲到函数柯里化(curring)。尾递归的实现往往是从递归函数改写而来的，改写的步骤就是把所有用到的内部变量改写成函数的参数。在递归函数改写成尾递归函数这里，没有函数柯里化什么事，函数柯里化是在尾递归改写完成后将多参数改写成单参数。先解释下柯里化的意思，指将多参数函数改写成单参数形式。</p>\n<p>根据张鑫旭的博文<a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">JS中的柯里化</a>中写道柯里化主要有三个作用：1.参数服用；2.提前返回；3.延迟计算/运行。</p>\n<p>在本书中，关于柯里化的代码解释如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn,n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>,m,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tailFactorial(n<span class=\"number\">-1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = curring(tailFactorial, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">//120</span></span><br></pre></td></tr></table></figure></p>\n<p>上面是一种笨拙的方法，这里，n指尾递归函数的参数默认值,m是尾递归参数真正的参数。以上代码将阶乘尾递归函数tailFactorial变成只接受一个参数的factorial.<br>同时，利用ES6的函数默认值也能实现上面的函数柯里化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total=<span class=\"number\">1</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n, n*total);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>最近在看阮一峰的《ES6入门》，在尾调用扩展中提到了函数柯里化。</p>\n</blockquote>\n<h1 id=\"一、什么是尾调用\"><a href=\"#一、什么是尾调用\" class=\"headerlink\" title=\"一、什么是尾调用\"></a>一、什么是尾调用</h1><p>尾调用是函数式编程的一个概念，就是某个函数的最后一步是调用另一个函数。尾调用不一定出现在函数尾部，只要在最后一步操作即可。</p>\n<p>尾调用很特殊，函数调用会在内存中有一个调用帧，保存调用位置和内部变量等信息，函数嵌套调用形成一个调用栈。尾调用由于函数是最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置，内部变量等不会再用到了。</p>\n<h1 id=\"二、尾调用和尾递归\"><a href=\"#二、尾调用和尾递归\" class=\"headerlink\" title=\"二、尾调用和尾递归\"></a>二、尾调用和尾递归</h1><p>函数调用本身叫做递归，尾调用自身就称为尾递归。递归由于需要保存很多个调用帧很容易发生栈溢出，但是对于尾递归来说，由于只存在一个调用栈所以不会发生栈溢出。 </p>\n<h1 id=\"三、尾递归的实现\"><a href=\"#三、尾递归的实现\" class=\"headerlink\" title=\"三、尾递归的实现\"></a>三、尾递归的实现</h1><p>终于要讲到函数柯里化(curring)。尾递归的实现往往是从递归函数改写而来的，改写的步骤就是把所有用到的内部变量改写成函数的参数。在递归函数改写成尾递归函数这里，没有函数柯里化什么事，函数柯里化是在尾递归改写完成后将多参数改写成单参数。先解释下柯里化的意思，指将多参数函数改写成单参数形式。</p>\n<p>根据张鑫旭的博文<a href=\"http://www.zhangxinxu.com/wordpress/2013/02/js-currying/\" target=\"_blank\" rel=\"noopener\">JS中的柯里化</a>中写道柯里化主要有三个作用：1.参数服用；2.提前返回；3.延迟计算/运行。</p>\n<p>在本书中，关于柯里化的代码解释如下：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">currying</span>(<span class=\"params\">fn,n</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">m</span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> fn.call(<span class=\"keyword\">this</span>,m,n);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">tailFactorial</span>(<span class=\"params\">n, total</span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tailFactorial(n<span class=\"number\">-1</span>, n*total);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> factorial = curring(tailFactorial, <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">factorial(<span class=\"number\">5</span>) <span class=\"comment\">//120</span></span><br></pre></td></tr></table></figure></p>\n<p>上面是一种笨拙的方法，这里，n指尾递归函数的参数默认值,m是尾递归参数真正的参数。以上代码将阶乘尾递归函数tailFactorial变成只接受一个参数的factorial.<br>同时，利用ES6的函数默认值也能实现上面的函数柯里化：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">factorial</span>(<span class=\"params\">n, total=<span class=\"number\">1</span></span>)</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n === <span class=\"number\">1</span>) <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> factorial(n, n*total);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n"},{"title":"响应式web设计","date":"2017-02-09T02:39:24.000Z","_content":"\n> 本文摘自[响应式网页设计][1]\n\n# 什么是响应式设计\n\n响应式设计网页是由Ethan Marcotte提出的一个概念，指的是网页应该能根据不同分辨率的设备自适应和自动缩放等，当然也应该不仅限于此。\n\n响应式设计应该做到两点，响应式布局和响应式内容（图片、多媒体）。\n\n# 响应式布局\n\n我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏（portrait）、横屏（landscape），怎样才能让一种设计方案满足所有。\n\n这时候布局应该是一种弹性的栅格布局，不同尺寸下弹性适应。这里指的应该是Bootstrap的流式布局。\n\n## Meta标签定义\n\n使用viewport meta 标签在手机浏览器上控制布局\n\n    <meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″>\n    \n**注意：**很多人常常使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染而不会自动缩放，用户需要手动移动页面或者缩放。最差的是和initial-scale=1同时使用user-scalable=no或maximum-scale=1，这将使你的网站不能被缩放——用户不能放大/缩小网页来看到全部的内容。\n\n## 使用媒体查询\n\n- 设备类型\nall所有设备\nscreen 电脑显示器\nprint打印用纸或打印预览视图\nhandheld便携设备\ntv电视机类型的设备\nspeech语意和音频盒成器\nbraille盲人用点字法触觉回馈设备\nembossed盲文打印机\nprojection各种投影设备\ntty使用固定密度字母栅格的媒介，比如电传打字机和终端\n\n- 设备特性\nwidth浏览器宽度\nheight浏览器高度\ndevice-width设备屏幕分辨率的宽度值\ndevice-height设备屏幕分辨率的高度值\norientation浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape\naspect-ratio比例值，浏览器的纵横比\ndevice-aspect-ratio比例值，屏幕的纵横比\n\n媒体查询的例子如下：\n\n    /*for 240px width screen*/\n    @media only screen and (max-device-width:240px){\n    selector{...}\n    }\n    /*for 320px width screen*/\n    @media only screen and (min-device-width:241px) and (max-device-width:320px){\n    selector{...}\n    }\n    \n## 对于表格的处理\n\n- 隐藏不重要的数据列\n\n 实现方法：\n\n        media only screen and (max-width: 800px) {\n    \ttable td:nth-child(2), \n    \ttable th:nth-child(2) {display: none;}\n    }\n    \n- 多列横向变2列纵向\n\n    实现方法：\n    <thead>定位隐藏，<td>变块元素，并绑定对应<th>列名，然    后用伪元素的content:attr(data-th)实现<th>\n\n- 固定首列，剩余列横向滚动\n\n    实现代码：\n    \n    > thead {float:left;}\n    tbody {display:block;width:auto;overflow-x:auto;}\n    \n# 响应式图片\n\n## 处理原理\n\n浏览器获取用户终端的屏幕尺寸、分辨率逻辑处理后输出适应的图片，如屏幕分辨率320*480，那么我们匹配给它的是宽度应小于320px的图片。如果终端屏幕的DPI(devicepixels)DPI详解值很高，也就是高清屏，那么我们就得输出2倍分辨率的图形(宽:640px)；以保证在高清屏下图形的清晰度。\n\n## 解决方案\n\n其实W3C已经有一个用于响应式图形的草案：新定义标签`<picture>`，因为它还只是草案，目前还没有支持的浏览器，期待在不久的未来我们能用上。虽然目前不支持，但我们还是来了解下，为之后的内容做个铺垫。\n\n`<picture>`是一个图形element，内容由多个源图组成，并由CSS Media Queries来适配出合理图形，代码规范如下：\n\n\n    <picture width=\"500\" height=\"500\">\n       <source media=\"(min-width: 640px)\" srcset=\"large-1.jpg 1x, large-2.jpg 2x\">\n       <source media=\"(min-width: 320px)\" srcset=\"med-1.jpg 1x, med-2.jpg 2x\">\n       <source srcset=\"small-1.jpg 1x, small-2.jpg 2x\">\n       <img src=\"small-1.jpg\" alt=\"\">\n       <p>Accessible text</p>\n       <!-- Fallback content-->\n       <noscript>\n          <img src=\"external/imgs/small.jpg\" alt=\"Team photo\">\n       </noscript>\n    </picture>\n\nsource: 一个图片源；media: 媒体查询，用于适配屏幕尺寸；srcset: 图片链接，1x适应普通屏，2x适应高清屏；<noscript/>: 当浏览器不支持脚本时的一个替代方案；<img/>: 初始图片；另外还有一个无障碍文本，类似<img/>的alt属性。\n\n`<picture>`目前还不支持，但它的原理我们是可借鉴的，所以就诞生了一个用于图片响应式处理的类库Picturefill\n\n    <span data-picture data-alt=\"图片描述文本\">\n        <span data-src=\"small.jpg\"></span>\n        <span data-src=\"medium.jpg\"     data-media=\"(min-width: 400px)\"></span>\n        <span data-src=\"large.jpg\"      data-media=\"(min-width: 800px)\"></span>\n        <span data-src=\"extralarge.jpg\" data-media=\"(min-width: 1000px)\"></span>\n        <!-- 浏览器不支持JS时的备用方案. -->\n        <noscript>\n            <img src=\"external/imgs/small.jpg\" alt=\"图片描述文本\">\n        </noscript>\n    </span>\n\n\n其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，以适用于自身产品，例如图片加载失败的替代方案。\n\n## 高分辨率(DPI)下的响应式处理\n\n  > SVG：优点可承载色彩丰富、设计复杂图形，且渲染不会出现边缘不顺滑；缺点是IE的支持不完美，在我大中华这是硬伤。\n  \n   > Icon fonts：支持多浏览器，图形颜色大小的修改成本低，易于维护；图形表现单一，不支持色彩丰富且复杂的图形，IE6渲染有毛边。\n   \n   > -webkit-image-set:只支持单个图形的适配，不利于图形合并，兼容不完美（Safari 6+, Chrome 21+）\n\nJS检测：`var retina = window.devicePixelRatio > 1;`\n\nCSS Media Query:\n\n    @media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */\n           (min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */\n           (min-resolution: 2dppx),             /* The standard way */\n           (min-resolution: 192dpi)             /* dppx fallback */\n\n由于高清屏的特性，1px是由2×2个像素点来渲染\n\n  [1]: https://isux.tencent.com/responsive-web-design.html\n","source":"_posts/响应式web设计.md","raw":"---\ntitle: 响应式web设计\ndate: 2017-02-09 10:39:24\ntags: HTML5 CSS3\n---\n\n> 本文摘自[响应式网页设计][1]\n\n# 什么是响应式设计\n\n响应式设计网页是由Ethan Marcotte提出的一个概念，指的是网页应该能根据不同分辨率的设备自适应和自动缩放等，当然也应该不仅限于此。\n\n响应式设计应该做到两点，响应式布局和响应式内容（图片、多媒体）。\n\n# 响应式布局\n\n我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏（portrait）、横屏（landscape），怎样才能让一种设计方案满足所有。\n\n这时候布局应该是一种弹性的栅格布局，不同尺寸下弹性适应。这里指的应该是Bootstrap的流式布局。\n\n## Meta标签定义\n\n使用viewport meta 标签在手机浏览器上控制布局\n\n    <meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″>\n    \n**注意：**很多人常常使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染而不会自动缩放，用户需要手动移动页面或者缩放。最差的是和initial-scale=1同时使用user-scalable=no或maximum-scale=1，这将使你的网站不能被缩放——用户不能放大/缩小网页来看到全部的内容。\n\n## 使用媒体查询\n\n- 设备类型\nall所有设备\nscreen 电脑显示器\nprint打印用纸或打印预览视图\nhandheld便携设备\ntv电视机类型的设备\nspeech语意和音频盒成器\nbraille盲人用点字法触觉回馈设备\nembossed盲文打印机\nprojection各种投影设备\ntty使用固定密度字母栅格的媒介，比如电传打字机和终端\n\n- 设备特性\nwidth浏览器宽度\nheight浏览器高度\ndevice-width设备屏幕分辨率的宽度值\ndevice-height设备屏幕分辨率的高度值\norientation浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape\naspect-ratio比例值，浏览器的纵横比\ndevice-aspect-ratio比例值，屏幕的纵横比\n\n媒体查询的例子如下：\n\n    /*for 240px width screen*/\n    @media only screen and (max-device-width:240px){\n    selector{...}\n    }\n    /*for 320px width screen*/\n    @media only screen and (min-device-width:241px) and (max-device-width:320px){\n    selector{...}\n    }\n    \n## 对于表格的处理\n\n- 隐藏不重要的数据列\n\n 实现方法：\n\n        media only screen and (max-width: 800px) {\n    \ttable td:nth-child(2), \n    \ttable th:nth-child(2) {display: none;}\n    }\n    \n- 多列横向变2列纵向\n\n    实现方法：\n    <thead>定位隐藏，<td>变块元素，并绑定对应<th>列名，然    后用伪元素的content:attr(data-th)实现<th>\n\n- 固定首列，剩余列横向滚动\n\n    实现代码：\n    \n    > thead {float:left;}\n    tbody {display:block;width:auto;overflow-x:auto;}\n    \n# 响应式图片\n\n## 处理原理\n\n浏览器获取用户终端的屏幕尺寸、分辨率逻辑处理后输出适应的图片，如屏幕分辨率320*480，那么我们匹配给它的是宽度应小于320px的图片。如果终端屏幕的DPI(devicepixels)DPI详解值很高，也就是高清屏，那么我们就得输出2倍分辨率的图形(宽:640px)；以保证在高清屏下图形的清晰度。\n\n## 解决方案\n\n其实W3C已经有一个用于响应式图形的草案：新定义标签`<picture>`，因为它还只是草案，目前还没有支持的浏览器，期待在不久的未来我们能用上。虽然目前不支持，但我们还是来了解下，为之后的内容做个铺垫。\n\n`<picture>`是一个图形element，内容由多个源图组成，并由CSS Media Queries来适配出合理图形，代码规范如下：\n\n\n    <picture width=\"500\" height=\"500\">\n       <source media=\"(min-width: 640px)\" srcset=\"large-1.jpg 1x, large-2.jpg 2x\">\n       <source media=\"(min-width: 320px)\" srcset=\"med-1.jpg 1x, med-2.jpg 2x\">\n       <source srcset=\"small-1.jpg 1x, small-2.jpg 2x\">\n       <img src=\"small-1.jpg\" alt=\"\">\n       <p>Accessible text</p>\n       <!-- Fallback content-->\n       <noscript>\n          <img src=\"external/imgs/small.jpg\" alt=\"Team photo\">\n       </noscript>\n    </picture>\n\nsource: 一个图片源；media: 媒体查询，用于适配屏幕尺寸；srcset: 图片链接，1x适应普通屏，2x适应高清屏；<noscript/>: 当浏览器不支持脚本时的一个替代方案；<img/>: 初始图片；另外还有一个无障碍文本，类似<img/>的alt属性。\n\n`<picture>`目前还不支持，但它的原理我们是可借鉴的，所以就诞生了一个用于图片响应式处理的类库Picturefill\n\n    <span data-picture data-alt=\"图片描述文本\">\n        <span data-src=\"small.jpg\"></span>\n        <span data-src=\"medium.jpg\"     data-media=\"(min-width: 400px)\"></span>\n        <span data-src=\"large.jpg\"      data-media=\"(min-width: 800px)\"></span>\n        <span data-src=\"extralarge.jpg\" data-media=\"(min-width: 1000px)\"></span>\n        <!-- 浏览器不支持JS时的备用方案. -->\n        <noscript>\n            <img src=\"external/imgs/small.jpg\" alt=\"图片描述文本\">\n        </noscript>\n    </span>\n\n\n其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，以适用于自身产品，例如图片加载失败的替代方案。\n\n## 高分辨率(DPI)下的响应式处理\n\n  > SVG：优点可承载色彩丰富、设计复杂图形，且渲染不会出现边缘不顺滑；缺点是IE的支持不完美，在我大中华这是硬伤。\n  \n   > Icon fonts：支持多浏览器，图形颜色大小的修改成本低，易于维护；图形表现单一，不支持色彩丰富且复杂的图形，IE6渲染有毛边。\n   \n   > -webkit-image-set:只支持单个图形的适配，不利于图形合并，兼容不完美（Safari 6+, Chrome 21+）\n\nJS检测：`var retina = window.devicePixelRatio > 1;`\n\nCSS Media Query:\n\n    @media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */\n           (min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */\n           (min-resolution: 2dppx),             /* The standard way */\n           (min-resolution: 192dpi)             /* dppx fallback */\n\n由于高清屏的特性，1px是由2×2个像素点来渲染\n\n  [1]: https://isux.tencent.com/responsive-web-design.html\n","slug":"响应式web设计","published":1,"updated":"2019-03-17T03:04:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dw000wlvwv41dmemr2","content":"<blockquote>\n<p>本文摘自<a href=\"https://isux.tencent.com/responsive-web-design.html\" target=\"_blank\" rel=\"noopener\">响应式网页设计</a></p>\n</blockquote>\n<h1 id=\"什么是响应式设计\"><a href=\"#什么是响应式设计\" class=\"headerlink\" title=\"什么是响应式设计\"></a>什么是响应式设计</h1><p>响应式设计网页是由Ethan Marcotte提出的一个概念，指的是网页应该能根据不同分辨率的设备自适应和自动缩放等，当然也应该不仅限于此。</p>\n<p>响应式设计应该做到两点，响应式布局和响应式内容（图片、多媒体）。</p>\n<h1 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h1><p>我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏（portrait）、横屏（landscape），怎样才能让一种设计方案满足所有。</p>\n<p>这时候布局应该是一种弹性的栅格布局，不同尺寸下弹性适应。这里指的应该是Bootstrap的流式布局。</p>\n<h2 id=\"Meta标签定义\"><a href=\"#Meta标签定义\" class=\"headerlink\" title=\"Meta标签定义\"></a>Meta标签定义</h2><p>使用viewport meta 标签在手机浏览器上控制布局</p>\n<pre><code>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″&gt;\n</code></pre><p><strong>注意：</strong>很多人常常使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染而不会自动缩放，用户需要手动移动页面或者缩放。最差的是和initial-scale=1同时使用user-scalable=no或maximum-scale=1，这将使你的网站不能被缩放——用户不能放大/缩小网页来看到全部的内容。</p>\n<h2 id=\"使用媒体查询\"><a href=\"#使用媒体查询\" class=\"headerlink\" title=\"使用媒体查询\"></a>使用媒体查询</h2><ul>\n<li><p>设备类型<br>all所有设备<br>screen 电脑显示器<br>print打印用纸或打印预览视图<br>handheld便携设备<br>tv电视机类型的设备<br>speech语意和音频盒成器<br>braille盲人用点字法触觉回馈设备<br>embossed盲文打印机<br>projection各种投影设备<br>tty使用固定密度字母栅格的媒介，比如电传打字机和终端</p>\n</li>\n<li><p>设备特性<br>width浏览器宽度<br>height浏览器高度<br>device-width设备屏幕分辨率的宽度值<br>device-height设备屏幕分辨率的高度值<br>orientation浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape<br>aspect-ratio比例值，浏览器的纵横比<br>device-aspect-ratio比例值，屏幕的纵横比</p>\n</li>\n</ul>\n<p>媒体查询的例子如下：</p>\n<pre><code>/*for 240px width screen*/\n@media only screen and (max-device-width:240px){\nselector{...}\n}\n/*for 320px width screen*/\n@media only screen and (min-device-width:241px) and (max-device-width:320px){\nselector{...}\n}\n</code></pre><h2 id=\"对于表格的处理\"><a href=\"#对于表格的处理\" class=\"headerlink\" title=\"对于表格的处理\"></a>对于表格的处理</h2><ul>\n<li><p>隐藏不重要的数据列</p>\n<p>实现方法：</p>\n<pre><code>media only screen and (max-width: 800px) {\ntable td:nth-child(2), \ntable th:nth-child(2) {display: none;}\n</code></pre><p>  }</p>\n</li>\n<li><p>多列横向变2列纵向</p>\n<p>  实现方法：<br>  <thead>定位隐藏，</thead><td>变块元素，并绑定对应<th>列名，然    后用伪元素的content:attr(data-th)实现</th><th></th></td></p>\n</li>\n<li><p>固定首列，剩余列横向滚动</p>\n<p>  实现代码：</p>\n<blockquote>\n<p>thead {float:left;}<br>  tbody {display:block;width:auto;overflow-x:auto;}</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"响应式图片\"><a href=\"#响应式图片\" class=\"headerlink\" title=\"响应式图片\"></a>响应式图片</h1><h2 id=\"处理原理\"><a href=\"#处理原理\" class=\"headerlink\" title=\"处理原理\"></a>处理原理</h2><p>浏览器获取用户终端的屏幕尺寸、分辨率逻辑处理后输出适应的图片，如屏幕分辨率320*480，那么我们匹配给它的是宽度应小于320px的图片。如果终端屏幕的DPI(devicepixels)DPI详解值很高，也就是高清屏，那么我们就得输出2倍分辨率的图形(宽:640px)；以保证在高清屏下图形的清晰度。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>其实W3C已经有一个用于响应式图形的草案：新定义标签<code>&lt;picture&gt;</code>，因为它还只是草案，目前还没有支持的浏览器，期待在不久的未来我们能用上。虽然目前不支持，但我们还是来了解下，为之后的内容做个铺垫。</p>\n<p><code>&lt;picture&gt;</code>是一个图形element，内容由多个源图组成，并由CSS Media Queries来适配出合理图形，代码规范如下：</p>\n<pre><code>&lt;picture width=&quot;500&quot; height=&quot;500&quot;&gt;\n   &lt;source media=&quot;(min-width: 640px)&quot; srcset=&quot;large-1.jpg 1x, large-2.jpg 2x&quot;&gt;\n   &lt;source media=&quot;(min-width: 320px)&quot; srcset=&quot;med-1.jpg 1x, med-2.jpg 2x&quot;&gt;\n   &lt;source srcset=&quot;small-1.jpg 1x, small-2.jpg 2x&quot;&gt;\n   &lt;img src=&quot;small-1.jpg&quot; alt=&quot;&quot;&gt;\n   &lt;p&gt;Accessible text&lt;/p&gt;\n   &lt;!-- Fallback content--&gt;\n   &lt;noscript&gt;\n      &lt;img src=&quot;external/imgs/small.jpg&quot; alt=&quot;Team photo&quot;&gt;\n   &lt;/noscript&gt;\n&lt;/picture&gt;\n</code></pre><p>source: 一个图片源；media: 媒体查询，用于适配屏幕尺寸；srcset: 图片链接，1x适应普通屏，2x适应高清屏；<noscript>: 当浏览器不支持脚本时的一个替代方案；<img>: 初始图片；另外还有一个无障碍文本，类似<img>的alt属性。</noscript></p>\n<p><code>&lt;picture&gt;</code>目前还不支持，但它的原理我们是可借鉴的，所以就诞生了一个用于图片响应式处理的类库Picturefill</p>\n<pre><code>&lt;span data-picture data-alt=&quot;图片描述文本&quot;&gt;\n    &lt;span data-src=&quot;small.jpg&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;medium.jpg&quot;     data-media=&quot;(min-width: 400px)&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;large.jpg&quot;      data-media=&quot;(min-width: 800px)&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;extralarge.jpg&quot; data-media=&quot;(min-width: 1000px)&quot;&gt;&lt;/span&gt;\n    &lt;!-- 浏览器不支持JS时的备用方案. --&gt;\n    &lt;noscript&gt;\n        &lt;img src=&quot;external/imgs/small.jpg&quot; alt=&quot;图片描述文本&quot;&gt;\n    &lt;/noscript&gt;\n&lt;/span&gt;\n</code></pre><p>其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，以适用于自身产品，例如图片加载失败的替代方案。</p>\n<h2 id=\"高分辨率-DPI-下的响应式处理\"><a href=\"#高分辨率-DPI-下的响应式处理\" class=\"headerlink\" title=\"高分辨率(DPI)下的响应式处理\"></a>高分辨率(DPI)下的响应式处理</h2><blockquote>\n<p>SVG：优点可承载色彩丰富、设计复杂图形，且渲染不会出现边缘不顺滑；缺点是IE的支持不完美，在我大中华这是硬伤。</p>\n<p>Icon fonts：支持多浏览器，图形颜色大小的修改成本低，易于维护；图形表现单一，不支持色彩丰富且复杂的图形，IE6渲染有毛边。</p>\n<p>-webkit-image-set:只支持单个图形的适配，不利于图形合并，兼容不完美（Safari 6+, Chrome 21+）</p>\n</blockquote>\n<p>JS检测：<code>var retina = window.devicePixelRatio &gt; 1;</code></p>\n<p>CSS Media Query:</p>\n<pre><code>@media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */\n       (min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */\n       (min-resolution: 2dppx),             /* The standard way */\n       (min-resolution: 192dpi)             /* dppx fallback */\n</code></pre><p>由于高清屏的特性，1px是由2×2个像素点来渲染</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文摘自<a href=\"https://isux.tencent.com/responsive-web-design.html\" target=\"_blank\" rel=\"noopener\">响应式网页设计</a></p>\n</blockquote>\n<h1 id=\"什么是响应式设计\"><a href=\"#什么是响应式设计\" class=\"headerlink\" title=\"什么是响应式设计\"></a>什么是响应式设计</h1><p>响应式设计网页是由Ethan Marcotte提出的一个概念，指的是网页应该能根据不同分辨率的设备自适应和自动缩放等，当然也应该不仅限于此。</p>\n<p>响应式设计应该做到两点，响应式布局和响应式内容（图片、多媒体）。</p>\n<h1 id=\"响应式布局\"><a href=\"#响应式布局\" class=\"headerlink\" title=\"响应式布局\"></a>响应式布局</h1><p>我们需要兼容不同屏幕分辨率、清晰度以及屏幕定向方式竖屏（portrait）、横屏（landscape），怎样才能让一种设计方案满足所有。</p>\n<p>这时候布局应该是一种弹性的栅格布局，不同尺寸下弹性适应。这里指的应该是Bootstrap的流式布局。</p>\n<h2 id=\"Meta标签定义\"><a href=\"#Meta标签定义\" class=\"headerlink\" title=\"Meta标签定义\"></a>Meta标签定义</h2><p>使用viewport meta 标签在手机浏览器上控制布局</p>\n<pre><code>&lt;meta name=”viewport” content=”width=device-width, initial-scale=1, maximum-scale=1″&gt;\n</code></pre><p><strong>注意：</strong>很多人常常使用initial-scale=1到非响应式网站上，这会让网站以100%宽度渲染而不会自动缩放，用户需要手动移动页面或者缩放。最差的是和initial-scale=1同时使用user-scalable=no或maximum-scale=1，这将使你的网站不能被缩放——用户不能放大/缩小网页来看到全部的内容。</p>\n<h2 id=\"使用媒体查询\"><a href=\"#使用媒体查询\" class=\"headerlink\" title=\"使用媒体查询\"></a>使用媒体查询</h2><ul>\n<li><p>设备类型<br>all所有设备<br>screen 电脑显示器<br>print打印用纸或打印预览视图<br>handheld便携设备<br>tv电视机类型的设备<br>speech语意和音频盒成器<br>braille盲人用点字法触觉回馈设备<br>embossed盲文打印机<br>projection各种投影设备<br>tty使用固定密度字母栅格的媒介，比如电传打字机和终端</p>\n</li>\n<li><p>设备特性<br>width浏览器宽度<br>height浏览器高度<br>device-width设备屏幕分辨率的宽度值<br>device-height设备屏幕分辨率的高度值<br>orientation浏览器窗口的方向纵向还是横向，当窗口的高度值大于等于宽度时该特性值为portrait，否则为landscape<br>aspect-ratio比例值，浏览器的纵横比<br>device-aspect-ratio比例值，屏幕的纵横比</p>\n</li>\n</ul>\n<p>媒体查询的例子如下：</p>\n<pre><code>/*for 240px width screen*/\n@media only screen and (max-device-width:240px){\nselector{...}\n}\n/*for 320px width screen*/\n@media only screen and (min-device-width:241px) and (max-device-width:320px){\nselector{...}\n}\n</code></pre><h2 id=\"对于表格的处理\"><a href=\"#对于表格的处理\" class=\"headerlink\" title=\"对于表格的处理\"></a>对于表格的处理</h2><ul>\n<li><p>隐藏不重要的数据列</p>\n<p>实现方法：</p>\n<pre><code>media only screen and (max-width: 800px) {\ntable td:nth-child(2), \ntable th:nth-child(2) {display: none;}\n</code></pre><p>  }</p>\n</li>\n<li><p>多列横向变2列纵向</p>\n<p>  实现方法：<br>  <thead>定位隐藏，</thead><td>变块元素，并绑定对应<th>列名，然    后用伪元素的content:attr(data-th)实现</th><th></th></td></p>\n</li>\n<li><p>固定首列，剩余列横向滚动</p>\n<p>  实现代码：</p>\n<blockquote>\n<p>thead {float:left;}<br>  tbody {display:block;width:auto;overflow-x:auto;}</p>\n</blockquote>\n</li>\n</ul>\n<h1 id=\"响应式图片\"><a href=\"#响应式图片\" class=\"headerlink\" title=\"响应式图片\"></a>响应式图片</h1><h2 id=\"处理原理\"><a href=\"#处理原理\" class=\"headerlink\" title=\"处理原理\"></a>处理原理</h2><p>浏览器获取用户终端的屏幕尺寸、分辨率逻辑处理后输出适应的图片，如屏幕分辨率320*480，那么我们匹配给它的是宽度应小于320px的图片。如果终端屏幕的DPI(devicepixels)DPI详解值很高，也就是高清屏，那么我们就得输出2倍分辨率的图形(宽:640px)；以保证在高清屏下图形的清晰度。</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>其实W3C已经有一个用于响应式图形的草案：新定义标签<code>&lt;picture&gt;</code>，因为它还只是草案，目前还没有支持的浏览器，期待在不久的未来我们能用上。虽然目前不支持，但我们还是来了解下，为之后的内容做个铺垫。</p>\n<p><code>&lt;picture&gt;</code>是一个图形element，内容由多个源图组成，并由CSS Media Queries来适配出合理图形，代码规范如下：</p>\n<pre><code>&lt;picture width=&quot;500&quot; height=&quot;500&quot;&gt;\n   &lt;source media=&quot;(min-width: 640px)&quot; srcset=&quot;large-1.jpg 1x, large-2.jpg 2x&quot;&gt;\n   &lt;source media=&quot;(min-width: 320px)&quot; srcset=&quot;med-1.jpg 1x, med-2.jpg 2x&quot;&gt;\n   &lt;source srcset=&quot;small-1.jpg 1x, small-2.jpg 2x&quot;&gt;\n   &lt;img src=&quot;small-1.jpg&quot; alt=&quot;&quot;&gt;\n   &lt;p&gt;Accessible text&lt;/p&gt;\n   &lt;!-- Fallback content--&gt;\n   &lt;noscript&gt;\n      &lt;img src=&quot;external/imgs/small.jpg&quot; alt=&quot;Team photo&quot;&gt;\n   &lt;/noscript&gt;\n&lt;/picture&gt;\n</code></pre><p>source: 一个图片源；media: 媒体查询，用于适配屏幕尺寸；srcset: 图片链接，1x适应普通屏，2x适应高清屏；<noscript>: 当浏览器不支持脚本时的一个替代方案；<img>: 初始图片；另外还有一个无障碍文本，类似<img>的alt属性。</noscript></p>\n<p><code>&lt;picture&gt;</code>目前还不支持，但它的原理我们是可借鉴的，所以就诞生了一个用于图片响应式处理的类库Picturefill</p>\n<pre><code>&lt;span data-picture data-alt=&quot;图片描述文本&quot;&gt;\n    &lt;span data-src=&quot;small.jpg&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;medium.jpg&quot;     data-media=&quot;(min-width: 400px)&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;large.jpg&quot;      data-media=&quot;(min-width: 800px)&quot;&gt;&lt;/span&gt;\n    &lt;span data-src=&quot;extralarge.jpg&quot; data-media=&quot;(min-width: 1000px)&quot;&gt;&lt;/span&gt;\n    &lt;!-- 浏览器不支持JS时的备用方案. --&gt;\n    &lt;noscript&gt;\n        &lt;img src=&quot;external/imgs/small.jpg&quot; alt=&quot;图片描述文本&quot;&gt;\n    &lt;/noscript&gt;\n&lt;/span&gt;\n</code></pre><p>其原理就是JS获取Source的源以及CSS Media Queries规则，输出适应图片， 逻辑细节这里不再解析，感兴趣的可查看其JS代码，逻辑不是很复杂，也可以自己封装一个类库，以适用于自身产品，例如图片加载失败的替代方案。</p>\n<h2 id=\"高分辨率-DPI-下的响应式处理\"><a href=\"#高分辨率-DPI-下的响应式处理\" class=\"headerlink\" title=\"高分辨率(DPI)下的响应式处理\"></a>高分辨率(DPI)下的响应式处理</h2><blockquote>\n<p>SVG：优点可承载色彩丰富、设计复杂图形，且渲染不会出现边缘不顺滑；缺点是IE的支持不完美，在我大中华这是硬伤。</p>\n<p>Icon fonts：支持多浏览器，图形颜色大小的修改成本低，易于维护；图形表现单一，不支持色彩丰富且复杂的图形，IE6渲染有毛边。</p>\n<p>-webkit-image-set:只支持单个图形的适配，不利于图形合并，兼容不完美（Safari 6+, Chrome 21+）</p>\n</blockquote>\n<p>JS检测：<code>var retina = window.devicePixelRatio &gt; 1;</code></p>\n<p>CSS Media Query:</p>\n<pre><code>@media (-webkit-min-device-pixel-ratio: 2), /* Webkit-based browsers */\n       (min--moz-device-pixel-ratio: 2),    /* Older Firefox browsers (prior to Firefox 16) */\n       (min-resolution: 2dppx),             /* The standard way */\n       (min-resolution: 192dpi)             /* dppx fallback */\n</code></pre><p>由于高清屏的特性，1px是由2×2个像素点来渲染</p>\n"},{"title":"循环中redis读取性能问题","date":"2019-04-17T16:00:00.000Z","_content":"> 循环中\b进行读取操作是一种非常耗内存的方式\n\n\b公司的业务中\b经常使用redis来存储数据，所以操作redis是我日常工作的一部分。之所以选择redis，老大解释的原因有三个：一是因为redis读取容易和高速，二是redis支持丰富的数据类型，三是redis的操作都是原子性的，要么成功要么失败。选择redis的原因也是redis相对于其他数据库的优势。部分业务会根据需要持久化，落库。\n\n今天遇到一个关于redis读取性能的问题，代码大概如下：\n```php\n$recrods =  $redis->hgetall(\"records\");\nforeach($records as $key => $value){\n    $value1 =  $redis->hget(\"key1\",$key);\n    $value2 =  $redis->hget(\"key2\",$key);\n    $value3 =  $redis->hget(\"key3\",$key);\n    //...\b省略其他代码\n}\n```\n首先获取某个key下的全部键值，遍历这个键值表又操作了几次读取操作。当业务量少的时候，没有发现什么问题，当并发请求变多的时候，突然发现服务器的cpu飙升报警，redis进程被卡住了。经过排查，发现是上面这段循环代码导致的。\n\n回头看这段代码确实写得很有问题，想当然的什么都使用循环解决，却没有考虑到程序的性能问题。\n\n\b优化这段代码，首先想到的是通过管道来进行读取操作，但是发现优化不是很明显。接着想到问题显然出现在循环中多次进行读取操作，多次请求了redis导致的，如果可以把多个请求合并成一个请求就好了。\n\nredis的`hmget`命令适合\b用于这个场景下的问题，此命令用于返回哈希表中，一个或多个给定字段的值。所以把所有的\bfield合并成一个数组，就可以返回对应的多个值，然后再进行处理，就不用再一个一个进行`hget`操作。\n优化后的代码大概如下：\n```php\n$recrods =  $redis->hgetall(\"records\");\nforeach($records as $key => $value){\n    $keys[] = $key;\n}\n$values1 =  $redis->hmget(\"key1\",$keys);\n$values2 =  $redis->hmget(\"key2\",$keys);\n$values3 =  $redis->hmget(\"key3\",$keys);\n//...\b省略其他代码\n```\n\n可以有多个新建的数组，数组循环是一件很快的事情，但是在循环中多次请求存取并不是一件美好的事情。重构后的代码，虽然牺牲\b了空间，但节省了时间。\n","source":"_posts/循环中的redis读取性能问题.md","raw":"---\ntitle: 循环中redis读取性能问题\ndate: 2019-04-18\ntags: redis 循环\n---\n> 循环中\b进行读取操作是一种非常耗内存的方式\n\n\b公司的业务中\b经常使用redis来存储数据，所以操作redis是我日常工作的一部分。之所以选择redis，老大解释的原因有三个：一是因为redis读取容易和高速，二是redis支持丰富的数据类型，三是redis的操作都是原子性的，要么成功要么失败。选择redis的原因也是redis相对于其他数据库的优势。部分业务会根据需要持久化，落库。\n\n今天遇到一个关于redis读取性能的问题，代码大概如下：\n```php\n$recrods =  $redis->hgetall(\"records\");\nforeach($records as $key => $value){\n    $value1 =  $redis->hget(\"key1\",$key);\n    $value2 =  $redis->hget(\"key2\",$key);\n    $value3 =  $redis->hget(\"key3\",$key);\n    //...\b省略其他代码\n}\n```\n首先获取某个key下的全部键值，遍历这个键值表又操作了几次读取操作。当业务量少的时候，没有发现什么问题，当并发请求变多的时候，突然发现服务器的cpu飙升报警，redis进程被卡住了。经过排查，发现是上面这段循环代码导致的。\n\n回头看这段代码确实写得很有问题，想当然的什么都使用循环解决，却没有考虑到程序的性能问题。\n\n\b优化这段代码，首先想到的是通过管道来进行读取操作，但是发现优化不是很明显。接着想到问题显然出现在循环中多次进行读取操作，多次请求了redis导致的，如果可以把多个请求合并成一个请求就好了。\n\nredis的`hmget`命令适合\b用于这个场景下的问题，此命令用于返回哈希表中，一个或多个给定字段的值。所以把所有的\bfield合并成一个数组，就可以返回对应的多个值，然后再进行处理，就不用再一个一个进行`hget`操作。\n优化后的代码大概如下：\n```php\n$recrods =  $redis->hgetall(\"records\");\nforeach($records as $key => $value){\n    $keys[] = $key;\n}\n$values1 =  $redis->hmget(\"key1\",$keys);\n$values2 =  $redis->hmget(\"key2\",$keys);\n$values3 =  $redis->hmget(\"key3\",$keys);\n//...\b省略其他代码\n```\n\n可以有多个新建的数组，数组循环是一件很快的事情，但是在循环中多次请求存取并不是一件美好的事情。重构后的代码，虽然牺牲\b了空间，但节省了时间。\n","slug":"循环中的redis读取性能问题","published":1,"updated":"2019-04-18T15:26:13.404Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dx000zlvwv0s8tbv27","content":"<blockquote>\n<p>循环中\b进行读取操作是一种非常耗内存的方式</p>\n</blockquote>\n<p>\b公司的业务中\b经常使用redis来存储数据，所以操作redis是我日常工作的一部分。之所以选择redis，老大解释的原因有三个：一是因为redis读取容易和高速，二是redis支持丰富的数据类型，三是redis的操作都是原子性的，要么成功要么失败。选择redis的原因也是redis相对于其他数据库的优势。部分业务会根据需要持久化，落库。</p>\n<p>今天遇到一个关于redis读取性能的问题，代码大概如下：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$recrods =  $redis-&gt;hgetall(<span class=\"string\">\"records\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($records <span class=\"keyword\">as</span> $key =&gt; $value)&#123;</span><br><span class=\"line\">    $value1 =  $redis-&gt;hget(<span class=\"string\">\"key1\"</span>,$key);</span><br><span class=\"line\">    $value2 =  $redis-&gt;hget(<span class=\"string\">\"key2\"</span>,$key);</span><br><span class=\"line\">    $value3 =  $redis-&gt;hget(<span class=\"string\">\"key3\"</span>,$key);</span><br><span class=\"line\">    <span class=\"comment\">//...\b省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先获取某个key下的全部键值，遍历这个键值表又操作了几次读取操作。当业务量少的时候，没有发现什么问题，当并发请求变多的时候，突然发现服务器的cpu飙升报警，redis进程被卡住了。经过排查，发现是上面这段循环代码导致的。</p>\n<p>回头看这段代码确实写得很有问题，想当然的什么都使用循环解决，却没有考虑到程序的性能问题。</p>\n<p>\b优化这段代码，首先想到的是通过管道来进行读取操作，但是发现优化不是很明显。接着想到问题显然出现在循环中多次进行读取操作，多次请求了redis导致的，如果可以把多个请求合并成一个请求就好了。</p>\n<p>redis的<code>hmget</code>命令适合\b用于这个场景下的问题，此命令用于返回哈希表中，一个或多个给定字段的值。所以把所有的\bfield合并成一个数组，就可以返回对应的多个值，然后再进行处理，就不用再一个一个进行<code>hget</code>操作。<br>优化后的代码大概如下：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$recrods =  $redis-&gt;hgetall(<span class=\"string\">\"records\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($records <span class=\"keyword\">as</span> $key =&gt; $value)&#123;</span><br><span class=\"line\">    $keys[] = $key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$values1 =  $redis-&gt;hmget(<span class=\"string\">\"key1\"</span>,$keys);</span><br><span class=\"line\">$values2 =  $redis-&gt;hmget(<span class=\"string\">\"key2\"</span>,$keys);</span><br><span class=\"line\">$values3 =  $redis-&gt;hmget(<span class=\"string\">\"key3\"</span>,$keys);</span><br><span class=\"line\"><span class=\"comment\">//...\b省略其他代码</span></span><br></pre></td></tr></table></figure></p>\n<p>可以有多个新建的数组，数组循环是一件很快的事情，但是在循环中多次请求存取并不是一件美好的事情。重构后的代码，虽然牺牲\b了空间，但节省了时间。</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>循环中\b进行读取操作是一种非常耗内存的方式</p>\n</blockquote>\n<p>\b公司的业务中\b经常使用redis来存储数据，所以操作redis是我日常工作的一部分。之所以选择redis，老大解释的原因有三个：一是因为redis读取容易和高速，二是redis支持丰富的数据类型，三是redis的操作都是原子性的，要么成功要么失败。选择redis的原因也是redis相对于其他数据库的优势。部分业务会根据需要持久化，落库。</p>\n<p>今天遇到一个关于redis读取性能的问题，代码大概如下：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$recrods =  $redis-&gt;hgetall(<span class=\"string\">\"records\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($records <span class=\"keyword\">as</span> $key =&gt; $value)&#123;</span><br><span class=\"line\">    $value1 =  $redis-&gt;hget(<span class=\"string\">\"key1\"</span>,$key);</span><br><span class=\"line\">    $value2 =  $redis-&gt;hget(<span class=\"string\">\"key2\"</span>,$key);</span><br><span class=\"line\">    $value3 =  $redis-&gt;hget(<span class=\"string\">\"key3\"</span>,$key);</span><br><span class=\"line\">    <span class=\"comment\">//...\b省略其他代码</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>首先获取某个key下的全部键值，遍历这个键值表又操作了几次读取操作。当业务量少的时候，没有发现什么问题，当并发请求变多的时候，突然发现服务器的cpu飙升报警，redis进程被卡住了。经过排查，发现是上面这段循环代码导致的。</p>\n<p>回头看这段代码确实写得很有问题，想当然的什么都使用循环解决，却没有考虑到程序的性能问题。</p>\n<p>\b优化这段代码，首先想到的是通过管道来进行读取操作，但是发现优化不是很明显。接着想到问题显然出现在循环中多次进行读取操作，多次请求了redis导致的，如果可以把多个请求合并成一个请求就好了。</p>\n<p>redis的<code>hmget</code>命令适合\b用于这个场景下的问题，此命令用于返回哈希表中，一个或多个给定字段的值。所以把所有的\bfield合并成一个数组，就可以返回对应的多个值，然后再进行处理，就不用再一个一个进行<code>hget</code>操作。<br>优化后的代码大概如下：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$recrods =  $redis-&gt;hgetall(<span class=\"string\">\"records\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">foreach</span>($records <span class=\"keyword\">as</span> $key =&gt; $value)&#123;</span><br><span class=\"line\">    $keys[] = $key;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">$values1 =  $redis-&gt;hmget(<span class=\"string\">\"key1\"</span>,$keys);</span><br><span class=\"line\">$values2 =  $redis-&gt;hmget(<span class=\"string\">\"key2\"</span>,$keys);</span><br><span class=\"line\">$values3 =  $redis-&gt;hmget(<span class=\"string\">\"key3\"</span>,$keys);</span><br><span class=\"line\"><span class=\"comment\">//...\b省略其他代码</span></span><br></pre></td></tr></table></figure></p>\n<p>可以有多个新建的数组，数组循环是一件很快的事情，但是在循环中多次请求存取并不是一件美好的事情。重构后的代码，虽然牺牲\b了空间，但节省了时间。</p>\n"},{"title":"微信公众号自定义菜单","date":"2017-04-06T13:17:57.000Z","_content":"> 好久没写日记，好久没更新Github了，甚是想念~这几个星期在忙着写论文，希望导师不要改动多就好 ~\\(≧▽≦)/~\n\n#微信公众号自定义菜单\n\n首先打开微信公众号接口调试工具，[传送门在此][1]\n我们的目的是要自定义菜单：\n选择接口类型：自定义菜单\n选择接口列表：自定义菜单创建接口/menu/create\n这时候我们发现有一个参数列表，其中`access_token`是通过基础支持来获取的，`body`则是我们自定义菜单的json数据，具体怎么填写这两个参数如下：\n\n## `access_token`\n\n还是在微信公众号接口调试工具的页面\n接口类型：基础支持\n接口列表：获取access token接口/token\n参数列表：appid 这是我们申请的公众号的appid;secret 同上。如果我们申请了公众号，每个公众号都会有这两个值，直接复制这两个值填入相应的输入框，点击检查问题按钮便可以得到`access_token`。\n\n##`body`\n在这里主要是定义我们的自定义菜单类型，常见的有`click`,'view','pic_weixin'等，配置的格式举例如下：\n`\n{\n     \"button\":[\n     {\t\n          \"type\":\"click\",\n          \"name\":\"今日歌曲\",\n          \"key\":\"V1001_TODAY_MUSIC\"\n      },\n      {\n                    \"type\": \"pic_weixin\", \n                    \"name\": \"微信相册发图\", \n                    \"key\": \"rselfmenu_1_2\", \n                    \"sub_button\": [\n                     {\t\n               \"type\":\"view\",\n               \"name\":\"搜索\",\n               \"url\":\"http://www.soso.com/\"\n            },\n            {\n               \"type\":\"view\",\n               \"name\":\"视频\",\n               \"url\":\"http://v.qq.com/\"\n            },\n            {\n               \"type\":\"click\",\n               \"name\":\"赞一下我们\",\n               \"key\":\"V1001_GOOD\"\n            }]\n                }\n            ]\n`\n其中`sub_button`是二级菜单，它的数据格式也像一级菜单那样设置。\n\n以上的内容十分简单，并不需要任何编程知识。以后应该会主要更新自己学习`vue.js`和`webpack`的记录，希望自己能坚持下来！\n\n  [1]: https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&type=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95&form=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%20/menu/create","source":"_posts/微信公众号自定义菜单.md","raw":"---\ntitle: 微信公众号自定义菜单\ndate: 2017-04-06 21:17:57\ntags: 微信公众号\n---\n> 好久没写日记，好久没更新Github了，甚是想念~这几个星期在忙着写论文，希望导师不要改动多就好 ~\\(≧▽≦)/~\n\n#微信公众号自定义菜单\n\n首先打开微信公众号接口调试工具，[传送门在此][1]\n我们的目的是要自定义菜单：\n选择接口类型：自定义菜单\n选择接口列表：自定义菜单创建接口/menu/create\n这时候我们发现有一个参数列表，其中`access_token`是通过基础支持来获取的，`body`则是我们自定义菜单的json数据，具体怎么填写这两个参数如下：\n\n## `access_token`\n\n还是在微信公众号接口调试工具的页面\n接口类型：基础支持\n接口列表：获取access token接口/token\n参数列表：appid 这是我们申请的公众号的appid;secret 同上。如果我们申请了公众号，每个公众号都会有这两个值，直接复制这两个值填入相应的输入框，点击检查问题按钮便可以得到`access_token`。\n\n##`body`\n在这里主要是定义我们的自定义菜单类型，常见的有`click`,'view','pic_weixin'等，配置的格式举例如下：\n`\n{\n     \"button\":[\n     {\t\n          \"type\":\"click\",\n          \"name\":\"今日歌曲\",\n          \"key\":\"V1001_TODAY_MUSIC\"\n      },\n      {\n                    \"type\": \"pic_weixin\", \n                    \"name\": \"微信相册发图\", \n                    \"key\": \"rselfmenu_1_2\", \n                    \"sub_button\": [\n                     {\t\n               \"type\":\"view\",\n               \"name\":\"搜索\",\n               \"url\":\"http://www.soso.com/\"\n            },\n            {\n               \"type\":\"view\",\n               \"name\":\"视频\",\n               \"url\":\"http://v.qq.com/\"\n            },\n            {\n               \"type\":\"click\",\n               \"name\":\"赞一下我们\",\n               \"key\":\"V1001_GOOD\"\n            }]\n                }\n            ]\n`\n其中`sub_button`是二级菜单，它的数据格式也像一级菜单那样设置。\n\n以上的内容十分简单，并不需要任何编程知识。以后应该会主要更新自己学习`vue.js`和`webpack`的记录，希望自己能坚持下来！\n\n  [1]: https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&type=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95&form=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%20/menu/create","slug":"微信公众号自定义菜单","published":1,"updated":"2019-03-17T03:04:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dx0010lvwv7q4expiz","content":"<blockquote>\n<p>好久没写日记，好久没更新Github了，甚是想念~这几个星期在忙着写论文，希望导师不要改动多就好 ~(≧▽≦)/~</p>\n</blockquote>\n<p>#微信公众号自定义菜单</p>\n<p>首先打开微信公众号接口调试工具，<a href=\"https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95&amp;form=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%20/menu/create\" target=\"_blank\" rel=\"noopener\">传送门在此</a><br>我们的目的是要自定义菜单：<br>选择接口类型：自定义菜单<br>选择接口列表：自定义菜单创建接口/menu/create<br>这时候我们发现有一个参数列表，其中<code>access_token</code>是通过基础支持来获取的，<code>body</code>则是我们自定义菜单的json数据，具体怎么填写这两个参数如下：</p>\n<h2 id=\"access-token\"><a href=\"#access-token\" class=\"headerlink\" title=\"access_token\"></a><code>access_token</code></h2><p>还是在微信公众号接口调试工具的页面<br>接口类型：基础支持<br>接口列表：获取access token接口/token<br>参数列表：appid 这是我们申请的公众号的appid;secret 同上。如果我们申请了公众号，每个公众号都会有这两个值，直接复制这两个值填入相应的输入框，点击检查问题按钮便可以得到<code>access_token</code>。</p>\n<p>##<code>body</code><br>在这里主要是定义我们的自定义菜单类型，常见的有<code>click</code>,’view’,’pic_weixin’等，配置的格式举例如下：<br><code>{\n     &quot;button&quot;:[\n     {    \n          &quot;type&quot;:&quot;click&quot;,\n          &quot;name&quot;:&quot;今日歌曲&quot;,\n          &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot;\n      },\n      {\n                    &quot;type&quot;: &quot;pic_weixin&quot;, \n                    &quot;name&quot;: &quot;微信相册发图&quot;, \n                    &quot;key&quot;: &quot;rselfmenu_1_2&quot;, \n                    &quot;sub_button&quot;: [\n                     {    \n               &quot;type&quot;:&quot;view&quot;,\n               &quot;name&quot;:&quot;搜索&quot;,\n               &quot;url&quot;:&quot;http://www.soso.com/&quot;\n            },\n            {\n               &quot;type&quot;:&quot;view&quot;,\n               &quot;name&quot;:&quot;视频&quot;,\n               &quot;url&quot;:&quot;http://v.qq.com/&quot;\n            },\n            {\n               &quot;type&quot;:&quot;click&quot;,\n               &quot;name&quot;:&quot;赞一下我们&quot;,\n               &quot;key&quot;:&quot;V1001_GOOD&quot;\n            }]\n                }\n            ]</code><br>其中<code>sub_button</code>是二级菜单，它的数据格式也像一级菜单那样设置。</p>\n<p>以上的内容十分简单，并不需要任何编程知识。以后应该会主要更新自己学习<code>vue.js</code>和<code>webpack</code>的记录，希望自己能坚持下来！</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>好久没写日记，好久没更新Github了，甚是想念~这几个星期在忙着写论文，希望导师不要改动多就好 ~(≧▽≦)/~</p>\n</blockquote>\n<p>#微信公众号自定义菜单</p>\n<p>首先打开微信公众号接口调试工具，<a href=\"https://mp.weixin.qq.com/debug/cgi-bin/apiinfo?t=index&amp;type=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95&amp;form=%E8%87%AA%E5%AE%9A%E4%B9%89%E8%8F%9C%E5%8D%95%E5%88%9B%E5%BB%BA%E6%8E%A5%E5%8F%A3%20/menu/create\" target=\"_blank\" rel=\"noopener\">传送门在此</a><br>我们的目的是要自定义菜单：<br>选择接口类型：自定义菜单<br>选择接口列表：自定义菜单创建接口/menu/create<br>这时候我们发现有一个参数列表，其中<code>access_token</code>是通过基础支持来获取的，<code>body</code>则是我们自定义菜单的json数据，具体怎么填写这两个参数如下：</p>\n<h2 id=\"access-token\"><a href=\"#access-token\" class=\"headerlink\" title=\"access_token\"></a><code>access_token</code></h2><p>还是在微信公众号接口调试工具的页面<br>接口类型：基础支持<br>接口列表：获取access token接口/token<br>参数列表：appid 这是我们申请的公众号的appid;secret 同上。如果我们申请了公众号，每个公众号都会有这两个值，直接复制这两个值填入相应的输入框，点击检查问题按钮便可以得到<code>access_token</code>。</p>\n<p>##<code>body</code><br>在这里主要是定义我们的自定义菜单类型，常见的有<code>click</code>,’view’,’pic_weixin’等，配置的格式举例如下：<br><code>{\n     &quot;button&quot;:[\n     {    \n          &quot;type&quot;:&quot;click&quot;,\n          &quot;name&quot;:&quot;今日歌曲&quot;,\n          &quot;key&quot;:&quot;V1001_TODAY_MUSIC&quot;\n      },\n      {\n                    &quot;type&quot;: &quot;pic_weixin&quot;, \n                    &quot;name&quot;: &quot;微信相册发图&quot;, \n                    &quot;key&quot;: &quot;rselfmenu_1_2&quot;, \n                    &quot;sub_button&quot;: [\n                     {    \n               &quot;type&quot;:&quot;view&quot;,\n               &quot;name&quot;:&quot;搜索&quot;,\n               &quot;url&quot;:&quot;http://www.soso.com/&quot;\n            },\n            {\n               &quot;type&quot;:&quot;view&quot;,\n               &quot;name&quot;:&quot;视频&quot;,\n               &quot;url&quot;:&quot;http://v.qq.com/&quot;\n            },\n            {\n               &quot;type&quot;:&quot;click&quot;,\n               &quot;name&quot;:&quot;赞一下我们&quot;,\n               &quot;key&quot;:&quot;V1001_GOOD&quot;\n            }]\n                }\n            ]</code><br>其中<code>sub_button</code>是二级菜单，它的数据格式也像一级菜单那样设置。</p>\n<p>以上的内容十分简单，并不需要任何编程知识。以后应该会主要更新自己学习<code>vue.js</code>和<code>webpack</code>的记录，希望自己能坚持下来！</p>\n"},{"title":"跨域与跨域访问","date":"2017-03-05T02:52:49.000Z","_content":"> 本文内容大部分转载自：[详解js跨域问题][1]\n跨域是指从一个域名的网页去请求另一个域名的资源。如果协议，域名，端口有任何一个不同，就是跨域。但是我们在写代码时，大多数都是要实现跨域获取资源，跨域通信的手段有：jsonp,document.domain,window.name,hash传值，postMessage，Access-Control-Allow-Origin.\n因为自己在实际的项目练习中，很少有与服务端通信的经验，所以只是暂时地做做笔记，加深理解。\n\n## 跨域资源共享(CORS)\n定义了必须在访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通。\n客户端在发送跨域请求时，发送一个带有Origin字段和http请求头信息：\n`Origin:http://xx.xx`(协议+域名+端口)\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果值是`*`，则接受任何来自其他域的请求，如果值是几个url，则在其中的url会被同意请求。\n\n## JSONP\n`JSONP`也叫填充式JSON，是应用JSON的一种新方法，只不过被包含在调用的JSON，例如：\n`callback({'name','abc'})`\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。\njq的例子：\n\n    <script type=\"text/javascript\">\n    $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){\n        //处理获得的json数据\n    });\n</script>\n\n**但是JSONP只能实现GET请求。**\n\n## document.domain\n\n例如http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n如在www.example.com设置：`document.domain = 'example.com';//设置成主域`.\n修改document.domain的方法只适用于不同子域的框架间的交互。\n\n## 使用window.name来进行跨域\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的\n\n## 使用HTML5的window.postMessage方法跨域\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法\n\n\n  [1]: https://segmentfault.com/a/1190000000718840#articleHeader1","source":"_posts/跨域.md","raw":"---\ntitle: 跨域与跨域访问\ndate: 2017-03-05 10:52:49\ntags: 跨域\n---\n> 本文内容大部分转载自：[详解js跨域问题][1]\n跨域是指从一个域名的网页去请求另一个域名的资源。如果协议，域名，端口有任何一个不同，就是跨域。但是我们在写代码时，大多数都是要实现跨域获取资源，跨域通信的手段有：jsonp,document.domain,window.name,hash传值，postMessage，Access-Control-Allow-Origin.\n因为自己在实际的项目练习中，很少有与服务端通信的经验，所以只是暂时地做做笔记，加深理解。\n\n## 跨域资源共享(CORS)\n定义了必须在访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通。\n客户端在发送跨域请求时，发送一个带有Origin字段和http请求头信息：\n`Origin:http://xx.xx`(协议+域名+端口)\n服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果值是`*`，则接受任何来自其他域的请求，如果值是几个url，则在其中的url会被同意请求。\n\n## JSONP\n`JSONP`也叫填充式JSON，是应用JSON的一种新方法，只不过被包含在调用的JSON，例如：\n`callback({'name','abc'})`\nJSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。\n\n在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。\njq的例子：\n\n    <script type=\"text/javascript\">\n    $.getJSON('http://example.com/data.php?callback=?,function(jsondata)'){\n        //处理获得的json数据\n    });\n</script>\n\n**但是JSONP只能实现GET请求。**\n\n## document.domain\n\n例如http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html 和 http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\n如在www.example.com设置：`document.domain = 'example.com';//设置成主域`.\n修改document.domain的方法只适用于不同子域的框架间的交互。\n\n## 使用window.name来进行跨域\nwindow对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的\n\n## 使用HTML5的window.postMessage方法跨域\nwindow.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法\n\n\n  [1]: https://segmentfault.com/a/1190000000718840#articleHeader1","slug":"跨域","published":1,"updated":"2019-03-17T03:04:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dy0012lvwvyu4v4kgu","content":"<blockquote>\n<p>本文内容大部分转载自：<a href=\"https://segmentfault.com/a/1190000000718840#articleHeader1\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br>跨域是指从一个域名的网页去请求另一个域名的资源。如果协议，域名，端口有任何一个不同，就是跨域。但是我们在写代码时，大多数都是要实现跨域获取资源，跨域通信的手段有：jsonp,document.domain,window.name,hash传值，postMessage，Access-Control-Allow-Origin.<br>因为自己在实际的项目练习中，很少有与服务端通信的经验，所以只是暂时地做做笔记，加深理解。</p>\n</blockquote>\n<h2 id=\"跨域资源共享-CORS\"><a href=\"#跨域资源共享-CORS\" class=\"headerlink\" title=\"跨域资源共享(CORS)\"></a>跨域资源共享(CORS)</h2><p>定义了必须在访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通。<br>客户端在发送跨域请求时，发送一个带有Origin字段和http请求头信息：<br><code>Origin:http://xx.xx</code>(协议+域名+端口)<br>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果值是<code>*</code>，则接受任何来自其他域的请求，如果值是几个url，则在其中的url会被同意请求。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p><code>JSONP</code>也叫填充式JSON，是应用JSON的一种新方法，只不过被包含在调用的JSON，例如：<br><code>callback({&#39;name&#39;,&#39;abc&#39;})</code><br>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。<br>jq的例子：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n$.getJSON(&apos;http://example.com/data.php?callback=?,function(jsondata)&apos;){\n    //处理获得的json数据\n});\n</code></pre><p></p>\n<p><strong>但是JSONP只能实现GET请求。</strong></p>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>例如<a href=\"http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html</a> 和 <a href=\"http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"noopener\">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a><br>如在www.example.com设置：<code>document.domain = &#39;example.com&#39;;//设置成主域</code>.<br>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h2 id=\"使用window-name来进行跨域\"><a href=\"#使用window-name来进行跨域\" class=\"headerlink\" title=\"使用window.name来进行跨域\"></a>使用window.name来进行跨域</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h2 id=\"使用HTML5的window-postMessage方法跨域\"><a href=\"#使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"使用HTML5的window.postMessage方法跨域\"></a>使用HTML5的window.postMessage方法跨域</h2><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>本文内容大部分转载自：<a href=\"https://segmentfault.com/a/1190000000718840#articleHeader1\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br>跨域是指从一个域名的网页去请求另一个域名的资源。如果协议，域名，端口有任何一个不同，就是跨域。但是我们在写代码时，大多数都是要实现跨域获取资源，跨域通信的手段有：jsonp,document.domain,window.name,hash传值，postMessage，Access-Control-Allow-Origin.<br>因为自己在实际的项目练习中，很少有与服务端通信的经验，所以只是暂时地做做笔记，加深理解。</p>\n</blockquote>\n<h2 id=\"跨域资源共享-CORS\"><a href=\"#跨域资源共享-CORS\" class=\"headerlink\" title=\"跨域资源共享(CORS)\"></a>跨域资源共享(CORS)</h2><p>定义了必须在访问跨域资源时，浏览器和服务器应该如何沟通。CORS背后的基本思想是使用自定义的HTTP头部让浏览器与服务器进行沟通。<br>客户端在发送跨域请求时，发送一个带有Origin字段和http请求头信息：<br><code>Origin:http://xx.xx</code>(协议+域名+端口)<br>服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果值是<code>*</code>，则接受任何来自其他域的请求，如果值是几个url，则在其中的url会被同意请求。</p>\n<h2 id=\"JSONP\"><a href=\"#JSONP\" class=\"headerlink\" title=\"JSONP\"></a>JSONP</h2><p><code>JSONP</code>也叫填充式JSON，是应用JSON的一种新方法，只不过被包含在调用的JSON，例如：<br><code>callback({&#39;name&#39;,&#39;abc&#39;})</code><br>JSONP由两部分组成：回调函数和数据。回调函数是当响应到来时应该在页面中调用的函数，而数据就是传入回调函数中的JSON数据。</p>\n<p>在js中，我们直接用XMLHttpRequest请求不同域上的数据时，是不可以的。但是，在页面上引入不同域上的js脚本文件却是可以的，jsonp正是利用这个特性来实现的。<br>jq的例子：</p>\n<pre><code>&lt;script type=&quot;text/javascript&quot;&gt;\n$.getJSON(&apos;http://example.com/data.php?callback=?,function(jsondata)&apos;){\n    //处理获得的json数据\n});\n</code></pre><p></p>\n<p><strong>但是JSONP只能实现GET请求。</strong></p>\n<h2 id=\"document-domain\"><a href=\"#document-domain\" class=\"headerlink\" title=\"document.domain\"></a>document.domain</h2><p>例如<a href=\"http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html\" target=\"_blank\" rel=\"noopener\">http://www.exampe.com/a.html想访问到http://example.com/b.html,这个时候，document.domain就可以派上用场了，我们只要把http://www.example.com/a.html</a> 和 <a href=\"http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。\" target=\"_blank\" rel=\"noopener\">http://example.com/b.html这两个页面的document.domain都设成相同的域名就可以了。但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同。</a><br>如在www.example.com设置：<code>document.domain = &#39;example.com&#39;;//设置成主域</code>.<br>修改document.domain的方法只适用于不同子域的框架间的交互。</p>\n<h2 id=\"使用window-name来进行跨域\"><a href=\"#使用window-name来进行跨域\" class=\"headerlink\" title=\"使用window.name来进行跨域\"></a>使用window.name来进行跨域</h2><p>window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的</p>\n<h2 id=\"使用HTML5的window-postMessage方法跨域\"><a href=\"#使用HTML5的window-postMessage方法跨域\" class=\"headerlink\" title=\"使用HTML5的window.postMessage方法跨域\"></a>使用HTML5的window.postMessage方法跨域</h2><p>window.postMessage(message,targetOrigin) 方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法</p>\n"},{"title":"轮播图插件封装","date":"2017-02-22T15:17:04.000Z","_content":"> 之前写了一个轮播图的功能实现，给前辈看了下代码，收获很多。总结了一下自己之前代码的问题和讨论一下jQuery插件封装的套路。\n\n# 之前代码的坑\n 1. reset style\n    自己在写css时写的reset针对了所有`*`，有一些没必要reset的会因此    也去查找，避免耗费资源以后千万记得针对需要的标签做reset就可以，    网络上也有很多reset的样式。\n\n 2. 命名规范\n    在写HTML的class时使用`-`分割名字，如：`class=\"nav-box\"`。\n    写HTML的id时，使用驼峰式命名，如：`id=navBox`。\n    在JavaScript中，变量同样使用驼峰命名。\n    在JavaScript中，变量对象使用`$`开头，如：`var $el=$('html')`。\n    函数中的私有变量对象使用下划线开头，如：`var _this=$(this)`。\n\n 3. 选择器不能大于3层，选择器是从右到左。\n \n 4. css的一些属性一定要记得写兼容。\n \n 5. +1或者-1的时候根据需求尽量用自增或自减，减少代码量。\n \n 6. 使用rgba()函数时要注意兼容IE8\n `background: rgba(255,255,255,.1);\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);`\n\n 7. link type=text/css 已经不用写了。\n \n 8. 还有a标签里放#会直接跳的\n    正确的姿势应该是这样的：`href=javascript:;`\n\n# jQuery封装插件\n\n 为了避免和其他JavaScript库冲突，我们最好将jQuery传递给一个自我执行的封闭程序，jQuery在此程序中映射为$符号，这样可以避免$号被其他库覆写。\n \n\n    (function($) {\n    $.fn.m​​yPlugin = function() {\n        //你自己的插件代码\n    };\n})(jQuery);\n\n插件封装的模板如下：\n\n    (function($){ \n    //插件名字\n\tvar pluginName = \"myTab\";\n\t//插件的默认配置\n\tvar defaults = {\n\t\t....\n\t}\n\n\tfunction Plugin(element,options){\n\t\tthis.element = element;\n\t\t/*对于比较复杂的和提供了许多选项可定制的的插件，最好有一个当插件被调用的时候可以被拓展的默认设置(通过使用$.extend)。*/\n    this.options = $.extend({},defaults,options);\n\n\t\tthis.init();\n\t}\n\t\n\t//初始化方法\n\tPlugin.prototype.init = function(){\n        ...\n\t}\n\t\n\t//暴露方法\n\t$.fn[pluginName] = function(options){\n\t    //保持chainability，这样jQuery收集的元素可以继续被jQuery方法如.css控制\n\t\treturn this.each(function(){\n\t\t\tif(!$.data(this,'plugin_'+pluginName)){\n\t\t\t\t$.data(this,'plugin_'+pluginName,new Plugin(this,options));\n\t\t\t}\n\t\t});\n\t}\n    })(jQuery);\n\n## 总结\n\n编写jQuery插件允许你做出库，将最有用的功能集成到可重用的代码，可以节省开发者的时间，使开发更高效。 开发jQuery插件时，要牢记：\n\n 1. 始终包裹在一个封闭的插件：\n\n    (function($) {\n       /* plugin goes here */\n    })(jQuery);\n\n 2. 不要冗余包裹this关键字在插件的功能范围内；\n\n 3.除非插件返回特定值，否则总是返回this关键字来维持chainability；\n\n 4. 传递一个可拓展的默认对象参数而不是大量的参数给插件；\n\n 5. 不要在一个插件中多次命名不同方法；\n\n 6. 始终命名空间的方法，事件和数据；\n","source":"_posts/轮播图插件封装.md","raw":"---\ntitle: 轮播图插件封装\ndate: 2017-02-22 23:17:04\ntags: jQuery\n---\n> 之前写了一个轮播图的功能实现，给前辈看了下代码，收获很多。总结了一下自己之前代码的问题和讨论一下jQuery插件封装的套路。\n\n# 之前代码的坑\n 1. reset style\n    自己在写css时写的reset针对了所有`*`，有一些没必要reset的会因此    也去查找，避免耗费资源以后千万记得针对需要的标签做reset就可以，    网络上也有很多reset的样式。\n\n 2. 命名规范\n    在写HTML的class时使用`-`分割名字，如：`class=\"nav-box\"`。\n    写HTML的id时，使用驼峰式命名，如：`id=navBox`。\n    在JavaScript中，变量同样使用驼峰命名。\n    在JavaScript中，变量对象使用`$`开头，如：`var $el=$('html')`。\n    函数中的私有变量对象使用下划线开头，如：`var _this=$(this)`。\n\n 3. 选择器不能大于3层，选择器是从右到左。\n \n 4. css的一些属性一定要记得写兼容。\n \n 5. +1或者-1的时候根据需求尽量用自增或自减，减少代码量。\n \n 6. 使用rgba()函数时要注意兼容IE8\n `background: rgba(255,255,255,.1);\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);`\n\n 7. link type=text/css 已经不用写了。\n \n 8. 还有a标签里放#会直接跳的\n    正确的姿势应该是这样的：`href=javascript:;`\n\n# jQuery封装插件\n\n 为了避免和其他JavaScript库冲突，我们最好将jQuery传递给一个自我执行的封闭程序，jQuery在此程序中映射为$符号，这样可以避免$号被其他库覆写。\n \n\n    (function($) {\n    $.fn.m​​yPlugin = function() {\n        //你自己的插件代码\n    };\n})(jQuery);\n\n插件封装的模板如下：\n\n    (function($){ \n    //插件名字\n\tvar pluginName = \"myTab\";\n\t//插件的默认配置\n\tvar defaults = {\n\t\t....\n\t}\n\n\tfunction Plugin(element,options){\n\t\tthis.element = element;\n\t\t/*对于比较复杂的和提供了许多选项可定制的的插件，最好有一个当插件被调用的时候可以被拓展的默认设置(通过使用$.extend)。*/\n    this.options = $.extend({},defaults,options);\n\n\t\tthis.init();\n\t}\n\t\n\t//初始化方法\n\tPlugin.prototype.init = function(){\n        ...\n\t}\n\t\n\t//暴露方法\n\t$.fn[pluginName] = function(options){\n\t    //保持chainability，这样jQuery收集的元素可以继续被jQuery方法如.css控制\n\t\treturn this.each(function(){\n\t\t\tif(!$.data(this,'plugin_'+pluginName)){\n\t\t\t\t$.data(this,'plugin_'+pluginName,new Plugin(this,options));\n\t\t\t}\n\t\t});\n\t}\n    })(jQuery);\n\n## 总结\n\n编写jQuery插件允许你做出库，将最有用的功能集成到可重用的代码，可以节省开发者的时间，使开发更高效。 开发jQuery插件时，要牢记：\n\n 1. 始终包裹在一个封闭的插件：\n\n    (function($) {\n       /* plugin goes here */\n    })(jQuery);\n\n 2. 不要冗余包裹this关键字在插件的功能范围内；\n\n 3.除非插件返回特定值，否则总是返回this关键字来维持chainability；\n\n 4. 传递一个可拓展的默认对象参数而不是大量的参数给插件；\n\n 5. 不要在一个插件中多次命名不同方法；\n\n 6. 始终命名空间的方法，事件和数据；\n","slug":"轮播图插件封装","published":1,"updated":"2019-03-17T03:04:24.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjumvx6dz0014lvwv9t2pbkmt","content":"<blockquote>\n<p>之前写了一个轮播图的功能实现，给前辈看了下代码，收获很多。总结了一下自己之前代码的问题和讨论一下jQuery插件封装的套路。</p>\n</blockquote>\n<h1 id=\"之前代码的坑\"><a href=\"#之前代码的坑\" class=\"headerlink\" title=\"之前代码的坑\"></a>之前代码的坑</h1><ol>\n<li><p>reset style<br>自己在写css时写的reset针对了所有<code>*</code>，有一些没必要reset的会因此    也去查找，避免耗费资源以后千万记得针对需要的标签做reset就可以，    网络上也有很多reset的样式。</p>\n</li>\n<li><p>命名规范<br>在写HTML的class时使用<code>-</code>分割名字，如：<code>class=&quot;nav-box&quot;</code>。<br>写HTML的id时，使用驼峰式命名，如：<code>id=navBox</code>。<br>在JavaScript中，变量同样使用驼峰命名。<br>在JavaScript中，变量对象使用<code>$</code>开头，如：<code>var $el=$(&#39;html&#39;)</code>。<br>函数中的私有变量对象使用下划线开头，如：<code>var _this=$(this)</code>。</p>\n</li>\n<li><p>选择器不能大于3层，选择器是从右到左。</p>\n</li>\n<li><p>css的一些属性一定要记得写兼容。</p>\n</li>\n<li><p>+1或者-1的时候根据需求尽量用自增或自减，减少代码量。</p>\n</li>\n<li><p>使用rgba()函数时要注意兼容IE8<br><code>background: rgba(255,255,255,.1);\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);</code></p>\n</li>\n<li><p>link type=text/css 已经不用写了。</p>\n</li>\n<li><p>还有a标签里放#会直接跳的<br>正确的姿势应该是这样的：<code>href=javascript:;</code></p>\n</li>\n</ol>\n<h1 id=\"jQuery封装插件\"><a href=\"#jQuery封装插件\" class=\"headerlink\" title=\"jQuery封装插件\"></a>jQuery封装插件</h1><p> 为了避免和其他JavaScript库冲突，我们最好将jQuery传递给一个自我执行的封闭程序，jQuery在此程序中映射为$符号，这样可以避免$号被其他库覆写。</p>\n<pre><code>(function($) {\n$.fn.m​​yPlugin = function() {\n    //你自己的插件代码\n};\n</code></pre><p>})(jQuery);</p>\n<p>插件封装的模板如下：</p>\n<pre><code>(function($){ \n//插件名字\nvar pluginName = &quot;myTab&quot;;\n//插件的默认配置\nvar defaults = {\n    ....\n}\n\nfunction Plugin(element,options){\n    this.element = element;\n    /*对于比较复杂的和提供了许多选项可定制的的插件，最好有一个当插件被调用的时候可以被拓展的默认设置(通过使用$.extend)。*/\nthis.options = $.extend({},defaults,options);\n\n    this.init();\n}\n\n//初始化方法\nPlugin.prototype.init = function(){\n    ...\n}\n\n//暴露方法\n$.fn[pluginName] = function(options){\n    //保持chainability，这样jQuery收集的元素可以继续被jQuery方法如.css控制\n    return this.each(function(){\n        if(!$.data(this,&apos;plugin_&apos;+pluginName)){\n            $.data(this,&apos;plugin_&apos;+pluginName,new Plugin(this,options));\n        }\n    });\n}\n})(jQuery);\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编写jQuery插件允许你做出库，将最有用的功能集成到可重用的代码，可以节省开发者的时间，使开发更高效。 开发jQuery插件时，要牢记：</p>\n<ol>\n<li><p>始终包裹在一个封闭的插件：</p>\n<p>(function($) {<br>   /<em> plugin goes here </em>/<br>})(jQuery);</p>\n</li>\n<li><p>不要冗余包裹this关键字在插件的功能范围内；</p>\n<p>3.除非插件返回特定值，否则总是返回this关键字来维持chainability；</p>\n</li>\n<li><p>传递一个可拓展的默认对象参数而不是大量的参数给插件；</p>\n</li>\n<li><p>不要在一个插件中多次命名不同方法；</p>\n</li>\n<li><p>始终命名空间的方法，事件和数据；</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>之前写了一个轮播图的功能实现，给前辈看了下代码，收获很多。总结了一下自己之前代码的问题和讨论一下jQuery插件封装的套路。</p>\n</blockquote>\n<h1 id=\"之前代码的坑\"><a href=\"#之前代码的坑\" class=\"headerlink\" title=\"之前代码的坑\"></a>之前代码的坑</h1><ol>\n<li><p>reset style<br>自己在写css时写的reset针对了所有<code>*</code>，有一些没必要reset的会因此    也去查找，避免耗费资源以后千万记得针对需要的标签做reset就可以，    网络上也有很多reset的样式。</p>\n</li>\n<li><p>命名规范<br>在写HTML的class时使用<code>-</code>分割名字，如：<code>class=&quot;nav-box&quot;</code>。<br>写HTML的id时，使用驼峰式命名，如：<code>id=navBox</code>。<br>在JavaScript中，变量同样使用驼峰命名。<br>在JavaScript中，变量对象使用<code>$</code>开头，如：<code>var $el=$(&#39;html&#39;)</code>。<br>函数中的私有变量对象使用下划线开头，如：<code>var _this=$(this)</code>。</p>\n</li>\n<li><p>选择器不能大于3层，选择器是从右到左。</p>\n</li>\n<li><p>css的一些属性一定要记得写兼容。</p>\n</li>\n<li><p>+1或者-1的时候根据需求尽量用自增或自减，减少代码量。</p>\n</li>\n<li><p>使用rgba()函数时要注意兼容IE8<br><code>background: rgba(255,255,255,.1);\nfilter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#19ffffff,endColorstr=#19ffffff);</code></p>\n</li>\n<li><p>link type=text/css 已经不用写了。</p>\n</li>\n<li><p>还有a标签里放#会直接跳的<br>正确的姿势应该是这样的：<code>href=javascript:;</code></p>\n</li>\n</ol>\n<h1 id=\"jQuery封装插件\"><a href=\"#jQuery封装插件\" class=\"headerlink\" title=\"jQuery封装插件\"></a>jQuery封装插件</h1><p> 为了避免和其他JavaScript库冲突，我们最好将jQuery传递给一个自我执行的封闭程序，jQuery在此程序中映射为$符号，这样可以避免$号被其他库覆写。</p>\n<pre><code>(function($) {\n$.fn.m​​yPlugin = function() {\n    //你自己的插件代码\n};\n</code></pre><p>})(jQuery);</p>\n<p>插件封装的模板如下：</p>\n<pre><code>(function($){ \n//插件名字\nvar pluginName = &quot;myTab&quot;;\n//插件的默认配置\nvar defaults = {\n    ....\n}\n\nfunction Plugin(element,options){\n    this.element = element;\n    /*对于比较复杂的和提供了许多选项可定制的的插件，最好有一个当插件被调用的时候可以被拓展的默认设置(通过使用$.extend)。*/\nthis.options = $.extend({},defaults,options);\n\n    this.init();\n}\n\n//初始化方法\nPlugin.prototype.init = function(){\n    ...\n}\n\n//暴露方法\n$.fn[pluginName] = function(options){\n    //保持chainability，这样jQuery收集的元素可以继续被jQuery方法如.css控制\n    return this.each(function(){\n        if(!$.data(this,&apos;plugin_&apos;+pluginName)){\n            $.data(this,&apos;plugin_&apos;+pluginName,new Plugin(this,options));\n        }\n    });\n}\n})(jQuery);\n</code></pre><h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>编写jQuery插件允许你做出库，将最有用的功能集成到可重用的代码，可以节省开发者的时间，使开发更高效。 开发jQuery插件时，要牢记：</p>\n<ol>\n<li><p>始终包裹在一个封闭的插件：</p>\n<p>(function($) {<br>   /<em> plugin goes here </em>/<br>})(jQuery);</p>\n</li>\n<li><p>不要冗余包裹this关键字在插件的功能范围内；</p>\n<p>3.除非插件返回特定值，否则总是返回this关键字来维持chainability；</p>\n</li>\n<li><p>传递一个可拓展的默认对象参数而不是大量的参数给插件；</p>\n</li>\n<li><p>不要在一个插件中多次命名不同方法；</p>\n</li>\n<li><p>始终命名空间的方法，事件和数据；</p>\n</li>\n</ol>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjumvx6dc0000lvwv2u1tw7wy","tag_id":"cjumvx6di0004lvwvo6hfj95r","_id":"cjumvx6dm0009lvwvs1qzsxry"},{"post_id":"cjumvx6dh0002lvwvzi4w7u97","tag_id":"cjumvx6dl0008lvwvq0aq9o6o","_id":"cjumvx6dp000elvwv47zag61x"},{"post_id":"cjumvx6dj0005lvwvurt21bo7","tag_id":"cjumvx6di0004lvwvo6hfj95r","_id":"cjumvx6dq000ilvwv44x4ehza"},{"post_id":"cjumvx6dk0006lvwv9lrttyif","tag_id":"cjumvx6dq000glvwvxwr5ff2l","_id":"cjumvx6ds000mlvwvxrjhwtfq"},{"post_id":"cjumvx6dl0007lvwvjmkzpxs9","tag_id":"cjumvx6dr000klvwvz3q8dkgr","_id":"cjumvx6du000qlvwvn4gnokzn"},{"post_id":"cjumvx6dm000alvwvi6ts25p7","tag_id":"cjumvx6dr000klvwvz3q8dkgr","_id":"cjumvx6dv000ulvwvnhj28fcn"},{"post_id":"cjumvx6dm000blvwvtcewsumx","tag_id":"cjumvx6du000slvwv2mj2mvzr","_id":"cjumvx6dx000ylvwvq8qflj71"},{"post_id":"cjumvx6dp000flvwvs8i4oy0l","tag_id":"cjumvx6dw000xlvwvt8jekhre","_id":"cjumvx6dy0013lvwv54o6f8fh"},{"post_id":"cjumvx6dq000hlvwvqlzvr2ky","tag_id":"cjumvx6dy0011lvwvk3h47c11","_id":"cjumvx6dz0016lvwvgh90u43q"},{"post_id":"cjumvx6dz0014lvwv9t2pbkmt","tag_id":"cjumvx6dw000xlvwvt8jekhre","_id":"cjumvx6e00017lvwvf4apgw4r"},{"post_id":"cjumvx6dr000jlvwvvnqfumt5","tag_id":"cjumvx6dz0015lvwvjilb9s5h","_id":"cjumvx6e00019lvwvzryac05b"},{"post_id":"cjumvx6dr000llvwv3iiblr7q","tag_id":"cjumvx6e00018lvwvfpxu78ph","_id":"cjumvx6e0001blvwvpme8s2e0"},{"post_id":"cjumvx6ds000nlvwvas3jnn5i","tag_id":"cjumvx6e0001alvwvtgz7dep6","_id":"cjumvx6e0001dlvwvozykdruw"},{"post_id":"cjumvx6dt000plvwvrlcke72k","tag_id":"cjumvx6e0001clvwv7e5j5a65","_id":"cjumvx6e1001flvwvzved6ti2"},{"post_id":"cjumvx6du000rlvwvm27qa3ve","tag_id":"cjumvx6e0001alvwvtgz7dep6","_id":"cjumvx6e1001hlvwv9eqyztpd"},{"post_id":"cjumvx6dv000tlvwvxjmx77h6","tag_id":"cjumvx6e1001glvwvpzmj2qqr","_id":"cjumvx6e2001jlvwvlrnny37c"},{"post_id":"cjumvx6dv000vlvwvujg58vhd","tag_id":"cjumvx6e1001ilvwvxxh6r8ts","_id":"cjumvx6e2001llvwvzo6e5pxz"},{"post_id":"cjumvx6dw000wlvwv41dmemr2","tag_id":"cjumvx6e2001klvwvpe41r2zg","_id":"cjumvx6e2001nlvwvp6yapzn4"},{"post_id":"cjumvx6dx000zlvwv0s8tbv27","tag_id":"cjumvx6e2001mlvwve6qqa8if","_id":"cjumvx6e2001plvwvl2xnl4pl"},{"post_id":"cjumvx6dx0010lvwv7q4expiz","tag_id":"cjumvx6e2001olvwvobfgz59j","_id":"cjumvx6e3001rlvwv1lz9keg9"},{"post_id":"cjumvx6dy0012lvwvyu4v4kgu","tag_id":"cjumvx6e3001qlvwv1lfuvcoc","_id":"cjumvx6e3001slvwv53z8ttd6"}],"Tag":[{"name":"AngularJS","_id":"cjumvx6di0004lvwvo6hfj95r"},{"name":"Bootstrap 响应式开发","_id":"cjumvx6dl0008lvwvq0aq9o6o"},{"name":"hexo","_id":"cjumvx6dq000glvwvxwr5ff2l"},{"name":"Less","_id":"cjumvx6dr000klvwvz3q8dkgr"},{"name":"HTML5","_id":"cjumvx6du000slvwv2mj2mvzr"},{"name":"jQuery","_id":"cjumvx6dw000xlvwvt8jekhre"},{"name":"Ajax","_id":"cjumvx6dy0011lvwvk3h47c11"},{"name":"javascript this","_id":"cjumvx6dz0015lvwvjilb9s5h"},{"name":"microtask macrotask","_id":"cjumvx6e00018lvwvfpxu78ph"},{"name":"javascript","_id":"cjumvx6e0001alvwvtgz7dep6"},{"name":"php","_id":"cjumvx6e0001clvwv7e5j5a65"},{"name":"xss","_id":"cjumvx6e1001glvwvpzmj2qqr"},{"name":"ES6","_id":"cjumvx6e1001ilvwvxxh6r8ts"},{"name":"HTML5 CSS3","_id":"cjumvx6e2001klvwvpe41r2zg"},{"name":"redis 循环","_id":"cjumvx6e2001mlvwve6qqa8if"},{"name":"微信公众号","_id":"cjumvx6e2001olvwvobfgz59j"},{"name":"跨域","_id":"cjumvx6e3001qlvwv1lfuvcoc"}]}}